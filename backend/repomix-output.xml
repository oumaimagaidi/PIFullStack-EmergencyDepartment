This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.babelrc
.gitignore
config/tesseract.config.js
db.js
middleware/authMiddleware.js
middleware/fileUpload.js
middleware/uploadMiddleware.js
models/Alert.js
models/Ambulance.js
models/AmbulanceRequest.js
models/Annotation.js
models/AuditLog.js
models/BloodRequest.js
models/DonationPledge.js
models/EmergencyPatient.js
models/Feedback.js
models/MedicalRecord.js
models/Notification.js
models/OcrResult.js
models/PatientFile.js
models/pdfGenerator.js
models/Resource.js
models/SharedMedicalRecord.js
models/User.js
package.json
routes/ai.js
routes/alerts.js
routes/ambulance.js
routes/ambulanceRequests.js
routes/annotation.js
routes/archive.js
routes/auth copy.js
routes/auth.js
routes/bloodRequests.js
routes/chatbot.js
routes/emergencyPatients.js
routes/feedback.js
routes/medicalRecords.js
routes/notifications.js
routes/ocr.js
routes/patient.js
routes/patientFile.js
routes/profile.js
routes/resource.js
routes/users.js
sendSMS.js
server.js
services/aiService.js
services/classifierService.js
services/emailService.js
services/huggingFaceQAService.js
services/ocrService.js
services/otpService.js
services/simpleSymptomHelper.js
services/waitTimeService.js
socketManager.js
templates/medicalRecordTemplate.html
utils/pdfGenerator.js
utils/pdfProcessor.js
utils/textParser.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".babelrc">
{
    "presets": ["@babel/preset-env"]
  }
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
/backend/node_modules
/frontend/node_modules

# testing
/coverage

# production
/build
</file>

<file path="config/tesseract.config.js">
import multer from "multer";
import { v4 as uuidv4 } from "uuid";
import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    try {
      const uploadPath = path.resolve(__dirname, "../../../uploads/pdfs");
      await fs.ensureDir(uploadPath);
      cb(null, uploadPath);
    } catch (err) {
      cb(err);
    }
  },
  filename: (req, file, cb) => {
    const uniqueName = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueName);
  }
});

const fileFilter = (req, file, cb) => {
  if (file.mimetype === "application/pdf") {
    cb(null, true);
  } else {
    cb(new Error("Seuls les fichiers PDF sont autoris√©s"), false);
  }
};

export const uploadPDF = multer({
  storage,
  fileFilter,
  limits: { fileSize: 25 * 1024 * 1024 } // 25MB
});
</file>

<file path="db.js">
import mongoose from "mongoose";

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log("Connected to database successfully");
  } catch (error) {
    console.error("Could not connect to database!", error);
    process.exit(1);
  }
};

export default connectDB;
</file>

<file path="middleware/authMiddleware.js">
import jwt from "jsonwebtoken";
import dotenv from "dotenv";

dotenv.config();

export const authenticateToken = (req, res, next) => {
  // Try to get the token from cookies first, then check Authorization header
  const token = req.cookies?.token || req.header("Authorization")?.split(" ")[1];
  if (!token) {
    return res.status(401).json({ message: "Acc√®s refus√©, aucun token fourni" });
  }

  try {
    const verified = jwt.verify(token, process.env.JWT_SECRET);
    req.user = verified; // Attach user data to request object
    next();
  } catch (error) {
    return res.status(403).json({ message: "Token invalide", error });
  }
};
export const authorize = (roles) => {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s interdit : r√¥le non autoris√©" });
    }
    next();
  };
};
</file>

<file path="middleware/fileUpload.js">
import multer from 'multer';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs-extra';

// Configuration __dirname pour ES Modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Configuration stockage pour images
const imageStorage = multer.diskStorage({
  destination: async (req, file, cb) => {
    try {
      const uploadDir = join(__dirname, '../uploads/images');
      await fs.ensureDir(uploadDir);
      cb(null, uploadDir);
    } catch (error) {
      cb(error);
    }
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  }
});

// Middleware d'upload pour images
export const uploadImage = multer({
  storage: imageStorage,
  fileFilter: (req, file, cb) => {
    const allowedMimeTypes = [
      'image/jpeg',
      'image/png',
      'image/webp'
    ];

    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Type de fichier non autoris√©. Seules les images JPEG, PNG et WebP sont accept√©es.'));
    }
  },
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  }
});
</file>

<file path="middleware/uploadMiddleware.js">
import multer from "multer";
import path from "path";

// Configuration de Multer
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "uploads/"); // Dossier o√π enregistrer les images
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname)); // Nom unique
  },
});

const upload = multer({ storage: storage });

export default upload;
</file>

<file path="models/Alert.js">
import mongoose from "mongoose";

const AlertSchema = new mongoose.Schema({
  message: {
    type: String,
    required: true,
  },
  // optional free‚Äëform source identifier (e.g. "Ambulance #123", "System", etc.)
  source: {
    type: String,
    default: null,
  },
  timestamp: {
    type: Date,
    default: Date.now,
  },
});

export default mongoose.model("Alert", AlertSchema);
</file>

<file path="models/Ambulance.js">
import mongoose from 'mongoose';

const AmbulanceSchema = new mongoose.Schema({
  name : { type: String, required: true },
  latitude: { type: Number, required: true },
  longitude: { type: Number, required: true },
  status: { 
    type: String, 
    enum: ['OFF_DUTY', 'AVAILABLE', 'ON_MISSION', 'MAINTENANCE'], 
    required: true 
  },
  drivers: [{
    type: String,
    ref: "Driver",
    required: [false, "Driver ID is required"],
  }],
    mobile: {
    type: String,
    required: [false, "Mobile number is required"],
    match: [/^[0-9]{8,15}$/, "Please enter a valid mobile number (8-15 digits)"],
    unique: true
  },
  
  destination: { type: String, default: null },
  lastUpdated: { type: Date, default: Date.now },
  team: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
}); 

const Ambulance = mongoose.model('Ambulance', AmbulanceSchema);
export default Ambulance;
</file>

<file path="models/AmbulanceRequest.js">
import mongoose from 'mongoose';

const AmbulanceRequestSchema = new mongoose.Schema({
  patient: {
    name: { type: String, required: true },
    phone: { 
      type: String, 
      required: true,
      match: [/^[0-9]{8,15}$/, "Please enter a valid phone number"]
    },
    location: {
      latitude: { type: Number }, // Removed required: true
      longitude: { type: Number } // Removed required: true
    }
  },
  ambulance: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Ambulance' // Removed required: true
  },
  status: {
    type: String,
    enum: ['PENDING', 'ACCEPTED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'],
    default: 'PENDING'
  },
  emergencyType: {
    type: String,
    required: true,
    enum: ['CRITICAL', 'URGENT', 'NON_URGENT']
  },
  description: {
    type: String,
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Update the updatedAt timestamp before saving
AmbulanceRequestSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

const AmbulanceRequest = mongoose.model('AmbulanceRequest', AmbulanceRequestSchema);
export default AmbulanceRequest;
</file>

<file path="models/Annotation.js">
import mongoose from "mongoose"

const AnnotationSchema = new mongoose.Schema(
  {
    patientFileId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "PatientFile",
      required: true,
    },
    authorId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    text: {
      type: String,
      required: true,
    },
    position: {
      x: Number,
      y: Number,
    },
    type: {
      type: String,
      enum: ["comment", "highlight", "warning", "question"],
      default: "comment",
    },
    color: {
      type: String,
      default: "#FFD700", // Default yellow color
    },
    isResolved: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true },
)

export default mongoose.model("Annotation", AnnotationSchema)
</file>

<file path="models/AuditLog.js">
import mongoose from "mongoose";

const AuditLogSchema = new mongoose.Schema(
  {
    action: {
      type: String,
      required: true,
    },
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    details: {
      type: String,
      required: true,
    },
  },
  { timestamps: true }
);

export default mongoose.model("AuditLog", AuditLogSchema);
</file>

<file path="models/BloodRequest.js">
import mongoose from "mongoose";

const BloodRequestSchema = new mongoose.Schema(
  {
    patientId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "EmergencyPatient", 
      required: true,
    },
    requestingStaffId: {
      // The Doctor or Nurse who created the request
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    bloodTypeNeeded: {
      // e.g., "O+", "A-", "AB+", "Universal Donor Needed"
      type: String,
      required: true,
      enum: ["A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-", "Any"], // Or more specific if needed
    },
    quantityNeeded: {
      // e.g., number of units
      type: Number,
      required: true,
      min: 1,
    },
    quantityFulfilled: {
      type: Number,
      default: 0,
      min: 0,
    },
    urgency: {
      type: String,
      required: true,
      enum: ["Critical", "Urgent", "Standard"], // Critical (immediate), Urgent (within hours), Standard (within 24-48h)
      default: "Urgent",
    },
    reason: {
      // Brief reason for the request (e.g., "Surgery", "Trauma", "Anemia")
      type: String,
      required: false, // Optional but good to have
    },
    hospitalLocation: {
      // Specific hospital or department where donation/blood is needed
      type: String,
      required: true, // e.g., "Main Hospital - Blood Bank", "ER Department A"
    },
    contactPerson: {
      // Name or department to contact for donation inquiries
      type: String,
      required: false,
    },
    contactPhone: {
      // Phone number for donation inquiries
      type: String,
      required: false,
    },
    status: {
      type: String,
      required: true,
      enum: ["Open", "Partially Fulfilled", "Fulfilled", "Closed", "Cancelled"],
      default: "Open",
    },
    notes: {
      // Any additional notes for staff or potential donors
      type: String,
      required: false,
    },
    expiresAt: {
      // Optional: When the request is no longer valid
      type: Date,
      required: false,
    },
  },
  { timestamps: true } // Adds createdAt and updatedAt automatically
);

// Indexing for better query performance
BloodRequestSchema.index({ status: 1, bloodTypeNeeded: 1, urgency: 1 });
BloodRequestSchema.index({ patientId: 1 });

const BloodRequest = mongoose.model("BloodRequest", BloodRequestSchema);

export default BloodRequest;
</file>

<file path="models/DonationPledge.js">
import mongoose from "mongoose";

const DonationPledgeSchema = new mongoose.Schema(
  {
    bloodRequestId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "BloodRequest",
      required: true,
    },
    donorUserId: { // The user who is pledging to donate
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    donorName: { // Store name at time of pledge for easier display
        type: String,
        required: true,
    },
    donorContactPhone: {
        type: String,
        required: true,
    },
    donorBloodType: { // Good to confirm, though the request has the needed type
        type: String,
        required: true,
        enum: ["A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-", "Unknown"],
    },
    pledgedQuantity: { // How many units they are pledging
        type: Number,
        required: true,
        min: 1,
        default: 1,
    },
    status: { // Status of this specific pledge
      type: String,
      enum: ["Pledged", "Scheduled", "Donated", "Cancelled"],
      default: "Pledged",
    },
    donationDateScheduled: { // Optional: if a specific date is scheduled
        type: Date,
    },
    donationNotes: { // Any notes from the donor
        type: String,
    }
  },
  { timestamps: true }
);

DonationPledgeSchema.index({ bloodRequestId: 1, donorUserId: 1 }); // Optimize queries

const DonationPledge = mongoose.model("DonationPledge", DonationPledgeSchema);

export default DonationPledge;
</file>

<file path="models/EmergencyPatient.js">
// backend/models/EmergencyPatient.js
import mongoose from 'mongoose';
import { v4 as uuidv4 } from 'uuid';

const emergencyPatientSchema = new mongoose.Schema({
    firstName: { type: String, required: true },
    lastName: { type: String, required: true },
    dateOfBirth: { type: String, required: true },
    gender: { type: String, required: true, enum: ['male', 'female', 'other'] },
    phoneNumber: { type: String, required: true },
    email: {
        type: String,
        validate: {
            validator: function (v) {
                return /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(v);
            },
            message: props => `${props.value} is not a valid email address!`
        }
    },
    address: { type: String, required: true },
    emergencyContact: { type: String, required: true },
    insuranceInfo: { type: String },
    allergies: { type: String },
    currentMedications: { type: String },
    medicalHistory: { type: String },
    currentSymptoms: { type: String, required: true },
    painLevel: { type: String, required: true, enum: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'] },
    emergencyLevel: { type: String, required: true, enum: ['low', 'medium', 'high', 'critical'] },
    status: { type: String, default: 'Demande Enregistr√©e' },
    assignedDoctor: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        default: null
    },
    medicalRecord: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'MedicalRecord',
        default: null,
    },
    patientCode: { 
        type: String, 
        unique: true,
        default: () => `EMP-${uuidv4().substr(0, 8).toUpperCase()}`
    },
    isNewPatient: { type: Boolean, default: true },
    previousVisits: [{
        visitDate: { type: Date, default: Date.now },
        symptoms: String,
        treatment: String,
        doctor: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
    }],
    createdAt: { type: Date, default: Date.now },
    arrivalTime: { type: Date, default: Date.now }
}, { timestamps: true });

// M√©thode pour trouver un patient existant
emergencyPatientSchema.statics.findExistingPatient = async function(firstName, lastName, email) {
    return this.findOne({ 
        firstName: { $regex: new RegExp(`^${firstName}$`, 'i') },
        lastName: { $regex: new RegExp(`^${lastName}$`, 'i') },
        email: { $regex: new RegExp(`^${email}$`, 'i') }
    }).populate('medicalRecord');
};
// Nouvelle m√©thode pour les statistiques par niveau d'urgence
emergencyPatientSchema.statics.getEmergencyLevelStats = async function() {
    return this.aggregate([
        {
            $group: {
                _id: "$emergencyLevel",
                count: { $sum: 1 },
                // Vous pouvez ajouter d'autres statistiques ici si n√©cessaire
                averagePainLevel: { $avg: { $toDouble: "$painLevel" } }
            }
        },
        {
            $project: {
                emergencyLevel: "$_id",
                count: 1,
                averagePainLevel: 1,
                _id: 0
            }
        },
        {
            $sort: { 
                emergencyLevel: 1 
            }
        }
    ]);
};

// M√©thode pour les statistiques temporelles (optionnelle)
emergencyPatientSchema.statics.getEmergencyTrends = async function(timePeriod = 'day') {
    let groupFormat;
    
    switch (timePeriod) {
        case 'hour':
            groupFormat = { hour: { $hour: "$createdAt" } };
            break;
        case 'day':
            groupFormat = { day: { $dayOfMonth: "$createdAt" }, month: { $month: "$createdAt" }, year: { $year: "$createdAt" } };
            break;
        case 'month':
            groupFormat = { month: { $month: "$createdAt" }, year: { $year: "$createdAt" } };
            break;
        default:
            groupFormat = { day: { $dayOfMonth: "$createdAt" }, month: { $month: "$createdAt" }, year: { $year: "$createdAt" } };
    }

    return this.aggregate([
        {
            $group: {
                _id: groupFormat,
                total: { $sum: 1 },
                levels: {
                    $push: {
                        level: "$emergencyLevel",
                        pain: "$painLevel"
                    }
                }
            }
        },
        { $sort: { "_id": 1 } }
    ]);
};
const EmergencyPatient = mongoose.model('EmergencyPatient', emergencyPatientSchema);

export default EmergencyPatient;
</file>

<file path="models/Feedback.js">
import mongoose from "mongoose";

const feedbackSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    feedback: {
      type: String,
      required: true,
    },
    rating: {
      type: Number,
      required: true,
      min: 1,
      max: 5,
    },
  },
  { timestamps: true }
);

// Ajouter un index unique pour emp√™cher les doublons
feedbackSchema.index({ user: 1 }, { unique: true });

const Feedback = mongoose.model("Feedback", feedbackSchema);

export default Feedback;
</file>

<file path="models/MedicalRecord.js">
// backend/models/MedicalRecord.js
import mongoose from "mongoose";
import { v4 as uuidv4 } from 'uuid';

const medicalRecordSchema = new mongoose.Schema({
    patientId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'EmergencyPatient',
        required: true,
    },
    creator: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
        required: true,
    },
    accessCode: {
        type: String,
        unique: true,
        default: () => `MR-${uuidv4().substr(0, 8).toUpperCase()}`
    },
    emergencyContact: {
        name: String,
        relationship: String,
        phone: String,
    },
    bloodType: {
        type: String,
        enum: ["A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-"],
    },
    knownAllergies: [String],
    chronicConditions: [String],
    currentMedications: [
        {
            name: String,
            dosage: String,
            frequency: String,
        },
    ],
    lastUpdated: {
        type: Date,
        default: Date.now,
    },
    
}, { 
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// ... autres m√©thodes et virtuals ...
medicalRecordSchema.virtual('patientFiles', {
    ref: 'PatientFile',
    localField: '_id',
    foreignField: 'medicalRecord'
  });
const MedicalRecord = mongoose.model("MedicalRecord", medicalRecordSchema);
export default MedicalRecord;
</file>

<file path="models/Notification.js">
// models/Notification.js
import mongoose from 'mongoose';

const NotificationSchema = new mongoose.Schema({
    recipientId: { // L'ID de l'utilisateur qui doit recevoir la notification
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true, // Important pour les requ√™tes
    },
    message: {
        type: String,
        required: true,
    },
    type: { // Ex: 'doctor_assignment', 'patient_status_update', 'new_emergency_case'
        type: String,
        enum: ['doctor_assignment', 'patient_status_update', 'new_emergency_case', 'ambulance_alert', 'generic'], // Ajoutez d'autres types si besoin
        default: 'generic',
    },
    relatedEntityId: { // ID du patient, de l'urgence, etc. li√© √† la notification
        type: mongoose.Schema.Types.ObjectId,
        default: null,
    },
    relatedEntityType: { // 'EmergencyPatient', 'Ambulance', etc.
        type: String,
        default: null
    },
    isRead: {
        type: Boolean,
        default: false,
    },
    createdAt: {
        type: Date,
        default: Date.now,
        expires: '30d' // Optionnel: les notifications expirent apr√®s 30 jours
    },
});

export default mongoose.model('Notification', NotificationSchema);
</file>

<file path="models/OcrResult.js">
import mongoose from "mongoose";

const ocrResultSchema = new mongoose.Schema({
  medicalRecord: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "MedicalRecord",
    required: true,
  },
  originalFilename: {
    type: String,
    required: true,
  },
  textResult: {
    type: String,
    required: true,
  },
  extractedData: {
    patientName: String,
    diagnosis: String,
    tests: [
      {
        testName: String,
        result: String,
        date: Date,
      },
    ],
    treatments: [
      {
        name: String,
        dosage: String,
        frequency: String,
      },
    ],
    confidence: Number,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

export default mongoose.model("OcrResult", ocrResultSchema);
</file>

<file path="models/PatientFile.js">
import mongoose from "mongoose";

const patientFileSchema = new mongoose.Schema(
  {
    medicalRecord: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "MedicalRecord",
      required: true,
    },
    ocrResults: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'OcrResult'
    },
    isOCRProcessed: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      required: true,
      enum: [
        "Triage",
        "Diagnostic",
        "Treatment",
        "VitalSigns",
        "Discharge",
        "Prescription",
        "PatientInformation",
      ],
    },

    notes: String,

    dateRecorded: {
      type: Date,
      default: Date.now,
    },

    // D√©tails sp√©cifiques selon le type
    details: {
      priorityLevel: {
        type: String,
        enum: ["Resuscitation", "Emergency", "Urgent", "Semi-urgent", "Non-urgent"],
      },
      treatments: [{
        name: String,
        dosage: String,
        frequency: String,
        startDate: Date,
        endDate: Date
      }],
      chiefComplaint: String,

      diagnosis: String,
      diagnosticTests: [
        {
          testName: String,
          result: String,
          date: Date,
        },
      ],

      procedures: [
        {
          name: String,
          date: Date,
          notes: String,
        },
      ],

      vitalSigns: {
        temperature: Number,
        bloodPressure: {
          systolic: Number,
          diastolic: Number,
        },
        heartRate: Number,
        respiratoryRate: Number,
        oxygenSaturation: Number,
      },

      dischargeInstructions: String,
      followUpDate: Date,

      medications: [
        {
          name: String,
          dosage: String,
          frequency: String,
          duration: String,
        },
      ],

      patientInfo: {
        firstName: String,
        lastName: String,
        dateOfBirth: String,
        gender: String,
        phoneNumber: String,
        email: String,
        address: String,
        emergencyContact: String,
        insuranceInfo: String,
        allergies: String,
        currentMedications: String,
        medicalHistory: String,
        currentSymptoms: String,
        painLevel: String,
        emergencyLevel: String,
      },
    },

    // üîí ARCHIVAGE
    isArchived: {
      type: Boolean,
      default: false,
    },
    archivedAt: {
      type: Date,
      default: null,
    },
    archivedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      default: null,
    },
    archiveReason: {
      type: String,
      default: null,
    },

    restoredAt: {
      type: Date,
      default: null,
    },
    restoredBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      default: null,
    },
    restoreReason: {
      type: String,
      default: null,
    },
  },
  { timestamps: true }
);

// M√©thodes personnalis√©es
patientFileSchema.methods.updateFile = function (updateData) {
  console.log(`Updating patient file ${this._id}`);
};

patientFileSchema.methods.getFileType = function () {
  return this.type;
};

const PatientFile = mongoose.model("PatientFile", patientFileSchema);

export default PatientFile;
</file>

<file path="models/pdfGenerator.js">
// backend/utils/pdfGenerator.js
import pdf from 'html-pdf-node';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export const generateMedicalRecordPDF = async (medicalRecord, patientFiles) => {
  const templatePath = path.join(__dirname, '../templates/medicalRecordTemplate.html');
  let template = fs.readFileSync(templatePath, 'utf8');

  // Formatage des donn√©es pour le template
  const patientName = `${medicalRecord.patientId?.firstName} ${medicalRecord.patientId?.lastName}`;
  const birthDate = new Date(medicalRecord.patientId?.dateOfBirth).toLocaleDateString('fr-FR');
  
  // Remplacement des placeholders dans le template
  template = template
    .replace('{{patientName}}', patientName)
    .replace('{{birthDate}}', birthDate)
    .replace('{{bloodType}}', medicalRecord.bloodType || 'Non sp√©cifi√©')
    .replace('{{accessCode}}', medicalRecord.accessCode);

  // G√©n√©ration des fichiers m√©dicaux
  let filesHtml = '';
  patientFiles.forEach(file => {
    filesHtml += `
      <div class="file-section">
        <h3>${file.type}</h3>
        <p>Cr√©√© le: ${new Date(file.createdAt).toLocaleDateString('fr-FR')}</p>
        ${file.notes ? `<p>Notes: ${file.notes}</p>` : ''}
      </div>
      <hr>
    `;
  });
  template = template.replace('{{files}}', filesHtml);

  const options = { format: 'A4' };
  const buffer = await new Promise((resolve, reject) => {
    pdf.generatePdf({ content: template }, options, (err, buffer) => {
      if (err) reject(err);
      else resolve(buffer);
    });
  });

  return buffer;
};
</file>

<file path="models/Resource.js">
import mongoose from "mongoose";

const resourceSchema = new mongoose.Schema({
  type: { type: String, required: true },       // e.g. 'bed', 'ventilator'
  name: { type: String, required: true },       // e.g. 'ICU Bed 1'
  quantity: { type: Number, required: true, min: 0 },
  location: { type: String, required: true },   
  status: { type: String, required: true, enum: ['available','in-maintenance'] },
  allocatedTo: { type: mongoose.Schema.Types.ObjectId, ref: 'Patient', default: null },

}, { timestamps: true });

export default mongoose.model('Resource', resourceSchema);
</file>

<file path="models/SharedMedicalRecord.js">
import mongoose from "mongoose";

const SharedMedicalRecordSchema = new mongoose.Schema(
  {
    medicalRecordId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "MedicalRecord",
      required: true,
    },
    sharerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    recipientId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    note: {
      type: String,
      default: "",
    },
    sharedAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true }
);

export default mongoose.model("SharedMedicalRecord", SharedMedicalRecordSchema);
</file>

<file path="models/User.js">
import mongoose from "mongoose";

const options = { discriminatorKey: "role", timestamps: true };

// D√©finition du sch√©ma de base User
const UserSchema = new mongoose.Schema(
	{
		username: { type: String, required: true, unique: true },
		email: { type: String, required: true, unique: true },
		password: { type: String, required: true },
		phoneNumber: { type: String, required: true },
		role: { type: String, required: true, enum: ["Patient", "Doctor", "Nurse", "Administrator"] },
		isValidated: { type: Boolean, default: false }, // Nouveau champ
		profileImage: { type: String },
		resetPasswordToken: String, // Nouveau champ
		resetPasswordExpires: Date, // Nouveau champ
		otp: { type: String, required: false, default: 0 },
		 donationCount: {
      type: Number,
      default: 0,
    },
    unlockedBadges: [{
      type: String, // e.g., "beginner", "committed", "heroic", "legendary"
    }],
		otpExpires: Date,
		
	},
	options
);
// M√©thodes communes
UserSchema.methods.login = function () {
	console.log(`${this.username} logged in.`);
};

UserSchema.methods.logout = function () {
	console.log(`${this.username} logged out.`);
};

UserSchema.methods.updateProfile = function () {
	console.log(`${this.username} updated profile.`);
};

UserSchema.methods.resetPassword = function () {
	console.log(`${this.username} reset password.`);
};

const User = mongoose.model("User", UserSchema);

// ------------------- Patient -------------------
const PatientSchema = new mongoose.Schema({
	name: { type: String, required: true },
	dateOfBirth: { type: Date, required: true },
	gender: { type: String, required: true, enum: ["Male", "Female", "Other"] },
	address: { type: String, required: true },
	emergencyContact: { type: String, required: true },
	bloodType: { type: String, required: true },
	allergies: [{ type: String }],
});

PatientSchema.methods.registerPatient = function () {
	console.log(`Patient ${this.name} registered.`);
};

PatientSchema.methods.updatePatientInfo = function () {
	console.log(`Patient ${this.name} info updated.`);
};

PatientSchema.methods.viewMedicalHistory = function () {
	console.log(`Viewing medical history of ${this.name}.`);
};

const Patient = User.discriminator("Patient", PatientSchema);

// ------------------- Doctor -------------------
const DoctorSchema = new mongoose.Schema({
	badgeNumber: { type: String, required: true },
	specialization: { type: String, required: true },
	licenseNumber: { type: String, required: true },
	isAvailable: { type: Boolean, default: true }, // New field
});

DoctorSchema.methods.assignTreatment = function () {
	console.log(`Doctor ${this.username} assigned treatment.`);
};

DoctorSchema.methods.changePatientStatus = function () {
	console.log(`Doctor ${this.username} changed patient status.`);
};

DoctorSchema.methods.assignResources = function () {
	console.log(`Doctor ${this.username} assigned resources.`);
};

DoctorSchema.methods.prescribeMedication = function () {
	console.log(`Doctor ${this.username} prescribed medication.`);
};

DoctorSchema.methods.viewSchedule = function () {
	console.log(`Doctor ${this.username} viewing schedule.`);
};

const Doctor = User.discriminator("Doctor", DoctorSchema);

// ------------------- Nurse -------------------
const NurseSchema = new mongoose.Schema({
	badgeNumber: { type: String, required: true },
	shift: { type: String, required: true },
	licenseNumber: { type: String, required: true },
});

NurseSchema.methods.addMedicalNotes = function () {
	console.log(`Nurse ${this.username} added medical notes.`);
};

NurseSchema.methods.assignPatientPriority = function () {
	console.log(`Nurse ${this.username} assigned patient priority.`);
};

NurseSchema.methods.updatePatientAllocation = function () {
	console.log(`Nurse ${this.username} updated patient allocation.`);
};

NurseSchema.methods.administerMedication = function () {
	console.log(`Nurse ${this.username} administered medication.`);
};

NurseSchema.methods.viewSchedule = function () {
	console.log(`Nurse ${this.username} viewing schedule.`);
};

const Nurse = User.discriminator("Nurse", NurseSchema);

// ------------------- Administrator -------------------
const AdminSchema = new mongoose.Schema({
	badgeNumber: { type: String, required: true },
});

AdminSchema.methods.manageResources = function () {
	console.log(`Administrator ${this.username} managing resources.`);
};

AdminSchema.methods.allocateNurses = function () {
	console.log(`Administrator ${this.username} allocating nurses.`);
};

AdminSchema.methods.allocateDoctors = function () {
	console.log(`Administrator ${this.username} allocating doctors.`);
};

AdminSchema.methods.calculateResourceUtilization = function () {
	console.log(`Administrator ${this.username} calculating resource utilization.`);
};

const Administrator = User.discriminator("Administrator", AdminSchema);

export { User, Patient, Doctor, Nurse, Administrator };
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "description": "",
  "dependencies": {
    "@huggingface/inference": "^3.13.0",
    "@tensorflow/tfjs": "^4.22.0",
    "@xenova/transformers": "^2.17.2",
    "bcrypt": "^5.1.1",
    "bcryptjs": "^3.0.0",
    "canvas": "^3.1.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "cross-env": "^7.0.3",
    "dotenv": "^16.5.0",
    "express": "^4.21.2",
    "express-fileupload": "^1.5.1",
    "fs-extra": "^11.3.0",
    "google-auth-library": "^9.15.1",
    "html-pdf-node": "^1.0.8",
    "joi": "^17.13.3",
    "joi-password-complexity": "^5.2.0",
    "jsonwebtoken": "^9.0.2",
    "libphonenumber-js": "^1.12.4",
    "mongoose": "^8.13.2",
    "multer": "^1.4.5-lts.1",
    "node-fetch": "^2.7.0",
    "nodemailer": "^6.10.0",
    "otp-generator": "^4.0.1",
    "p-queue": "^8.1.0",
    "pdf-lib": "^1.17.1",
    "pdf2pic": "^3.1.4",
    "pdfjs-dist": "^3.11.174",
    "puppeteer": "^24.6.1",
    "sharp": "^0.34.1",
    "socket.io": "^4.8.1",
    "tesseract.js": "^4.1.1",
    "twilio": "^5.4.5",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  }
}
</file>

<file path="routes/ai.js">
// backend/routes/ai.js
import express from 'express';
// --- CORRECTION ICI ---
// Assurez-vous que cet import pointe vers le bon fichier et la bonne fonction
import { analyzeSymptomsSimple } from '../services/simpleSymptomHelper.js'; // <= Changer ceci !

const router = express.Router();

// POST /api/ai/analyze-symptoms
router.post('/analyze-symptoms', (req, res) => { // Pas besoin d'async
  const { symptomText } = req.body;

  if (!symptomText || typeof symptomText !== 'string' || symptomText.trim().length < 5) {
    console.log("[Simple Analysis] Texte trop court, retour vide.");
    return res.json({ keywords: [], suggestedQuestions: [] });
  }

  try {
    // --- CORRECTION ICI ---
    // Utiliser la fonction import√©e correctement
    const analysisResult = analyzeSymptomsSimple(symptomText); // <= Changer ceci !
    console.log("[Route AI Simple] R√©sultat envoy√©:", analysisResult);
    res.json(analysisResult);
  } catch (error) {
    console.error("Erreur inattendue dans l'analyse simple:", error);
    res.status(500).json({ message: "Erreur interne lors de l'analyse des sympt√¥mes." });
  }
});

export default router;
</file>

<file path="routes/alerts.js">
import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import Alert from "../models/Alert.js";
import { authenticateToken } from "../middleware/authMiddleware.js";

dotenv.config();
const router = express.Router();

// allow only our React app to hit these endpoints
router.use(
  cors({
    origin: "http://localhost:3000",
    credentials: true,
  })
);


router.get("/", authenticateToken, async (req, res) => {
  try {
    const alerts = await Alert.find().sort({ timestamp: -1 }).lean();
    res.json(alerts);
  } catch (err) {
    console.error("Failed to fetch alerts:", err);
    res.status(500).json({ error: "Server error" });
  }
});

router.post("/", authenticateToken, async (req, res) => {
  try {
    const { message, source } = req.body;
    const alert = await Alert.create({ message, source });

    // broadcast to all connected clients
    const io = req.app.get("io");
    io.emit("alert", {
      _id: alert._id,
      message: alert.message,
      source: alert.source,
      timestamp: alert.timestamp,
    });

    res.status(201).json(alert);
  } catch (err) {
    console.error("Failed to create alert:", err);
    res.status(500).json({ error: "Server error" });
  }
});

export default router;
</file>

<file path="routes/ambulance.js">
import express from "express";
import mongoose from "mongoose";
import cors from "cors";
import dotenv from "dotenv";
import { authenticateToken } from "../middleware/authMiddleware.js";
import  Ambulance  from "../models/Ambulance.js";

const router = express.Router();
router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();

// Create a new ambulance (admin only)
router.post("/", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }
    console.log("üì© Requ√™te re√ßue :", req.body);
    const newAmbulance = new Ambulance(req.body);
    const savedAmbulance = await newAmbulance.save();
    res.status(201).json(savedAmbulance);
  } catch (error) {
    console.error("Erreur lors de la cr√©ation de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Get all ambulances
router.get("/", authenticateToken, async (req, res) => {
  try {
    // Allow access to Administrator, Doctor, or Nurse roles
    if (!["Administrator", "Doctor", "Nurse","Patient"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }
    
    const ambulances = await Ambulance.find().populate("team", "username email role");
    res.status(200).json(ambulances);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des ambulances:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Get the ambulance assigned to the current nurse
router.get("/assigned", authenticateToken, async (req, res) => {
    try {
      // Only nurses are allowed to access this endpoint
      if (req.user.role !== "Nurse") {
        return res.status(403).json({ message: "Acc√®s refus√©" });
      }
  
      // Find an ambulance where the team includes the current nurse's id
      const ambulance = await Ambulance.findOne({ team: req.user.id }).populate("team", "username email role");
      if (!ambulance) {
        return res.status(404).json({ message: "Aucune ambulance assign√©e" });
      }
  
      res.status(200).json(ambulance);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de l'ambulance assign√©e:", error);
      res.status(500).json({ message: "Erreur serveur", error: error.message });
    }
  });
  
// Get ambulance by ID
router.get("/:id", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const ambulance = await Ambulance.findById(req.params.id).populate("team", "username email role");
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    res.status(200).json(ambulance);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update ambulance by ID
router.put("/:id", authenticateToken, async (req, res) => {
    console.log("üì© Requ√™te re√ßue :", req.user.role);

  try {
    if (!["Administrator", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const updatedAmbulance = await Ambulance.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    
    if (!updatedAmbulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    res.status(200).json(updatedAmbulance);
  } catch (error) {
    console.error("Erreur lors de la mise √† jour de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Delete ambulance by ID
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const deletedAmbulance = await Ambulance.findByIdAndDelete(req.params.id);
    
    if (!deletedAmbulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    res.status(200).json({ message: "Ambulance supprim√©e avec succ√®s" });
  } catch (error) {
    console.error("Erreur lors de la suppression de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update ambulance status
router.put("/:id/status", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const { status } = req.body;
    
    if (!status || !['IN_TRANSIT', 'AVAILABLE', 'ON_MISSION', 'MAINTENANCE'].includes(status)) {
      return res.status(400).json({ message: "Statut d'ambulance invalide" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    ambulance.status = status;
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    res.status(200).json({
      message: `Statut de l'ambulance mis √† jour √† ${status}`,
      ambulance: ambulance
    });
  } catch (error) {
    console.error("Erreur lors de la mise √† jour du statut de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update ambulance location
router.put("/:id/location", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const { latitude, longitude } = req.body;
    
    if (typeof latitude !== 'number' || typeof longitude !== 'number') {
      return res.status(400).json({ message: "Coordonn√©es de localisation invalides" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    ambulance.latitude = latitude;
    ambulance.longitude = longitude;
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    res.status(200).json({
      message: "Localisation de l'ambulance mise √† jour",
      ambulance: ambulance
    });
  } catch (error) {
    console.error("Erreur lors de la mise √† jour de la localisation de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Add team member to ambulance
router.post("/:id/team", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const { userId } = req.body;
    
    if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ message: "ID utilisateur invalide" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    // Prevent duplicate team members
    if (ambulance.team.includes(userId)) {
      return res.status(400).json({ message: "Cet utilisateur fait d√©j√† partie de l'√©quipe" });
    }
    
    ambulance.team.push(userId);
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    const updatedAmbulance = await Ambulance.findById(req.params.id).populate("team", "username email role");
    
    res.status(200).json({
      message: "Membre ajout√© √† l'√©quipe",
      ambulance: updatedAmbulance
    });
  } catch (error) {
    console.error("Erreur lors de l'ajout d'un membre √† l'√©quipe:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Remove team member from ambulance
router.delete("/:id/team/:userId", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id) || !mongoose.Types.ObjectId.isValid(req.params.userId)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    // Check if user is in the team
    if (!ambulance.team.includes(req.params.userId)) {
      return res.status(400).json({ message: "Cet utilisateur ne fait pas partie de l'√©quipe" });
    }
    
    ambulance.team = ambulance.team.filter(id => id.toString() !== req.params.userId);
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    const updatedAmbulance = await Ambulance.findById(req.params.id).populate("team", "username email role");
    
    res.status(200).json({
      message: "Membre retir√© de l'√©quipe",
      ambulance: updatedAmbulance
    });
  } catch (error) {
    console.error("Erreur lors du retrait d'un membre de l'√©quipe:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Get available ambulances
router.get("/status/available", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }
    
    const availableAmbulances = await Ambulance.find({ status: "AVAILABLE" }).populate("team", "username email role");
    res.status(200).json(availableAmbulances);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des ambulances disponibles:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update estimated arrival time
router.put("/:id/eta", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const { estimatedArrival } = req.body;
    
    if (!estimatedArrival) {
      return res.status(400).json({ message: "Heure d'arriv√©e estim√©e requise" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    ambulance.estimatedArrival = new Date(estimatedArrival);
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    res.status(200).json({
      message: "Heure d'arriv√©e estim√©e mise √† jour",
      ambulance: ambulance
    });
  } catch (error) {
    console.error("Erreur lors de la mise √† jour de l'heure d'arriv√©e estim√©e:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});


export default router;
</file>

<file path="routes/ambulanceRequests.js">
import express from "express";
import AmbulanceRequest from "../models/AmbulanceRequest.js";
import Ambulance from "../models/Ambulance.js";
import cors from "cors";
import dotenv from "dotenv";
import { authenticateToken } from "../middleware/authMiddleware.js";

const router = express.Router();

dotenv.config();
// Enable CORS for React front-end
router.use(
  cors({
    origin: "http://localhost:3000",
    credentials: true,
    methods: ["GET","POST","PUT","PATCH","DELETE","OPTIONS"],
    allowedHeaders: ["Content-Type","Authorization"],
  })
);
/**
 * Create a new ambulance request (unauthenticated patients allowed)
 */
router.post("/", async (req, res) => {
  try {
    const request = await AmbulanceRequest.create({
      ...req.body,
      ambulance: null,
      status: "PENDING",
    });

    req.io.emit("ambulanceRequestUpdate", {
      type: "NEW_REQUEST",
      data: request,
    });

    return res.status(201).json(request);
  } catch (error) {
    console.error("Error creating ambulance request:", error);
    return res.status(500).json({ message: "Error creating ambulance request" });
  }
});

/**
 * Assign an ambulance to a request and set patient location (protected)
 */
router.patch("/:id/assign", authenticateToken, async (req, res) => {
  console.log("üöë Assign request received:", req.body);
  const { ambulanceId, patientLocation } = req.body;
  try {
    const request = await AmbulanceRequest.findById(req.params.id);
    if (!request) return res.status(404).json({ message: "Request not found" });

    const ambulance = await Ambulance.findById(ambulanceId);
    if (!ambulance || ambulance.status !== "AVAILABLE") {
      return res.status(400).json({ message: "Ambulance not available" });
    }

    request.ambulance = ambulance._id;
    request.patient.location = patientLocation;
    request.status = "ACCEPTED";
    await request.save();

    ambulance.status = "ON_MISSION";
    ambulance.destination = `${patientLocation.latitude},${patientLocation.longitude}`;
    await ambulance.save();

    // Notify front-end and ambulance socket
    req.io.emit(`ambulance_${ambulance._id}`, {
      type: "NEW_MISSION",
      data: request,
    });
    req.io.emit("destinationUpdate", {
      id: ambulance._id,
      destinationLatitude: patientLocation.latitude,
      destinationLongitude: patientLocation.longitude,
    });

    return res.json(request);
  } catch (error) {
    console.error("Error assigning ambulance:", error);
    return res.status(500).json({ message: "Error assigning ambulance" });
  }
});

/**
 * List all ambulance requests (protected)
 */
router.get("/", authenticateToken, async (req, res) => {
  try {
    const requests = await AmbulanceRequest.find()
      .populate("ambulance")
      .sort({ createdAt: -1 });
    return res.json(requests);
  } catch (error) {
    console.error("Error fetching ambulance requests:", error);
    return res.status(500).json({ message: "Error fetching ambulance requests" });
  }
});

/**
 * Get single ambulance request by ID (protected)
 */
router.get("/:id", authenticateToken, async (req, res) => {
  try {
    const request = await AmbulanceRequest.findById(req.params.id).populate("ambulance");
    if (!request) return res.status(404).json({ message: "Request not found" });
    return res.json(request);
  } catch (error) {
    console.error("Error fetching ambulance request:", error);
    return res.status(500).json({ message: "Error fetching ambulance request" });
  }
});

/**
 * Update status of an ambulance request (protected)
 */
router.patch("/:id/status", authenticateToken, async (req, res) => {
  try {
    const { status } = req.body;
    const request = await AmbulanceRequest.findById(req.params.id);
    if (!request) return res.status(404).json({ message: "Request not found" });

    request.status = status;
    await request.save();

    // If completed, free up ambulance
    if (status === "COMPLETED" && request.ambulance) {
      const ambulance = await Ambulance.findById(request.ambulance);
      if (ambulance) {
        ambulance.status = "AVAILABLE";
        ambulance.destination = null;
        await ambulance.save();
      }
    }

    req.io.emit(`request_${request._id}`, {
      type: "STATUS_UPDATE",
      data: { status },
    });

    return res.json(request);
  } catch (error) {
    console.error("Error updating request status:", error);
    return res.status(500).json({ message: "Error updating request status" });
  }
});

export default router;
</file>

<file path="routes/annotation.js">
import express from "express"
import { authenticateToken } from "../middleware/authMiddleware.js"
import Annotation from "../models/Annotation.js"
import PatientFile from "../models/PatientFile.js"
import AuditLog from "../models/AuditLog.js"
import mongoose from "mongoose"
import MedicalRecord from "../models/MedicalRecord.js";
const router = express.Router()

// Create a new annotation
router.post("/", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux professionnels de sant√©" })
    }

    const { patientFileId, text, position, type, color } = req.body

    // Validate patient file exists
    const patientFile = await PatientFile.findById(patientFileId)
    if (!patientFile) {
      return res.status(404).json({ message: "Document m√©dical introuvable" })
    }

    const newAnnotation = new Annotation({
      patientFileId,
      authorId: req.user.id,
      text,
      position,
      type: type || "comment",
      color: color || "#FFD700",
    })

    await newAnnotation.save()

    // Log the action
    await AuditLog.create({
      action: "CREATE_ANNOTATION",
      userId: req.user.id,
      details: `Annotation cr√©√©e pour le document ${patientFileId}`,
    })

    // Populate author information
    const populatedAnnotation = await Annotation.findById(newAnnotation._id).populate("authorId", "username role")

    res.status(201).json(populatedAnnotation)
  } catch (error) {
    console.error("Erreur lors de la cr√©ation de l'annotation:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Get all annotations for a specific patient file
router.get("/file/:patientFileId", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Nurse", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" })
    }

    const { patientFileId } = req.params

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(patientFileId)) {
      return res.status(400).json({ message: "Select file patient" })
    }

    const annotations = await Annotation.find({ patientFileId })
      .populate("authorId", "username role")
      .sort({ createdAt: -1 })

    res.status(200).json(annotations)
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des annotations:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Update an annotation
router.put("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params
    const { text, isResolved, color, type } = req.body

    // Find the annotation
    const annotation = await Annotation.findById(id)
    if (!annotation) {
      return res.status(404).json({ message: "Annotation introuvable" })
    }

    // Check if user is the author or an administrator
    if (annotation.authorId.toString() !== req.user.id && req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Vous n'√™tes pas autoris√© √† modifier cette annotation" })
    }

    // Update fields
    if (text) annotation.text = text
    if (isResolved !== undefined) annotation.isResolved = isResolved
    if (color) annotation.color = color
    if (type) annotation.type = type

    await annotation.save()

    // Log the action
    await AuditLog.create({
      action: "UPDATE_ANNOTATION",
      userId: req.user.id,
      details: `Annotation ${id} mise √† jour`,
    })

    // Return updated annotation with author info
    const updatedAnnotation = await Annotation.findById(id).populate("authorId", "username role")

    res.status(200).json(updatedAnnotation)
  } catch (error) {
    console.error("Erreur lors de la mise √† jour de l'annotation:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})
// Nouvelle route pour r√©cup√©rer les annotations par dossier m√©dical
router.get("/medical-record/:medicalRecordId", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Nurse", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const { medicalRecordId } = req.params;

    // Validation de l'ID du dossier m√©dical
    if (!mongoose.Types.ObjectId.isValid(medicalRecordId)) {
      return res.status(400).json({ message: "ID de dossier m√©dical invalide" });
    }

    // V√©rification de l'existence du dossier m√©dical
    const medicalRecord = await MedicalRecord.findById(medicalRecordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical introuvable" });
    }

    // R√©cup√©ration de tous les fichiers patients associ√©s
    const patientFiles = await PatientFile.find({ medicalRecord: medicalRecordId });
    const patientFileIds = patientFiles.map(file => file._id);

    // R√©cup√©ration de toutes les annotations pour ces fichiers
    const annotations = await Annotation.find({ patientFileId: { $in: patientFileIds } })
      .populate("authorId", "username role")
      .sort({ createdAt: -1 });

    res.status(200).json(annotations);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des annotations par dossier m√©dical:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Delete an annotation
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params

    // Find the annotation
    const annotation = await Annotation.findById(id)
    if (!annotation) {
      return res.status(404).json({ message: "Annotation introuvable" })
    }

    // Check if user is the author or an administrator
    if (annotation.authorId.toString() !== req.user.id && req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Vous n'√™tes pas autoris√© √† supprimer cette annotation" })
    }

    await Annotation.findByIdAndDelete(id)

    // Log the action
    await AuditLog.create({
      action: "DELETE_ANNOTATION",
      userId: req.user.id,
      details: `Annotation ${id} supprim√©e`,
    })

    res.status(200).json({ message: "Annotation supprim√©e avec succ√®s" })
  } catch (error) {
    console.error("Erreur lors de la suppression de l'annotation:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

export default router
</file>

<file path="routes/archive.js">
import express from "express"
import { authenticateToken } from "../middleware/authMiddleware.js"
import PatientFile from "../models/PatientFile.js"
import MedicalRecord from "../models/MedicalRecord.js"
import AuditLog from "../models/AuditLog.js"
import mongoose from "mongoose"

const router = express.Router()

// Archive a patient file
router.put("/patient-files/:id/archive", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins et administrateurs" })
    }

    const { id } = req.params
    const { reason } = req.body

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID de document invalide" })
    }

    // Find the patient file
    const patientFile = await PatientFile.findById(id)
    if (!patientFile) {
      return res.status(404).json({ message: "Document m√©dical introuvable" })
    }

    // Update the file status to archived
    patientFile.isArchived = true
    patientFile.archivedAt = new Date()
    patientFile.archiveReason = reason || "Document archiv√© par un professionnel de sant√©"
    patientFile.archivedBy = req.user.id

    await patientFile.save()

    // Log the action
    await AuditLog.create({
      action: "ARCHIVE_PATIENT_FILE",
      userId: req.user.id,
      details: `Document m√©dical ${id} archiv√©: ${reason || "Aucune raison sp√©cifi√©e"}`,
    })

    res.status(200).json({
      message: "Document archiv√© avec succ√®s",
      patientFile,
    })
  } catch (error) {
    console.error("Erreur lors de l'archivage du document:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Restore an archived patient file
router.put("/patient-files/:id/restore", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins et administrateurs" })
    }

    const { id } = req.params
    const { reason } = req.body

    // Find the patient file
    const patientFile = await PatientFile.findById(id)
    if (!patientFile) {
      return res.status(404).json({ message: "Document m√©dical introuvable" })
    }

    if (!patientFile.isArchived) {
      return res.status(400).json({ message: "Ce document n'est pas archiv√©" })
    }

    // Restore the file
    patientFile.isArchived = false
    patientFile.archivedAt = null
    patientFile.archiveReason = null
    patientFile.archivedBy = null
    patientFile.restoredAt = new Date()
    patientFile.restoredBy = req.user.id
    patientFile.restoreReason = reason || "Document restaur√© par un professionnel de sant√©"

    await patientFile.save()

    // Log the action
    await AuditLog.create({
      action: "RESTORE_PATIENT_FILE",
      userId: req.user.id,
      details: `Document m√©dical ${id} restaur√©: ${reason || "Aucune raison sp√©cifi√©e"}`,
    })

    res.status(200).json({
      message: "Document restaur√© avec succ√®s",
      patientFile,
    })
  } catch (error) {
    console.error("Erreur lors de la restauration du document:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Get all archived patient files for a medical record
router.get("/medical-records/:recordId/archived", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Administrator", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" })
    }

    const { recordId } = req.params

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(recordId)) {
      return res.status(400).json({ message: "ID de dossier m√©dical invalide" })
    }

    // Check if medical record exists
    const medicalRecord = await MedicalRecord.findById(recordId)
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical introuvable" })
    }

    // Get all archived files for this medical record
    const archivedFiles = await PatientFile.find({
      medicalRecord: recordId,
      isArchived: true,
    }).populate("archivedBy", "username role")

    res.status(200).json(archivedFiles)
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des documents archiv√©s:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Get all archived patient files (admin only)
router.get("/archived", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux administrateurs" })
    }

    // Optional query parameters for filtering
    const { before, after, medicalRecordId } = req.query

    const query = { isArchived: true }

    if (before) {
      query.archivedAt = { ...query.archivedAt, $lt: new Date(before) }
    }

    if (after) {
      query.archivedAt = { ...query.archivedAt, $gt: new Date(after) }
    }

    if (medicalRecordId && mongoose.Types.ObjectId.isValid(medicalRecordId)) {
      query.medicalRecord = medicalRecordId
    }

    const archivedFiles = await PatientFile.find(query)
      .populate("archivedBy", "username role")
      .populate("medicalRecord", "accessCode")
      .sort({ archivedAt: -1 })

    res.status(200).json(archivedFiles)
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des documents archiv√©s:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

export default router
</file>

<file path="routes/auth copy.js">
import express from "express";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { User } from "../models/User.js";
import dotenv from "dotenv";
import crypto from "crypto"; // Utilisez cette syntaxe pour les modules ES
import nodemailer from "nodemailer";
import { generateOTP, saveOTPToUser, verifyOTP } from "../services/otpService.js";
import { sendOTP } from "../services/emailService.js";
import { OAuth2Client } from "google-auth-library";
import multer from "multer";
import upload from "../middleware/uploadMiddleware.js"
import { authenticateToken } from "../middleware/authMiddleware.js";
import sendSMS from "../sendSMS.js";

const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

// Middleware CORS pour assurer que toutes les routes acceptent les requ√™tes frontend
import cors from "cors";

const router = express.Router();
// üìÇ D√©finir le stockage des fichiers
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/'); // Dossier o√π enregistrer les images
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname)); // Nom unique
  }
});



router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Utilisateur non trouv√©" });

    if (!user.isValidated) {
      if (user.role === "Patient") return res.status(400).json({ message: "Votre compte est en attente de validation de mail via otp" });
      return res.status(400).json({ message: "Votre compte est en attente de validation par un administrateur" });
    }

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) return res.status(400).json({ message: "Mot de passe incorrect" });

    // Generate JWT Token
    const token = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "7d" });
    console.log("Generated Token:", token);
    // Store token in an HTTP-only cookie
    res.cookie("token", token, {
      httpOnly: false,
      secure: process.env.NODE_ENV === "production", // Set secure in production (HTTPS only)
      sameSite: "strict", // Protect against CSRF attacks
      maxAge: 7 * 24 * 60 * 60 * 1000, // Cookie expires in 7 days
    });
    

    res.status(200).json({ message: "Connexion r√©ussie", user },);
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
router.post("/logout", (req, res) => {
  console.log("Logout route hit");
  res.clearCookie("token", { httpOnly: true, sameSite: "strict", secure: process.env.NODE_ENV === "production" });
  res.status(200).json({ message: "D√©connexion r√©ussie" });
});
router.get("/me", authenticateToken, (req, res) => {
  try {
    // If the token is valid, `req.user` will have the decoded data
    const user = req.user;

    // Optionally, you can fetch the full user from the database if necessary
    res.status(200).json({
      id: user.id,
      username: user.username,
      email: user.email,
      role: user.role,
      profilePicture: user.profilePicture, // Add additional info as needed
    });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Route de login avec Google
router.post("/google-login", async (req, res) => {
  try {
    const { token } = req.body;
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID,
    });

    const { email, name, picture } = ticket.getPayload();

    let user = await User.findOne({ email });
    if (!user) {
      user = new User({ email, username: name, profilePicture: picture, isValidated: true });
      await user.save();
    }

    const jwtToken = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "7d" });

    res.status(200).json({ message: "Connexion r√©ussie avec Google", token: jwtToken, user });
  } catch (error) {
    console.error("Erreur Google Login:", error);
    res.status(500).json({ message: "Erreur lors de l'authentification Google", error: error.message });
  }
});





router.post("/register", upload.single("profileImage"), async (req, res) => {
  try {
    const { username, email, password, phoneNumber, role, ...roleSpecificData } = req.body;

    console.log("Donn√©es re√ßues :", req.body); // Log pour v√©rifier les donn√©es re√ßues

    // V√©rifier si l'utilisateur existe d√©j√†
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      console.log("Email d√©j√† utilis√© :", email);
      return res.status(400).json({ message: "Email d√©j√† utilis√©" });
    }

    // Hacher le mot de passe
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // Si le r√¥le est un r√¥le restreint (Doctor, Nurse, Admin), l'utilisateur doit √™tre en attente
    const isValidated = false; // Si r√¥le Patient, utilisateur est valid√©

    // Cr√©er un nouvel utilisateur
    const newUserData = {
      username,
      email,
      password: hashedPassword,
      phoneNumber,
      role,
      isValidated,
      profileImage: req.file ? `/uploads/${req.file.filename}` : null
    };

    // Ajouter les champs sp√©cifiques au r√¥le
    switch (role) {
      case "Patient":
        const { name, dateOfBirth, gender, address, emergencyContact, bloodType, allergies } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!name || !dateOfBirth || !gender || !address || !emergencyContact || !bloodType) {
          console.log("Champs obligatoires manquants pour un patient");
          return res.status(400).json({ message: "Tous les champs obligatoires pour un patient doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques au patient
        newUserData.name = name;
        newUserData.dateOfBirth = dateOfBirth;
        newUserData.gender = gender;
        newUserData.address = address;
        newUserData.emergencyContact = emergencyContact;
        newUserData.bloodType = bloodType;
        newUserData.allergies = allergies || []; // Les allergies sont optionnelles
        break;

      case "Doctor":
        const { badgeNumber: docBadgeNumber, specialization, licenseNumber: docLicenseNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!docBadgeNumber || !specialization || !docLicenseNumber) {
          console.log("Champs obligatoires manquants pour un m√©decin");
          return res.status(400).json({ message: "Tous les champs obligatoires pour un m√©decin doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques au m√©decin
        newUserData.badgeNumber = docBadgeNumber;
        newUserData.specialization = specialization;
        newUserData.licenseNumber = docLicenseNumber;
        break;

      case "Nurse":
        const { badgeNumber: nurseBadgeNumber, shift, licenseNumber: nurseLicenseNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!nurseBadgeNumber || !shift || !nurseLicenseNumber) {
          console.log("Champs obligatoires manquants pour une infirmi√®re");
          return res.status(400).json({ message: "Tous les champs obligatoires pour une infirmi√®re doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques √† l'infirmi√®re
        newUserData.badgeNumber = nurseBadgeNumber;
        newUserData.shift = shift;
        newUserData.licenseNumber = nurseLicenseNumber;
        break;

      case "Administrator":
        const { badgeNumber: adminBadgeNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!adminBadgeNumber) {
          console.log("Champs obligatoires manquants pour un administrateur");
          return res.status(400).json({ message: "Le num√©ro de badge est obligatoire pour un administrateur" });
        }

        // Ajouter les champs sp√©cifiques √† l'administrateur
        newUserData.badgeNumber = adminBadgeNumber;
        break;

      default:
        console.log("R√¥le invalide :", role);
        return res.status(400).json({ message: "R√¥le invalide" });
    }

    // Cr√©er un nouvel utilisateur
    const newUser = new User(newUserData);
    await newUser.save();
    console.log("Utilisateur cr√©√© avec succ√®s :", newUser);

    // G√©n√©rer et envoyer l'OTP
    const { otp, hashedOTP } = await generateOTP();
    console.log("OTP g√©n√©r√© :", otp);
    await saveOTPToUser(email, hashedOTP);
    console.log("OTP enregistr√© pour l'utilisateur :", email);
    await sendOTP(email, otp);
    console.log("OTP envoy√© √† :", email);

    // Envoyer un SMS de confirmation avec le num√©ro de t√©l√©phone
    const smsMessage = `Bienvenue ${username}, votre inscription a √©t√© r√©ussie !  Veuillez v√©rifier votre email pour l'OTP.`;
    await sendSMS(smsMessage, phoneNumber); // <--- CORRECT
    console.log("SMS envoy√© √† :", phoneNumber);

    res.status(201).json({ message: "Utilisateur cr√©√© avec succ√®s. Veuillez v√©rifier votre email pour l'OTP.", user: newUser });
  } catch (error) {
    console.error("Erreur lors de l'inscription :", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Route pour r√©initialiser le mot de passe
const transporter = nodemailer.createTransport({
  host: "smtp.gmail.com", // Serveur SMTP d'Outlook
  port: 587, // Port SMTP
  secure: false, // true pour le port 465, false pour les autres ports
  auth: {
    user: process.env.EMAIL_USER, // Votre adresse email
    pass: process.env.EMAIL_PASSWORD, // Votre mot de passe
  },
});
// üìå Route pour demander une r√©initialisation de mot de passe
router.post("/forgot-password", async (req, res) => {
  try {
    console.log("üì© Requ√™te re√ßue :", req.body);
    const { email } = req.body;

    // V√©rifier si l'utilisateur existe
    const user = await User.findOne({ email });
    if (!user) {
      console.log("‚ö† Utilisateur non trouv√© :", email);
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    // G√©n√©rer un token de r√©initialisation
    const resetToken = crypto.randomBytes(20).toString("hex");
    const resetTokenExpiry = Date.now() + 3600000; // 1 heure de validit√©

    // Enregistrer le token et sa date d'expiration dans la base de donn√©es
    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = resetTokenExpiry;
    await user.save();
    console.log("‚úÖ Token enregistr√© pour :", user.email);

    // üîó Construire le lien de r√©initialisation avec la syntaxe correcte
    const resetUrl = `http://localhost:3000/reset-password/${resetToken}`;

    // Envoyer un email avec le lien de r√©initialisation
    const mailOptions = {
      to: user.email,
      from: process.env.EMAIL_USER,
      subject: "R√©initialisation de mot de passe",
      html: `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R√©initialisation de mot de passe</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 0;
            text-align: center;
        }
        .container {
            width: 100%;
            max-width: 600px;
            margin: 50px auto;
            background-color: #ffffff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #333;
            font-size: 24px;
        }
        p {
            font-size: 16px;
            color: #555;
        }
        a {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            font-weight: bold;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            margin-top: 20px;
        }
        a:hover {
            background-color: #45a049;
        }
        .footer {
            font-size: 14px;
            color: #888;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>R√©initialisation de votre mot de passe</h2>
        <p>Vous avez demand√© une r√©initialisation de mot de passe. Cliquez sur le lien ci-dessous pour r√©initialiser votre mot de passe :</p>
        <a href="${resetUrl}">R√©initialiser votre mot de passe</a>
        <p class="footer">Si vous n'avez pas demand√© cette r√©initialisation, vous pouvez ignorer cet email.</p>
    </div>
</body>
</html>`,
    };

    console.log("üì® Envoi de l'email √† :", user.email);
    await transporter.sendMail(mailOptions);
    console.log("‚úÖ Email envoy√© avec succ√®s");

    res.status(200).json({ message: "Un email de r√©initialisation a √©t√© envoy√©" });
  } catch (error) {
    console.error("‚ùå Erreur dans /forgot-password :", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message || error });
  }
});

// Route pour r√©initialiser le mot de passe
router.post("/reset-password/:token", async (req, res) => {
  console.log("Reset password route hit");
  try {
    const { token } = req.params;
    const { newPassword } = req.body;
    console.log("Requ√™te re√ßue :", req.body); // Log pour v√©rifier la requ√™te
    // Trouver l'utilisateur avec le token valide
    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: Date.now() }, // V√©rifier que le token n'a pas expir√©
    });

    if (!user) return res.status(400).json({ message: "Token invalide ou expir√©" });

    // Hacher le nouveau mot de passe
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    // Mettre √† jour le mot de passe et effacer le token
    user.password = hashedPassword;
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    await user.save();

    res.status(200).json({ success: true, message: "Mot de passe r√©initialis√© avec succ√®s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});


// Route pour mettre √† jour le profil d'un utilisateur
router.put("/update-profile/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { username, phoneNumber, role, ...roleSpecificData } = req.body;

    // Trouver l'utilisateur par son ID
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Mettre √† jour les champs communs
    if (username) user.username = username;
    if (phoneNumber) user.phoneNumber = phoneNumber;

    // Mettre √† jour les champs sp√©cifiques au r√¥le
    switch (user.role) {
      case "Patient":
        const { name, dateOfBirth, gender, address, emergencyContact, bloodType, allergies } = roleSpecificData;

        if (name) user.name = name;
        if (dateOfBirth) user.dateOfBirth = dateOfBirth;
        if (gender) user.gender = gender;
        if (address) user.address = address;
        if (emergencyContact) user.emergencyContact = emergencyContact;
        if (bloodType) user.bloodType = bloodType;
        if (allergies) user.allergies = allergies;
        break;

      case "Doctor":
        const { badgeNumber: docBadgeNumber, specialization, licenseNumber: docLicenseNumber } = roleSpecificData;

        if (docBadgeNumber) user.badgeNumber = docBadgeNumber;
        if (specialization) user.specialization = specialization;
        if (docLicenseNumber) user.licenseNumber = docLicenseNumber;
        break;

      case "Nurse":
        const { badgeNumber: nurseBadgeNumber, shift, licenseNumber: nurseLicenseNumber } = roleSpecificData;

        if (nurseBadgeNumber) user.badgeNumber = nurseBadgeNumber;
        if (shift) user.shift = shift;
        if (nurseLicenseNumber) user.licenseNumber = nurseLicenseNumber;
        break;

      case "Administrator":
        const { badgeNumber: adminBadgeNumber } = roleSpecificData;

        if (adminBadgeNumber) user.badgeNumber = adminBadgeNumber;
        break;

      default:
        return res.status(400).json({ message: "R√¥le invalide" });
    }

    // Sauvegarder les modifications
    await user.save();

    res.status(200).json({ message: "Profil mis √† jour avec succ√®s", user });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
// Route pour changer le r√¥le d'un utilisateur (admin uniquement)
router.put("/change-role/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { role } = req.body;

    // Trouver l'utilisateur par son ID
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Changer le r√¥le de l'utilisateur
    user.role = role;
    await user.save();

    res.status(200).json({ message: "R√¥le de l'utilisateur mis √† jour avec succ√®s", user });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Send OTP Route
router.post("/send-otp", async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: "Email is required" });

    // Generate OTP
    const { otp, hashedOTP } = await generateOTP();

    // Store OTP with expiration (e.g., 5 minutes)
    saveOTPToUser(email, hashedOTP);

    // Send OTP to email
    await sendOTP(email, otp);

    res.status(200).json({ message: "OTP sent successfully" });
  } catch (error) {
    console.error("Error sending OTP:", error);
    res.status(500).json({ message: "Server error", error });
  }
});
router.post("/verify-otp", async (req, res) => {
  const { email, otp } = req.body;

  if (!email || !otp) {
    return res.status(400).json({ message: "Email et OTP sont requis" });
  }

  try {
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Utilisateur non trouv√©" });

    if (Date.now() > user.otpExpires) {
      return res.status(400).json({ message: "OTP expir√©" });
    }

    const isValid = await verifyOTP(otp, user.otp);
    if (!isValid) {
      if (user.role === "Patient") user.isValidated = true;
      return res.status(400).json({ message: "OTP incorrect" });

    }

    // Mettre √† jour l'utilisateur apr√®s v√©rification
    user.otpValidated = true;
    user.otp = undefined;
    user.otpExpires = undefined;
    user.isValidated = true;
    await user.save();

    res.status(200).json({ message: "OTP v√©rifi√© avec succ√®s. Vous pouvez maintenant vous connecter." });
  } catch (error) {
    console.error("Erreur lors de la v√©rification de l'OTP:", error);
    res.status(500).json({ message: "Erreur serveur", error });
  }
});


router.post('/send-sms', async (req, res) => {
  const { body, phoneNumber } = req.body;

  // V√©rifier que le corps du message et le num√©ro de t√©l√©phone sont fournis
  if (!body || !phoneNumber) {
    return res.status(400).json({ success: false, message: 'Body and phone number are required' });
  }

  try {
    const result = await sendSMS(body, phoneNumber);
    if (result.success) {
      return res.status(200).json(result);
    } else {
      return res.status(500).json(result);
    }
  } catch (error) {
    console.error(error);
    return res.status(500).json({ success: false, message: 'Failed to send SMS', error: error.message });
  }
});

///////router export 
export default router;
</file>

<file path="routes/auth.js">
import express from "express";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { User } from "../models/User.js";
import dotenv from "dotenv";
import crypto from "crypto"; // Utilisez cette syntaxe pour les modules ES
import nodemailer from "nodemailer";
import { generateOTP, saveOTPToUser, verifyOTP } from "../services/otpService.js";
import { sendOTP } from "../services/emailService.js";
import { OAuth2Client } from "google-auth-library";
import multer from "multer";
import upload from "../middleware/uploadMiddleware.js"
import { authenticateToken } from "../middleware/authMiddleware.js";
import sendSMS from "../sendSMS.js";

const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

// Middleware CORS pour assurer que toutes les routes acceptent les requ√™tes frontend
import cors from "cors";

const router = express.Router();
// üìÇ D√©finir le stockage des fichiers
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/'); // Dossier o√π enregistrer les images
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname)); // Nom unique
  }
});



router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Utilisateur non trouv√©" });

    if (!user.isValidated) {
      if (user.role === "Patient") return res.status(400).json({ message: "Votre compte est en attente de validation de mail via otp" });
      return res.status(400).json({ message: "Votre compte est en attente de validation par un administrateur" });
    }

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) return res.status(400).json({ message: "Mot de passe incorrect" });

    // Generate JWT Token
    const token = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "7d" });
    console.log("Generated Token:", token);
    // Store token in an HTTP-only cookie
    res.cookie("token", token, {
      httpOnly: false,
      secure: process.env.NODE_ENV === "production", // Set secure in production (HTTPS only)
      sameSite: "strict", // Protect against CSRF attacks
      maxAge: 7 * 24 * 60 * 60 * 1000, // Cookie expires in 7 days
    });
    

    res.status(200).json({ message: "Connexion r√©ussie", user },);
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
router.post("/logout", (req, res) => {
  console.log("Logout route hit");
  res.clearCookie("token", { httpOnly: true, sameSite: "strict", secure: process.env.NODE_ENV === "production" });
  res.status(200).json({ message: "D√©connexion r√©ussie" });
});
router.get("/me", authenticateToken, (req, res) => {
  try {
    // If the token is valid, `req.user` will have the decoded data
    const user = req.user;

    // Optionally, you can fetch the full user from the database if necessary
    res.status(200).json({
      id: user.id,
      username: user.username,
      email: user.email,
      role: user.role,
      profilePicture: user.profilePicture, // Add additional info as needed
    });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Route de login avec Google
router.post("/google-login", async (req, res) => {
  try {
    const { token } = req.body;
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID,
    });

    const { email, name, picture } = ticket.getPayload();

    let user = await User.findOne({ email });
    if (!user) {
      user = new User({ email, username: name, profilePicture: picture, isValidated: true });
      await user.save();
    }

    const jwtToken = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "7d" });

    res.status(200).json({ message: "Connexion r√©ussie avec Google", token: jwtToken, user });
  } catch (error) {
    console.error("Erreur Google Login:", error);
    res.status(500).json({ message: "Erreur lors de l'authentification Google", error: error.message });
  }
});





router.post("/register", upload.single("profileImage"), async (req, res) => {
  try {
    const { username, email, password, phoneNumber, role, ...roleSpecificData } = req.body;

    console.log("Donn√©es re√ßues :", req.body); // Log pour v√©rifier les donn√©es re√ßues

    // V√©rifier si l'utilisateur existe d√©j√†
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      console.log("Email d√©j√† utilis√© :", email);
      return res.status(400).json({ message: "Email d√©j√† utilis√©" });
    }

    // Hacher le mot de passe
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // Si le r√¥le est un r√¥le restreint (Doctor, Nurse, Admin), l'utilisateur doit √™tre en attente
    const isValidated = false; // Si r√¥le Patient, utilisateur est valid√©

    // Cr√©er un nouvel utilisateur
    const newUserData = {
      username,
      email,
      password: hashedPassword,
      phoneNumber,
      role,
      isValidated,
      profileImage: req.file ? `/uploads/${req.file.filename}` : null
    };

    // Ajouter les champs sp√©cifiques au r√¥le
    switch (role) {
      case "Patient":
        const { name, dateOfBirth, gender, address, emergencyContact, bloodType, allergies } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!name || !dateOfBirth || !gender || !address || !emergencyContact || !bloodType) {
          console.log("Champs obligatoires manquants pour un patient");
          return res.status(400).json({ message: "Tous les champs obligatoires pour un patient doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques au patient
        newUserData.name = name;
        newUserData.dateOfBirth = dateOfBirth;
        newUserData.gender = gender;
        newUserData.address = address;
        newUserData.emergencyContact = emergencyContact;
        newUserData.bloodType = bloodType;
        newUserData.allergies = allergies || []; // Les allergies sont optionnelles
        break;

      case "Doctor":
        const { badgeNumber: docBadgeNumber, specialization, licenseNumber: docLicenseNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!docBadgeNumber || !specialization || !docLicenseNumber) {
          console.log("Champs obligatoires manquants pour un m√©decin");
          return res.status(400).json({ message: "Tous les champs obligatoires pour un m√©decin doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques au m√©decin
        newUserData.badgeNumber = docBadgeNumber;
        newUserData.specialization = specialization;
        newUserData.licenseNumber = docLicenseNumber;
        break;

      case "Nurse":
        const { badgeNumber: nurseBadgeNumber, shift, licenseNumber: nurseLicenseNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!nurseBadgeNumber || !shift || !nurseLicenseNumber) {
          console.log("Champs obligatoires manquants pour une infirmi√®re");
          return res.status(400).json({ message: "Tous les champs obligatoires pour une infirmi√®re doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques √† l'infirmi√®re
        newUserData.badgeNumber = nurseBadgeNumber;
        newUserData.shift = shift;
        newUserData.licenseNumber = nurseLicenseNumber;
        break;

      case "Administrator":
        const { badgeNumber: adminBadgeNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!adminBadgeNumber) {
          console.log("Champs obligatoires manquants pour un administrateur");
          return res.status(400).json({ message: "Le num√©ro de badge est obligatoire pour un administrateur" });
        }

        // Ajouter les champs sp√©cifiques √† l'administrateur
        newUserData.badgeNumber = adminBadgeNumber;
        break;

      default:
        console.log("R√¥le invalide :", role);
        return res.status(400).json({ message: "R√¥le invalide" });
    }

    // Cr√©er un nouvel utilisateur
    const newUser = new User(newUserData);
    await newUser.save();
    console.log("Utilisateur cr√©√© avec succ√®s :", newUser);

    // G√©n√©rer et envoyer l'OTP
    const { otp, hashedOTP } = await generateOTP();
    console.log("OTP g√©n√©r√© :", otp);
    await saveOTPToUser(email, hashedOTP);
    console.log("OTP enregistr√© pour l'utilisateur :", email);
    await sendOTP(email, otp);
    console.log("OTP envoy√© √† :", email);

    // Envoyer un SMS de confirmation avec le num√©ro de t√©l√©phone
    const smsMessage = `Bienvenue ${username}, votre inscription a √©t√© r√©ussie !  Veuillez v√©rifier votre email pour l'OTP.`;
    await sendSMS(smsMessage, phoneNumber); // <--- CORRECT
    console.log("SMS envoy√© √† :", phoneNumber);

    res.status(201).json({ message: "Utilisateur cr√©√© avec succ√®s. Veuillez v√©rifier votre email pour l'OTP.", user: newUser });
  } catch (error) {
    console.error("Erreur lors de l'inscription :", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Route pour r√©initialiser le mot de passe
const transporter = nodemailer.createTransport({
  host: "smtp.gmail.com", // Serveur SMTP d'Outlook
  port: 587, // Port SMTP
  secure: false, // true pour le port 465, false pour les autres ports
  auth: {
    user: process.env.EMAIL_USER, // Votre adresse email
    pass: process.env.EMAIL_PASSWORD, // Votre mot de passe
  },
});
// üìå Route pour demander une r√©initialisation de mot de passe
router.post("/forgot-password", async (req, res) => {
  try {
    console.log("üì© Requ√™te re√ßue :", req.body);
    const { email } = req.body;

    // V√©rifier si l'utilisateur existe
    const user = await User.findOne({ email });
    if (!user) {
      console.log("‚ö† Utilisateur non trouv√© :", email);
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    // G√©n√©rer un token de r√©initialisation
    const resetToken = crypto.randomBytes(20).toString("hex");
    const resetTokenExpiry = Date.now() + 3600000; // 1 heure de validit√©

    // Enregistrer le token et sa date d'expiration dans la base de donn√©es
    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = resetTokenExpiry;
    await user.save();
    console.log("‚úÖ Token enregistr√© pour :", user.email);

    // üîó Construire le lien de r√©initialisation avec la syntaxe correcte
    const resetUrl = `http://localhost:3000/reset-password/${resetToken}`;

    // Envoyer un email avec le lien de r√©initialisation
    const mailOptions = {
      to: user.email,
      from: process.env.EMAIL_USER,
      subject: "R√©initialisation de mot de passe",
      html: `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R√©initialisation de mot de passe</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 0;
            text-align: center;
        }
        .container {
            width: 100%;
            max-width: 600px;
            margin: 50px auto;
            background-color: #ffffff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #333;
            font-size: 24px;
        }
        p {
            font-size: 16px;
            color: #555;
        }
        a {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            font-weight: bold;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            margin-top: 20px;
        }
        a:hover {
            background-color: #45a049;
        }
        .footer {
            font-size: 14px;
            color: #888;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>R√©initialisation de votre mot de passe</h2>
        <p>Vous avez demand√© une r√©initialisation de mot de passe. Cliquez sur le lien ci-dessous pour r√©initialiser votre mot de passe :</p>
        <a href="${resetUrl}">R√©initialiser votre mot de passe</a>
        <p class="footer">Si vous n'avez pas demand√© cette r√©initialisation, vous pouvez ignorer cet email.</p>
    </div>
</body>
</html>`,
    };

    console.log("üì® Envoi de l'email √† :", user.email);
    await transporter.sendMail(mailOptions);
    console.log("‚úÖ Email envoy√© avec succ√®s");

    res.status(200).json({ message: "Un email de r√©initialisation a √©t√© envoy√©" });
  } catch (error) {
    console.error("‚ùå Erreur dans /forgot-password :", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message || error });
  }
});

// Route pour r√©initialiser le mot de passe
router.post("/reset-password/:token", async (req, res) => {
  console.log("Reset password route hit");
  try {
    const { token } = req.params;
    const { newPassword } = req.body;
    console.log("Requ√™te re√ßue :", req.body); // Log pour v√©rifier la requ√™te
    // Trouver l'utilisateur avec le token valide
    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: Date.now() }, // V√©rifier que le token n'a pas expir√©
    });

    if (!user) return res.status(400).json({ message: "Token invalide ou expir√©" });

    // Hacher le nouveau mot de passe
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    // Mettre √† jour le mot de passe et effacer le token
    user.password = hashedPassword;
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    await user.save();

    res.status(200).json({ success: true, message: "Mot de passe r√©initialis√© avec succ√®s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});


// Route pour mettre √† jour le profil d'un utilisateur
router.put("/update-profile/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { username, phoneNumber, role, ...roleSpecificData } = req.body;

    // Trouver l'utilisateur par son ID
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Mettre √† jour les champs communs
    if (username) user.username = username;
    if (phoneNumber) user.phoneNumber = phoneNumber;

    // Mettre √† jour les champs sp√©cifiques au r√¥le
    switch (user.role) {
      case "Patient":
        const { name, dateOfBirth, gender, address, emergencyContact, bloodType, allergies } = roleSpecificData;

        if (name) user.name = name;
        if (dateOfBirth) user.dateOfBirth = dateOfBirth;
        if (gender) user.gender = gender;
        if (address) user.address = address;
        if (emergencyContact) user.emergencyContact = emergencyContact;
        if (bloodType) user.bloodType = bloodType;
        if (allergies) user.allergies = allergies;
        break;

      case "Doctor":
        const { badgeNumber: docBadgeNumber, specialization, licenseNumber: docLicenseNumber } = roleSpecificData;

        if (docBadgeNumber) user.badgeNumber = docBadgeNumber;
        if (specialization) user.specialization = specialization;
        if (docLicenseNumber) user.licenseNumber = docLicenseNumber;
        break;

      case "Nurse":
        const { badgeNumber: nurseBadgeNumber, shift, licenseNumber: nurseLicenseNumber } = roleSpecificData;

        if (nurseBadgeNumber) user.badgeNumber = nurseBadgeNumber;
        if (shift) user.shift = shift;
        if (nurseLicenseNumber) user.licenseNumber = nurseLicenseNumber;
        break;

      case "Administrator":
        const { badgeNumber: adminBadgeNumber } = roleSpecificData;

        if (adminBadgeNumber) user.badgeNumber = adminBadgeNumber;
        break;

      default:
        return res.status(400).json({ message: "R√¥le invalide" });
    }

    // Sauvegarder les modifications
    await user.save();

    res.status(200).json({ message: "Profil mis √† jour avec succ√®s", user });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
// Route pour changer le r√¥le d'un utilisateur (admin uniquement)
router.put("/change-role/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { role } = req.body;

    // Trouver l'utilisateur par son ID
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Changer le r√¥le de l'utilisateur
    user.role = role;
    await user.save();

    res.status(200).json({ message: "R√¥le de l'utilisateur mis √† jour avec succ√®s", user });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Send OTP Route
router.post("/send-otp", async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: "Email is required" });

    // Generate OTP
    const { otp, hashedOTP } = await generateOTP();

    // Store OTP with expiration (e.g., 5 minutes)
    saveOTPToUser(email, hashedOTP);

    // Send OTP to email
    await sendOTP(email, otp);

    res.status(200).json({ message: "OTP sent successfully" });
  } catch (error) {
    console.error("Error sending OTP:", error);
    res.status(500).json({ message: "Server error", error });
  }
});
router.post("/verify-otp", async (req, res) => {
  const { email, otp } = req.body;

  if (!email || !otp) {
    return res.status(400).json({ message: "Email et OTP sont requis" });
  }

  try {
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Utilisateur non trouv√©" });

    if (Date.now() > user.otpExpires) {
      return res.status(400).json({ message: "OTP expir√©" });
    }

    const isValid = await verifyOTP(otp, user.otp);
    if (!isValid) {
      if (user.role === "Patient") user.isValidated = true;
      return res.status(400).json({ message: "OTP incorrect" });

    }

    // Mettre √† jour l'utilisateur apr√®s v√©rification
    user.otpValidated = true;
    user.otp = undefined;
    user.otpExpires = undefined;
    user.isValidated = true;
    await user.save();

    res.status(200).json({ message: "OTP v√©rifi√© avec succ√®s. Vous pouvez maintenant vous connecter." });
  } catch (error) {
    console.error("Erreur lors de la v√©rification de l'OTP:", error);
    res.status(500).json({ message: "Erreur serveur", error });
  }
});


router.post('/send-sms', async (req, res) => {
  const { body, phoneNumber } = req.body;

  // V√©rifier que le corps du message et le num√©ro de t√©l√©phone sont fournis
  if (!body || !phoneNumber) {
    return res.status(400).json({ success: false, message: 'Body and phone number are required' });
  }

  try {
    const result = await sendSMS(body, phoneNumber);
    if (result.success) {
      return res.status(200).json(result);
    } else {
      return res.status(500).json(result);
    }
  } catch (error) {
    console.error(error);
    return res.status(500).json({ success: false, message: 'Failed to send SMS', error: error.message });
  }
});

///////router export 
export default router;
</file>

<file path="routes/bloodRequests.js">
import express from "express";
import mongoose from "mongoose";
import BloodRequest from "../models/BloodRequest.js";
import { authenticateToken, authorize } from "../middleware/authMiddleware.js"; // Assuming you have authorize middleware
import EmergencyPatient from "../models/EmergencyPatient.js"; // Or User if patients are Users
import { User } from "../models/User.js"; // For populating staff info
import DonationPledge from "../models/DonationPledge.js"; 
const router = express.Router();

// Middleware to authorize only medical staff (Doctor, Nurse, Administrator) for certain actions
const authorizeMedicalStaff = authorize(["Doctor", "Nurse", "Administrator"]);
const authorizeDoctorNurse = authorize(["Doctor", "Nurse"]);
const authorizeAdmin = authorize(["Administrator"]);

// == POST /api/blood-requests ==
// Create a new blood request
router.post("/", authenticateToken, authorizeMedicalStaff, async (req, res) => {
  try {
    const {
      patientId,
      bloodTypeNeeded,
      quantityNeeded,
      urgency,
      reason,
      hospitalLocation,
      contactPerson,
      contactPhone,
      notes,
      expiresAt,
    } = req.body;

    // Validate patientId exists
    const patient = await EmergencyPatient.findById(patientId); // Or User.findById(patientId) if using User model for patients
    if (!patient) {
      return res.status(404).json({ message: "Patient not found." });
    }

    const newBloodRequest = new BloodRequest({
      patientId,
      requestingStaffId: req.user.id, // ID of the logged-in staff member
      bloodTypeNeeded,
      quantityNeeded,
      urgency,
      reason,
      hospitalLocation,
      contactPerson,
      contactPhone,
      notes,
      expiresAt,
      status: "Open", // Default status
    });

    const savedRequest = await newBloodRequest.save();
    // TODO: Potentially emit a WebSocket event for new blood request: req.io.emit('newBloodRequest', savedRequest);

    res.status(201).json(savedRequest);
  } catch (error) {
    console.error("Error creating blood request:", error);
    if (error.name === "ValidationError") {
      return res.status(400).json({ message: "Validation Error", errors: error.errors });
    }
    res.status(500).json({ message: "Server error creating blood request", error: error.message });
  }
});

// == GET /api/blood-requests/active ==
// Get all active (Open or Partially Fulfilled) blood requests (for public/donor view)
// This route might not need strict authentication or could be open to all logged-in users
router.get("/active", async (req, res) => {
  try {
    const activeRequests = await BloodRequest.find({
      status: { $in: ["Open", "Partially Fulfilled"] },
      $or: [ // Optionally filter out expired requests if expiresAt is used
          { expiresAt: { $exists: false } },
          { expiresAt: null },
          { expiresAt: { $gt: new Date() } }
      ]
    })
      .populate("patientId", "firstName lastName bloodType") // Populate limited patient info for privacy
      .populate("requestingStaffId", "username") // Staff who created it
      .sort({ urgency: 1, createdAt: -1 }); // Sort by urgency then by newest

    res.status(200).json(activeRequests);
  } catch (error) {
    console.error("Error fetching active blood requests:", error);
    res.status(500).json({ message: "Server error fetching active blood requests", error: error.message });
  }
});

// == GET /api/blood-requests/all ==
// Get ALL blood requests (for admin/staff view)
router.get("/all", authenticateToken, authorizeMedicalStaff, async (req, res) => {
  try {
    const allRequests = await BloodRequest.find({})
      .populate("patientId", "firstName lastName bloodType")
      .populate("requestingStaffId", "username role")
      .sort({ createdAt: -1 });
    res.status(200).json(allRequests);
  } catch (error) {
    console.error("Error fetching all blood requests:", error);
    res.status(500).json({ message: "Server error fetching all blood requests", error: error.message });
  }
});

// == GET /api/blood-requests/:id ==
// Get a specific blood request by ID
router.get("/:id", authenticateToken, async (req, res) => { // Authenticate to ensure logged-in user
  try {
    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
        return res.status(400).json({ message: "Invalid blood request ID format." });
    }
    const request = await BloodRequest.findById(req.params.id)
      .populate("patientId") // Populate with more patient details if needed for staff
      .populate("requestingStaffId", "username role email phoneNumber");

    if (!request) {
      return res.status(404).json({ message: "Blood request not found." });
    }
    res.status(200).json(request);
  } catch (error) {
    console.error("Error fetching blood request by ID:", error);
    res.status(500).json({ message: "Server error fetching blood request", error: error.message });
  }
});

// == PUT /api/blood-requests/:id ==
// Update a blood request (e.g., update status, quantityFulfilled)
router.put("/:id", authenticateToken, authorizeMedicalStaff, async (req, res) => {
  try {
    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
        return res.status(400).json({ message: "Invalid blood request ID format." });
    }

    const { quantityFulfilled, status, notes, ...otherUpdatableFields } = req.body;
    const updateData = { ...otherUpdatableFields };

    if (quantityFulfilled !== undefined) {
      updateData.quantityFulfilled = Number(quantityFulfilled);
    }
    if (status) {
      updateData.status = status;
    }
    if (notes) {
      updateData.notes = notes;
    }

    // Ensure quantityFulfilled does not exceed quantityNeeded
    const existingRequest = await BloodRequest.findById(req.params.id);
    if (!existingRequest) {
      return res.status(404).json({ message: "Blood request not found." });
    }
    if (updateData.quantityFulfilled > existingRequest.quantityNeeded) {
      return res.status(400).json({ message: "Fulfilled quantity cannot exceed needed quantity." });
    }

    // Auto-update status to "Fulfilled" or "Partially Fulfilled"
    if (updateData.quantityFulfilled !== undefined) {
        if (updateData.quantityFulfilled >= existingRequest.quantityNeeded) {
            updateData.status = "Fulfilled";
        } else if (updateData.quantityFulfilled > 0) {
            updateData.status = "Partially Fulfilled";
        }
        // If quantityFulfilled is 0, status might be "Open" or manually set.
    }


    const updatedRequest = await BloodRequest.findByIdAndUpdate(
      req.params.id,
      { $set: updateData },
      { new: true, runValidators: true }
    )
    .populate("patientId", "firstName lastName bloodType")
    .populate("requestingStaffId", "username role");

    if (!updatedRequest) {
      return res.status(404).json({ message: "Blood request not found." });
    }

    // TODO: Potentially emit WebSocket event for updated blood request: req.io.emit('updateBloodRequest', updatedRequest);

    res.status(200).json(updatedRequest);
  } catch (error) {
    console.error("Error updating blood request:", error);
    if (error.name === "ValidationError") {
      return res.status(400).json({ message: "Validation Error", errors: error.errors });
    }
    res.status(500).json({ message: "Server error updating blood request", error: error.message });
  }
});

// == DELETE /api/blood-requests/:id ==
// Delete a blood request (Admin only, or perhaps the creating staff if not fulfilled)
router.delete("/:id", authenticateToken, authorizeAdmin, async (req, res) => {
  try {
    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
        return res.status(400).json({ message: "Invalid blood request ID format." });
    }
    const deletedRequest = await BloodRequest.findByIdAndDelete(req.params.id);
    if (!deletedRequest) {
      return res.status(404).json({ message: "Blood request not found." });
    }
    // TODO: Potentially emit WebSocket event for deleted blood request: req.io.emit('deleteBloodRequest', { id: req.params.id });
    res.status(200).json({ message: "Blood request deleted successfully." });
  } catch (error) {
    console.error("Error deleting blood request:", error);
    res.status(500).json({ message: "Server error deleting blood request", error: error.message });
  }
});
router.post("/:requestId/pledge", authenticateToken, async (req, res) => {
  console.log("--- New Pledge Request ---");
  console.log("Initial req.user from token:", JSON.stringify(req.user, null, 2));

  try {
    const { requestId } = req.params;
    const { donorContactPhone, donorBloodType, pledgedQuantity, donationNotes } = req.body;
    const donorUserId = req.user.id; // This ID comes from the token

    // --- FETCH FULL USER DETAILS USING THE ID FROM THE TOKEN ---
    let pledgingUser;
    try {
      // Fetch user and their current unlockedBadges and donationCount
      pledgingUser = await User.findById(donorUserId).select("username phoneNumber donationCount unlockedBadges").lean();
    } catch (userFetchError) {
      console.error(`Error fetching user details for ID ${donorUserId}:`, userFetchError);
      return res.status(500).json({ message: "Server error: Could not retrieve donor information." });
    }

    if (!pledgingUser) {
      console.error(`CRITICAL: User with ID ${donorUserId} not found in database, but token was valid.`);
      return res.status(404).json({ message: "Donor user account not found." });
    }

    const donorName = pledgingUser.username;

    // Fallback for phone number if not provided in form but available in user profile
    const finalDonorContactPhone = donorContactPhone || pledgingUser.phoneNumber;

    console.log(`Pledge attempt by User ID: ${donorUserId}, Username: ${donorName}, Contact: ${finalDonorContactPhone}`);

    // --- Validations ---
    if (!donorName) {
        console.error("Critical Error: donorName is undefined even after fetching user from DB. User object:", pledgingUser);
        return res.status(500).json({ message: "Server error: Could not retrieve donor name." });
    }
    if (!finalDonorContactPhone) {
        return res.status(400).json({ message: "Donor contact phone is required either in the form or in your profile." });
    }
    if (!mongoose.Types.ObjectId.isValid(requestId)) {
      return res.status(400).json({ message: "Invalid blood request ID." });
    }

    const bloodRequest = await BloodRequest.findById(requestId);
    if (!bloodRequest) {
      return res.status(404).json({ message: "Blood request not found." });
    }
    if (["Fulfilled", "Closed", "Cancelled"].includes(bloodRequest.status)) {
        return res.status(400).json({ message: "This blood request is no longer accepting pledges." });
    }
    if (!donorBloodType || !pledgedQuantity || Number(pledgedQuantity) < 1) { // Ensure pledgedQuantity is a number
        return res.status(400).json({ message: "Missing required pledge information or invalid quantity." });
    }

    const newPledge = new DonationPledge({
      bloodRequestId: requestId,
      donorUserId,
      donorName,
      donorContactPhone: finalDonorContactPhone,
      donorBloodType,
      pledgedQuantity: Number(pledgedQuantity),
      donationNotes,
      status: "Pledged", // Or "Donated" if pledges are considered immediate donations
    });

    console.log("Pledge object to be saved:", JSON.stringify(newPledge, null, 2));

    await newPledge.save();

    // --- START BADGE LOGIC ---
    // Update donor's donation count and check for new badges
    // This assumes a pledge immediately counts towards donation milestones.
    // In a real system, you might have a separate step to confirm the donation happened.
    
    // --- END BADGE LOGIC ---

    // Update the blood request's fulfilled quantity and status based on all active pledges
    const allPledgesForRequest = await DonationPledge.find({ bloodRequestId: requestId, status: { $ne: "Cancelled" } });
    const totalPledgedQuantity = allPledgesForRequest.reduce((sum, pledge) => sum + pledge.pledgedQuantity, 0);

    bloodRequest.quantityFulfilled = totalPledgedQuantity;

    if (bloodRequest.quantityFulfilled >= bloodRequest.quantityNeeded * 2) {
      bloodRequest.status = "Fulfilled";
    } else if (bloodRequest.quantityFulfilled >= bloodRequest.quantityNeeded) {
      bloodRequest.status = "Partially Fulfilled";
    } else if (bloodRequest.quantityFulfilled > 0) {
        bloodRequest.status = "Partially Fulfilled";
    } else if (bloodRequest.quantityFulfilled === 0 && bloodRequest.status !== "Open") {
       // If all pledges are cancelled and it wasn't already Open, revert to Open
       bloodRequest.status = "Open";
    }

    await bloodRequest.save();

    // TODO: Notify staff about the new pledge and potential request status change via WebSocket
    // if (req.io) {
    //   req.io.to('staff-room').emit('pledgeUpdate', { pledge: newPledge, request: bloodRequest });
    // }

    res.status(201).json({ message: "Donation pledged successfully!", pledge: newPledge, updatedRequest: bloodRequest });

  } catch (error) {
    console.error("Error pledging donation:", error);
    if (error.name === "ValidationError") {
      console.error("Mongoose Validation Errors:", JSON.stringify(error.errors, null, 2));
      return res.status(400).json({ message: "Validation Error", errors: error.errors });
    }
    res.status(500).json({ message: "Server error pledging donation.", error: error.message });
  }
});

// == GET /api/blood-requests/:requestId/pledges ==
// Get all pledges for a specific blood request (for staff/admin view)
// Medical staff updates the status of a specific pledge (e.g., confirm donation)
router.put("/pledges/:pledgeId/status", authenticateToken, authorizeDoctorNurse, async (req, res) => {
  console.log(`--- Update Pledge Status Request for Pledge ID: ${req.params.pledgeId} ---`);
  try {
    const { pledgeId } = req.params;
    const { status: newStatus, staffNotes } = req.body; // Optional: staff can add notes to the pledge update

    if (!mongoose.Types.ObjectId.isValid(pledgeId)) {
      return res.status(400).json({ message: "Invalid pledge ID." });
    }

    const validStatuses = ["Pledged", "Scheduled", "Donated", "Cancelled"];
    if (!newStatus || !validStatuses.includes(newStatus)) {
      return res.status(400).json({ message: "Invalid status provided." });
    }

    const pledgeToUpdate = await DonationPledge.findById(pledgeId);
    if (!pledgeToUpdate) {
      return res.status(404).json({ message: "Donation pledge not found." });
    }

    const oldStatus = pledgeToUpdate.status;
    pledgeToUpdate.status = newStatus;
    if (staffNotes) {
      pledgeToUpdate.donationNotes = pledgeToUpdate.donationNotes
        ? `${pledgeToUpdate.donationNotes}\nStaff Note (${new Date().toLocaleDateString()}): ${staffNotes}`
        : `Staff Note (${new Date().toLocaleDateString()}): ${staffNotes}`;
    }

    await pledgeToUpdate.save();
    console.log(`Pledge ${pledgeId} status updated to ${newStatus} by ${req.user.username}`);

    // --- BADGE AND BLOOD REQUEST UPDATE LOGIC (MOVED HERE) ---
    if (newStatus === "Donated" && oldStatus !== "Donated") { // Only trigger if newly marked as Donated
      // Update donor's donation count
      const donorToUpdate = await User.findById(pledgeToUpdate.donorUserId);
      if (donorToUpdate) {
        donorToUpdate.donationCount = (donorToUpdate.donationCount || 0) + 1; // Increment by 1 for the act of donation

        const currentUnlockedBadges = donorToUpdate.unlockedBadges || [];
        const newlyUnlockedBadges = [];
        if (donorToUpdate.donationCount >= 2 && !currentUnlockedBadges.includes("beginner")) newlyUnlockedBadges.push("beginner");
        if (donorToUpdate.donationCount >= 5 && !currentUnlockedBadges.includes("committed")) newlyUnlockedBadges.push("committed");
        if (donorToUpdate.donationCount >= 10 && !currentUnlockedBadges.includes("heroic")) newlyUnlockedBadges.push("heroic");
        if (donorToUpdate.donationCount >= 20 && !currentUnlockedBadges.includes("legendary")) newlyUnlockedBadges.push("legendary");

        if (newlyUnlockedBadges.length > 0) {
          donorToUpdate.unlockedBadges.push(...newlyUnlockedBadges);
           // TODO: Notify user about new badge
           // if(req.io) req.io.to(`user_${donorToUpdate._id}`).emit('newBadgeUnlocked', { badges: newlyUnlockedBadges, totalDonations: donorToUpdate.donationCount });
        }
        await donorToUpdate.save();
        console.log(`User ${donorToUpdate.username} donation act count updated to ${donorToUpdate.donationCount}`);
      }

      // Update the associated BloodRequest's quantityFulfilled
      const bloodRequest = await BloodRequest.findById(pledgeToUpdate.bloodRequestId);
      if (bloodRequest) {
        // Recalculate based on ALL "Donated" pledges for this request
        const donatedPledges = await DonationPledge.find({
          bloodRequestId: pledgeToUpdate.bloodRequestId,
          status: "Donated"
        });
        const totalDonatedQuantity = donatedPledges.reduce((sum, p) => sum + p.pledgedQuantity, 0);
        
        bloodRequest.quantityFulfilled = totalDonatedQuantity; // Now this reflects actual donated units

        // Update status of BloodRequest based on actual donations
        if (bloodRequest.quantityFulfilled >= bloodRequest.quantityNeeded) { // Changed from *2 to just needed quantity
          bloodRequest.status = "Fulfilled";
        } else if (bloodRequest.quantityFulfilled > 0) {
          bloodRequest.status = "Partially Fulfilled";
        } else {
          // If donations are cancelled and it goes to 0, revert to Open
          if (bloodRequest.status !== "Cancelled" && bloodRequest.status !== "Closed") {
            bloodRequest.status = "Open";
          }
        }
        await bloodRequest.save();
        console.log(`BloodRequest ${bloodRequest._id} quantityFulfilled updated to ${bloodRequest.quantityFulfilled}, status to ${bloodRequest.status}`);
        // TODO: Notify relevant parties about BloodRequest update
        // if (req.io) req.io.to('staff-room').emit('bloodRequestUpdated', bloodRequest);
      }
    } else if (oldStatus === "Donated" && newStatus !== "Donated") {
      // If a donation was revered (e.g., marked as Cancelled after being Donated)
      // Decrement donation count and potentially remove badges (more complex, handle carefully)
      // And recalculate bloodRequest.quantityFulfilled
      // This part needs careful consideration of your business logic for reversals.
       const donorToUpdate = await User.findById(pledgeToUpdate.donorUserId);
        if (donorToUpdate) {
            donorToUpdate.donationCount = Math.max(0, (donorToUpdate.donationCount || 0) - 1); // Decrement act count
            // Badge removal logic would be more complex here. For now, just decrement count.
            await donorToUpdate.save();
        }
        const bloodRequest = await BloodRequest.findById(pledgeToUpdate.bloodRequestId);
        if (bloodRequest) {
            const donatedPledges = await DonationPledge.find({ bloodRequestId: pledgeToUpdate.bloodRequestId, status: "Donated" });
            const totalDonatedQuantity = donatedPledges.reduce((sum, p) => sum + p.pledgedQuantity, 0);
            bloodRequest.quantityFulfilled = totalDonatedQuantity;
            // Re-evaluate status
            if (bloodRequest.quantityFulfilled >= bloodRequest.quantityNeeded) bloodRequest.status = "Fulfilled";
            else if (bloodRequest.quantityFulfilled > 0) bloodRequest.status = "Partially Fulfilled";
            else if (bloodRequest.status !== "Cancelled" && bloodRequest.status !== "Closed") bloodRequest.status = "Open";
            await bloodRequest.save();
        }
    }


    const updatedPledge = await DonationPledge.findById(pledgeId)
        .populate("donorUserId", "username email"); // Send back populated pledge

    res.status(200).json({ message: "Pledge status updated successfully.", pledge: updatedPledge });

  } catch (error) {
    console.error("Error updating pledge status:", error);
    if (error.name === "ValidationError") {
      return res.status(400).json({ message: "Validation Error", errors: error.errors });
    }
    res.status(500).json({ message: "Server error updating pledge status.", error: error.message });
  }
});


// GET /api/blood-requests/:requestId/pledges
// (This route remains the same as provided before)
router.get("/:requestId/pledges", authenticateToken, authorizeMedicalStaff, async (req, res) => {
    try {
        const { requestId } = req.params;
        if (!mongoose.Types.ObjectId.isValid(requestId)) {
            return res.status(400).json({ message: "Invalid blood request ID." });
        }

        const pledges = await DonationPledge.find({ bloodRequestId: requestId })
            .populate("donorUserId", "username email")
            .sort({ createdAt: -1 });

        if (!pledges) { // Should return empty array if no pledges, not null
            return res.status(200).json([]);
        }
        res.status(200).json(pledges);
    } catch (error) {
        console.error("Error fetching pledges:", error);
        res.status(500).json({ message: "Server error fetching pledges.", error: error.message });
    }
});

export default router;
</file>

<file path="routes/chatbot.js">
// backend/routes/chatbot.js
import express from 'express';
import mongoose from 'mongoose';
import { authenticateToken, authorize } from '../middleware/authMiddleware.js';
import { getAnswerFromContext } from '../services/huggingFaceQAService.js';

// Importer vos mod√®les Mongoose
import EmergencyPatient from '../models/EmergencyPatient.js';
import MedicalRecord from '../models/MedicalRecord.js';
import PatientFile from '../models/PatientFile.js';
import Resource from '../models/Resource.js';
import Ambulance from '../models/Ambulance.js';
// User n'est pas directement utilis√© ici, mais gard√© au cas o√π pour des √©volutions.
// import { User } from '../models/User.js';

const router = express.Router();

const formatDateForContext = (dateString) => {
    if (!dateString) return 'non sp√©cifi√©e';
    try {
        return new Date(dateString).toLocaleString('fr-FR', {
            day: '2-digit', month: '2-digit', year: 'numeric',
            hour: '2-digit', minute: '2-digit'
        });
    } catch (e) {
        return 'date invalide';
    }
};

const buildPatientContext = async (patientId, userQuery) => {
    console.log(`[BuildPatientCtx] D√©but pour patient ID: ${patientId}, Query: "${userQuery.substring(0,50)}..."`);
    const patient = await EmergencyPatient.findById(patientId).populate('assignedDoctor', 'username specialization');
    if (!patient) {
        console.warn(`[BuildPatientCtx] Patient non trouv√© pour ID: ${patientId}`);
        return "Les informations pour ce patient n'ont pas pu √™tre trouv√©es.";
    }

    let contextLines = [];

    // Informations de base de EmergencyPatient
    if (patient.firstName && patient.lastName) {
        contextLines.push(`Le nom complet du patient est ${patient.firstName} ${patient.lastName}.`);
    } else if (patient.firstName) {
        contextLines.push(`Le pr√©nom du patient est ${patient.firstName}.`);
    }
    if (patient.dateOfBirth) {
        const birthDate = new Date(patient.dateOfBirth);
        if (!isNaN(birthDate)) {
            const ageDifMs = Date.now() - birthDate.getTime();
            const ageDate = new Date(ageDifMs);
            const age = Math.abs(ageDate.getUTCFullYear() - 1970);
            contextLines.push(`Sa date de naissance est le ${birthDate.toLocaleDateString('fr-FR')}, il/elle a ${age} ans.`);
        }
    }
    if (patient.gender) contextLines.push(`Son genre est ${patient.gender}.`);
    if (patient.status) contextLines.push(`Son statut actuel est '${patient.status}'.`);
    if (patient.emergencyLevel) contextLines.push(`Son niveau d'urgence est '${patient.emergencyLevel}'.`);
    if (patient.currentSymptoms) contextLines.push(`Les sympt√¥mes principaux d√©crits par le patient sont : '${patient.currentSymptoms}'.`);
    if (patient.arrivalTime) contextLines.push(`Le patient est arriv√©(e) le ${formatDateForContext(patient.arrivalTime)}.`);
    if (patient.patientCode) contextLines.push(`Son code patient est ${patient.patientCode}.`);

    if (patient.assignedDoctor) {
        let doctorInfoStr = `Le m√©decin assign√© est Dr. ${patient.assignedDoctor.username}`;
        if (patient.assignedDoctor.specialization && String(patient.assignedDoctor.specialization).toLowerCase() !== 'undefined') {
            doctorInfoStr += `, sp√©cialiste en ${patient.assignedDoctor.specialization}.`;
        } else {
            doctorInfoStr += ".";
        }
        contextLines.push(doctorInfoStr);
    } else {
        contextLines.push("Aucun m√©decin n'est formellement assign√© √† ce patient pour le moment.");
    }

    // Informations de MedicalRecord
    const medicalRecord = await MedicalRecord.findOne({ patientId: patient._id });
    if (medicalRecord) {
        if (medicalRecord.bloodType) {
            contextLines.push(`Son groupe sanguin est ${medicalRecord.bloodType}.`);
        } else {
            contextLines.push("Le groupe sanguin du patient n'est pas sp√©cifi√© dans le dossier m√©dical.");
        }
        if (medicalRecord.knownAllergies && medicalRecord.knownAllergies.length > 0 &&
            !(medicalRecord.knownAllergies.length === 1 && String(medicalRecord.knownAllergies[0]).toLowerCase().includes('none'))) { // G√®re "none", "noneee"
            contextLines.push(`Les allergies connues du patient sont : ${medicalRecord.knownAllergies.join(', ')}.`);
        } else {
            contextLines.push("Aucune allergie connue n'est mentionn√©e dans le dossier m√©dical du patient.");
        }
    } else {
        contextLines.push("Aucun dossier m√©dical principal (contenant groupe sanguin ou allergies) n'a √©t√© trouv√© pour ce patient.");
    }

    const lowerUserQuery = userQuery.toLowerCase();

    // Charger des d√©tails sp√©cifiques des PatientFile si la query le sugg√®re
    if (lowerUserQuery.includes("signes vitaux") || lowerUserQuery.includes("vitals") || lowerUserQuery.includes("temp√©rature") || lowerUserQuery.includes("tension") || lowerUserQuery.includes("pouls") || lowerUserQuery.includes("saturation")) {
        const vitalSignsFile = await PatientFile.findOne({ medicalRecord: medicalRecord?._id, type: "VitalSigns", isArchived: false }).sort({ dateRecorded: -1 });
        if (vitalSignsFile && vitalSignsFile.details?.vitalSigns) {
            let vitalsString = `Derniers signes vitaux enregistr√©s le ${formatDateForContext(vitalSignsFile.dateRecorded)}: `;
            const vs = vitalSignsFile.details.vitalSigns;
            if (vs.temperature != null) vitalsString += `Temp√©rature ${vs.temperature}¬∞C. `;
            if (vs.heartRate != null) vitalsString += `Pouls ${vs.heartRate}bpm. `;
            if (vs.bloodPressure?.systolic != null && vs.bloodPressure?.diastolic != null) vitalsString += `Tension ${vs.bloodPressure.systolic}/${vs.bloodPressure.diastolic}mmHg. `;
            if (vs.respiratoryRate != null) vitalsString += `Fr√©quence respiratoire ${vs.respiratoryRate}/min. `;
            if (vs.oxygenSaturation != null) vitalsString += `Saturation O2 ${vs.oxygenSaturation}%.`;
            contextLines.push(vitalsString.trim());
        } else {
            contextLines.push("Aucun enregistrement r√©cent de signes vitaux n'a √©t√© trouv√© pour ce patient.");
        }
    }

    if (lowerUserQuery.includes("diagnostic") || lowerUserQuery.includes("diagnostique")) {
         const diagnosticFile = await PatientFile.findOne({ medicalRecord: medicalRecord?._id, type: "Diagnostic", isArchived: false }).sort({ dateRecorded: -1 });
         if (diagnosticFile && diagnosticFile.details?.diagnosis) {
            contextLines.push(`Le diagnostic principal pos√© le ${formatDateForContext(diagnosticFile.dateRecorded)} est : '${diagnosticFile.details.diagnosis}'.`);
            if (diagnosticFile.details.diagnosticTests?.length > 0) {
                contextLines.push("Tests diagnostiques associ√©s: " + diagnosticFile.details.diagnosticTests.map(t => `${t.testName || 'Test non nomm√©'} (R√©sultat: ${t.result || 'N/A'}, Date: ${formatDateForContext(t.date)})`).join('; '));
            }
         } else {
            contextLines.push("Aucun diagnostic principal r√©cent n'a √©t√© enregistr√© pour ce patient.");
         }
    }
    
    if (lowerUserQuery.includes("m√©dicament") || lowerUserQuery.includes("prescription") || lowerUserQuery.includes("traitement m√©dicamenteux")) {
        const prescriptionFile = await PatientFile.findOne({ medicalRecord: medicalRecord?._id, type: "Prescription", isArchived: false }).sort({ dateRecorded: -1 });
        if (prescriptionFile && prescriptionFile.details?.medications?.length > 0) {
            let medString = `M√©dicaments prescrits (le ${formatDateForContext(prescriptionFile.dateRecorded)}): `;
            medString += prescriptionFile.details.medications.map(m => `${m.name || 'M√©dicament non nomm√©'} ${m.dosage || ''} ${m.frequency || ''} pendant ${m.duration || ''}`).join('; ');
            contextLines.push(medString.trim());
        } else {
            contextLines.push("Aucune prescription r√©cente trouv√©e pour ce patient.");
        }
    }
    
    if (lowerUserQuery.includes("triage") || lowerUserQuery.includes("plainte principale")) {
        const triageFile = await PatientFile.findOne({ medicalRecord: medicalRecord?._id, type: "Triage", isArchived: false }).sort({ dateRecorded: -1 });
        if (triageFile) {
            let triageString = `Informations du triage (le ${formatDateForContext(triageFile.dateRecorded)}): `;
            if (triageFile.details?.priorityLevel) triageString += `Niveau de priorit√©: ${triageFile.details.priorityLevel}. `;
            if (triageFile.details?.chiefComplaint) triageString += `Plainte principale: ${triageFile.details.chiefComplaint}. `;
            if (triageFile.notes) triageString += `Notes additionnelles de triage: ${triageFile.notes}.`;
            contextLines.push(triageString.trim());
        } else {
            contextLines.push("Aucune information de triage r√©cente trouv√©e pour ce patient.");
        }
    }
    
    const finalContext = contextLines.join(' ').trim();
    console.log(`[BuildPatientCtx] Contexte final (premiers 500 chars):\n"${finalContext.substring(0, 500)}..."`);
    return finalContext;
};


const buildResourceContext = async (resourceId) => {
    const resource = await Resource.findById(resourceId);
    if (!resource) return "Ressource non trouv√©e.";
    return `La ressource est ${resource.name}, de type ${resource.type}. Son statut actuel est ${resource.status}. La quantit√© disponible est de ${resource.quantity}. Elle est localis√©e √† ${resource.location}.`;
};

const buildAmbulanceContext = async (ambulanceId) => {
    const ambulance = await Ambulance.findById(ambulanceId).populate('team', 'username');
    if (!ambulance) return "Ambulance non trouv√©e.";
    let teamInfo = ambulance.team && ambulance.team.length > 0 ? ambulance.team.map(member => member.username).join(', ') : 'Aucune personne assign√©e';
    let context = `L'ambulance est ${ambulance.name}. Son statut est ${ambulance.status}. `;
    if (ambulance.latitude != null && ambulance.longitude != null) {
        context += `Sa localisation actuelle est latitude ${ambulance.latitude}, longitude ${ambulance.longitude}. `;
    }
    if (ambulance.destination) {
        context += `Sa destination est ${ambulance.destination}. `;
    } else {
        context += `Aucune destination n'est actuellement d√©finie. `;
    }
    context += `L'√©quipe assign√©e est ${teamInfo}.`;
    return context;
};


router.post('/staff-query', authenticateToken, authorize(['Doctor', 'Nurse', 'Administrator']), async (req, res) => {
    const { targetType, targetId, userQuery } = req.body;
    
    console.log(`[Staff Query Route] Requ√™te re√ßue: targetType=${targetType}, targetId=${targetId}, userQuery="${userQuery}" par UserID: ${req.user.id}`);

    if (!targetType || !targetId || !userQuery) {
        console.warn("[Staff Query Route] Param√®tres manquants:", req.body);
        return res.status(400).json({ message: "targetType, targetId, et userQuery sont requis." });
    }
    if (!mongoose.Types.ObjectId.isValid(targetId)) {
        console.warn(`[Staff Query Route] targetId invalide: ${targetId}`);
        return res.status(400).json({ message: "targetId invalide." });
    }

    let context = "";
    try {
        switch (targetType) {
            case 'patient':
                context = await buildPatientContext(targetId, userQuery);
                break;
            case 'resource':
                context = await buildResourceContext(targetId);
                break;
            case 'ambulance':
                context = await buildAmbulanceContext(targetId);
                break;
            default:
                console.warn(`[Staff Query Route] targetType non support√©: ${targetType}`);
                return res.status(400).json({ message: "targetType non support√©." });
        }

        if (context.includes("non trouv√©") || context.includes("non trouv√©e")) {
             console.log(`[Staff Query Route] Entit√© cible non trouv√©e pour targetId ${targetId}. Contexte: "${context}"`);
             return res.status(404).json({ answer: context, score: 0 });
        }
        if (!context.trim()) {
            console.log(`[Staff Query Route] Contexte vide g√©n√©r√© pour targetId ${targetId} et query "${userQuery}".`);
            return res.status(200).json({ answer: "Je n'ai pas trouv√© d'informations sp√©cifiques pour cette requ√™te dans le dossier.", score: 0 });
        }

        // *** L'ORDRE EST IMPORTANT ICI : (question, contexte) ***
        const qaResult = await getAnswerFromContext(userQuery, context); 

        console.log(`[Staff Query Route] R√©ponse QA pour query "${userQuery}":`, qaResult);
        res.json(qaResult);

    } catch (error) {
        console.error("[Staff Query Route] Erreur interne lors du traitement de la requ√™te chatbot:", error);
        res.status(500).json({ message: "Erreur du serveur lors du traitement de la requ√™te chatbot.", details: error.message });
    }
});

export default router;
</file>

<file path="routes/emergencyPatients.js">
// backend/routes/emergencyPatients.js
import express from 'express';
import mongoose from 'mongoose';
import EmergencyPatient from '../models/EmergencyPatient.js';
import { User } from '../models/User.js';
import MedicalRecord from '../models/MedicalRecord.js';
import PatientFile from '../models/PatientFile.js';
import Notification from '../models/Notification.js'; // <--- AJOUTER L'IMPORT
import { authenticateToken } from '../middleware/authMiddleware.js';
import sendSMS from '../sendSMS.js';
import { getEstimatedWaitTime } from '../services/waitTimeService.js';

const router = express.Router();

// Helper function to find an available doctor (inchang√©)
const findAvailableDoctor = async () => {
  try {
    const doctor = await User.findOne({
      role: 'Doctor',
      isValidated: true,
      isAvailable: true,
    });
    return doctor;
  } catch (error) {
    console.error("Erreur lors de la recherche d'un m√©decin disponible:", error);
    return null;
  }
};

// POST route to create/update emergency patient registration
router.post('/', async (req, res) => {
  const io = req.io;
  const userSockets = req.userSockets;

  try {
    const { firstName, lastName, email, currentSymptoms, emergencyLevel, address, phoneNumber } = req.body;
    const existingPatient = await EmergencyPatient.findExistingPatient(firstName, lastName, email);
    let patient;
    let isNew = !existingPatient;

    if (existingPatient) {
      console.log(`Patient ${firstName} ${lastName} existe d√©j√†. Mise √† jour.`);
      patient = await EmergencyPatient.findByIdAndUpdate(
        existingPatient._id,
        { /* ...data... */ }, { new: true }
      );
    } else {
      console.log(`Nouveau patient: ${firstName} ${lastName}. Cr√©ation.`);
      patient = new EmergencyPatient({ ...req.body, isNewPatient: true });
      await patient.save();
    }

    const availableDoctor = await findAvailableDoctor();
    // let assignedDoctorDetails = null; // Pas utilis√© directement dans la r√©ponse JSON plus tard

    if (availableDoctor) {
      patient.assignedDoctor = availableDoctor._id;
      patient.status = 'M√©decin Assign√©';
      await patient.save();
      try {
        await User.findByIdAndUpdate(availableDoctor._id, { isAvailable: false });
        console.log(`M√©decin ${availableDoctor.username} (ID: ${availableDoctor._id}) mis √† jour √† 'Occup√©'.`);
      } catch (doctorUpdateError) {
        console.error(`ERREUR CRITIQUE: √âchec MAJ dispo m√©decin ${availableDoctor._id}.`, doctorUpdateError);
      }
      console.log(`M√©decin ${availableDoctor.username} assign√© au patient ${patient.firstName} ${patient.lastName}.`);

      // --- D√âBUT MODIFICATION NOTIFICATION M√âDECIN ---
      const doctorAssignmentPayload = {
        type: 'doctor_assignment',
        message: `You have been assigned to patient : ${patient.firstName} ${patient.lastName}.`,
        recipientId: availableDoctor._id, // Important pour la sauvegarde et le contexte
        relatedEntityId: patient._id,
        relatedEntityType: 'EmergencyPatient',
        patientName: `${patient.firstName} ${patient.lastName}` // Utile pour le toast frontend
      };

      try {
        const newDbNotificationForDoctor = new Notification({
            recipientId: doctorAssignmentPayload.recipientId,
            message: doctorAssignmentPayload.message,
            type: doctorAssignmentPayload.type,
            relatedEntityId: doctorAssignmentPayload.relatedEntityId,
            relatedEntityType: doctorAssignmentPayload.relatedEntityType
        });
        await newDbNotificationForDoctor.save();
        console.log(`üíæ Notification d'assignation sauvegard√©e en BDD pour m√©decin ${availableDoctor._id}`);
        // √âmettre le document sauvegard√© ou un payload enrichi si n√©cessaire
        // Pour la simplicit√©, on peut √©mettre le m√™me payload, le frontend le traitera
        // ou √©mettre newDbNotificationForDoctor.toObject() si vous voulez toutes les infos de la BDD.
      } catch (dbError) {
          console.error("‚ùå Erreur sauvegarde notification m√©decin en BDD:", dbError);
      }
      // --- FIN MODIFICATION NOTIFICATION M√âDECIN ---

      // --- D√âBUT MODIFICATION NOTIFICATION INFIRMI√àRE ---
      // Pour les infirmi√®res, on √©met √† une room. Si on veut une notif persistante par infirmi√®re,
      // il faudrait it√©rer sur les infirmi√®res connect√©es √† la room et cr√©er une notif pour chacune.
      // Pour l'instant, on se contente de l'√©mission socket.
      const nurseNotificationPayload = {
        type: 'new_emergency_case', // ou 'patient_assigned_to_doctor'
        message: `Patient: ${patient.firstName} ${patient.lastName} (Niveau: ${patient.emergencyLevel}) assign√© √† Dr. ${availableDoctor.username}.`,
        patientId: patient._id, // Garder patientId pour le toast frontend
        patientName: `${patient.firstName} ${patient.lastName}`,
        emergencyLevel: patient.emergencyLevel, // Ajouter le niveau pour le toast
        // Pas de recipientId sp√©cifique pour la room, donc pas de sauvegarde BDD simple ici
        // (sauf si on a un ID de groupe/r√¥le pour les infirmi√®res)
        relatedEntityId: patient._id,
        relatedEntityType: 'EmergencyPatient'
      };
      // --- FIN MODIFICATION NOTIFICATION INFIRMI√àRE ---


      const doctorSocketId = userSockets.get(availableDoctor._id.toString());
      if (doctorSocketId) {
        // Envoyer le document sauvegard√© ou un payload enrichi qui inclut l'ID de la notif BDD
        io.to(doctorSocketId).emit('notification', doctorAssignmentPayload); 
        console.log(`üì¨ WS Notif assignation envoy√©e m√©decin ${availableDoctor.username}`);
      } else {
        console.log(`‚ö†Ô∏è M√©decin assign√© ${availableDoctor.username} non connect√© (WS).`);
      }
      io.to('nurse-room').emit('notification', nurseNotificationPayload);
      console.log(`üì¨ WS Notif envoy√©e infirmi√®res (pour affichage en direct).`);

      // ... (SMS logic unchanged) ...
       if (phoneNumber) {
        const smsMessageToPatient = `Emergency Update: Dr. ${availableDoctor.username} (${availableDoctor.specialization || 'Doctor'}) has been assigned to your case. Please await further instructions or contact.`;
        try {
          console.log(`üì≤ Attempting SMS to PATIENT ${patient.firstName} ${patient.lastName} at ${phoneNumber} about assignment...`);
          const smsResultPatient = await sendSMS(smsMessageToPatient, phoneNumber);
          if (smsResultPatient.success) {
            console.log(`‚úÖ Assignment SMS sent successfully to PATIENT ${patient.firstName} ${patient.lastName}.`);
          } else {
            console.error(`‚ö†Ô∏è Failed assignment SMS to PATIENT ${patient.firstName} ${patient.lastName}: ${smsResultPatient.message || 'Unknown error'}`);
          }
        } catch (smsErrorPatient) {
          console.error(`‚ùå Critical error sending assignment SMS to PATIENT ${patient.firstName} ${patient.lastName}:`, smsErrorPatient);
        }
      } else {
        console.warn(`‚ö†Ô∏è Cannot send assignment SMS to patient ${patient.firstName} ${patient.lastName}: Phone number missing.`);
      }

    } else { // No available doctor
      console.warn(`‚ö†Ô∏è Aucun m√©decin disponible pour ${patient.firstName} ${patient.lastName}.`);
      const notificationPayloadNoDoctor = {
        type: 'unassigned_emergency_case', // Type plus sp√©cifique
        message: `Nouveau patient ${patient.firstName} ${patient.lastName} (Niveau: ${patient.emergencyLevel}) en attente. Aucun m√©decin disponible pour le moment.`,
        patientId: patient._id,
        patientName: `${patient.firstName} ${patient.lastName}`,
        symptoms: currentSymptoms,
        emergencyLevel: emergencyLevel,
        timestamp: new Date(),
        relatedEntityId: patient._id,
        relatedEntityType: 'EmergencyPatient'
      };
      // √âmettre aux administrateurs et/ou infirmi√®res et/ou docteurs qui pourraient devenir disponibles
      io.to('nurse-room').emit('notification', notificationPayloadNoDoctor);
      io.to('doctor-room').emit('notification', notificationPayloadNoDoctor); // Les m√©decins verront en attente
      io.to('administrator-room').emit('notification', notificationPayloadNoDoctor); // Si les admins suivent √ßa

      // Optionnel: Sauvegarder une notification "syst√®me" ou pour les admins
      // try {
      //   const adminUsers = await User.find({ role: 'Administrator' });
      //   for (const admin of adminUsers) {
      //     const adminNotification = new Notification({
      //       recipientId: admin._id,
      //       message: notificationPayloadNoDoctor.message,
      //       type: notificationPayloadNoDoctor.type,
      //       relatedEntityId: patient._id,
      //       relatedEntityType: 'EmergencyPatient'
      //     });
      //     await adminNotification.save();
      //   }
      //   console.log(`üíæ Notification "aucun m√©decin dispo" sauvegard√©e pour les admins.`);
      // } catch (dbError) {
      //   console.error("‚ùå Erreur sauvegarde notification admin en BDD:", dbError);
      // }
    }

    const responsePatient = await EmergencyPatient.findById(patient._id)
      .populate('assignedDoctor', 'username specialization email profileImage phoneNumber')
      .populate('medicalRecord', 'accessCode');

    res.status(201).json({
      patient: responsePatient,
      isNewPatient: isNew,
      patientCode: responsePatient.patientCode,
    });

  } catch (error) {
    // ... (error handling unchanged) ...
    console.error("‚ùå Erreur cr√©ation/mise √† jour patient d'urgence:", error);
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map(val => val.message);
      res.status(400).json({ message: "Erreur de validation", details: messages });
    } else {
      res.status(500).json({ message: 'Erreur Serveur Interne', error: error.message });
    }
  }
});


// PUT /:id/status
router.put('/:id/status', authenticateToken, async (req, res) => {
  const io = req.io;
  const userSockets = req.userSockets;
  try {
    const { id } = req.params; // ID du EmergencyPatient
    const { status } = req.body; // Nouveau statut
    // const userId = req.user.id; // ID de l'utilisateur effectuant l'action (infirmi√®re/m√©decin)

    // ... (validations inchang√©es) ...
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }
    const allowedStatuses = ['Demande Enregistr√©e', 'En Cours d\'Examen', 'M√©decin Assign√©', 'M√©decin En Route', 'Trait√©', 'Annul√©'];
    if (!allowedStatuses.includes(status)) {
      return res.status(400).json({ message: "Statut invalide" });
    }


    const updatedPatient = await EmergencyPatient.findByIdAndUpdate(
      id,
      { status },
      { new: true }
    ).populate('assignedDoctor', 'username specialization email profileImage');

    if (!updatedPatient) {
      return res.status(404).json({ message: "Patient non trouv√©" });
    }

    // --- D√âBUT MODIFICATION NOTIFICATION DE STATUT ---
    const statusUpdatePayloadForSocket = { // Ce qui est envoy√© via socket
      type: 'patient_status_update',
      message: `Statut du patient ${updatedPatient.firstName} ${updatedPatient.lastName} mis √† jour √†: ${status}.`,
      patientId: updatedPatient._id,
      patientName: `${updatedPatient.firstName} ${updatedPatient.lastName}`,
      newStatus: status,
      timestamp: new Date(),
      relatedEntityId: updatedPatient._id, // Lier √† l'EmergencyPatient
      relatedEntityType: 'EmergencyPatient'
    };

    // Sauvegarder la notification en BDD pour le m√©decin assign√© (s'il y en a un)
    if (updatedPatient.assignedDoctor?._id) {
        try {
            const newDbNotificationForDoctor = new Notification({
                recipientId: updatedPatient.assignedDoctor._id,
                message: statusUpdatePayloadForSocket.message,
                type: statusUpdatePayloadForSocket.type,
                relatedEntityId: statusUpdatePayloadForSocket.relatedEntityId,
                relatedEntityType: statusUpdatePayloadForSocket.relatedEntityType
            });
            await newDbNotificationForDoctor.save();
            console.log(`üíæ Notification de statut sauvegard√©e en BDD pour m√©decin ${updatedPatient.assignedDoctor._id}`);
            
            // √âmettre au m√©decin sp√©cifique
            const doctorSocketId = userSockets.get(updatedPatient.assignedDoctor._id.toString());
            if (doctorSocketId) {
                // On peut envoyer le document complet de la BDD ou le payload simple
                io.to(doctorSocketId).emit('notification', newDbNotificationForDoctor.toObject());
                console.log(`üì¨ Notification de statut (BDD) envoy√©e au m√©decin ${updatedPatient.assignedDoctor.username}`);
            } else {
                 console.log(`‚ö†Ô∏è M√©decin ${updatedPatient.assignedDoctor.username} non connect√© (WS) pour notif statut.`);
            }
        } catch (dbError) {
            console.error("‚ùå Erreur sauvegarde notification statut m√©decin en BDD:", dbError);
        }
    }

    // √âmettre √† la room des infirmi√®res (pour affichage en direct, pas de sauvegarde BDD par d√©faut pour la room)
    io.to('nurse-room').emit('notification', statusUpdatePayloadForSocket);
    console.log(`üì¨ Notification de statut (socket) envoy√©e √† toutes les infirmi√®res connect√©es.`);
    // --- FIN MODIFICATION ---

    // ... (Medical Record Creation Logic et SMS Logic inchang√©s) ...
     if (['M√©decin En Route', 'Trait√©'].includes(status)) {
      let medicalRecord = await MedicalRecord.findOne({ patientId: id });
      if (!medicalRecord) {
        console.log(`Cr√©ation du dossier m√©dical pour le patient ${id}...`);
        const medicalRecordData = { /* ... */ };
        // ... cr√©ation du dossier ...
      }
    }
    const patientPhoneNumber = updatedPatient.phoneNumber;
    if (patientPhoneNumber) {
      const smsMessage = `Emergency Update: Your request status has been updated to: ${status}.`;
      // ... envoi SMS ...
    }

    res.status(200).json(updatedPatient);
  } catch (error) {
    // ... (error handling inchang√©) ...
    console.error("‚ùå Erreur mise √† jour statut:", error);
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map(val => `${val.path}: ${val.message}`);
      console.error("Validation Error during MedicalRecord save:", error.errors);
      return res.status(400).json({ message: "Erreur de validation lors de la cr√©ation du dossier m√©dical", details: messages });
    }
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});


// ... (autres routes GET, DELETE, STATS inchang√©es) ...
// GET /:id/medical-access-code
router.get('/:id/medical-access-code', async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID patient invalide" });
  }
  try {
    const patient = await EmergencyPatient.findById(id);
    if (!patient) return res.status(404).json({ message: "Patient non trouv√©" });
    const medicalRecord = await MedicalRecord.findOne({ patientId: id })
      .select('accessCode')
      .lean();
    if (!medicalRecord) {
      return res.status(404).json({
        message: "Dossier m√©dical non trouv√©",
        shouldDisplay: false,
      });
    }
    res.status(200).json({
      accessCode: medicalRecord.accessCode,
      shouldDisplay: true,
    });
  } catch (error) {
    console.error("Erreur r√©cup√©ration code acc√®s:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// GET /
router.get('/', async (req, res) => {
  try {
    const emergencyPatients = await EmergencyPatient.find()
      .populate('assignedDoctor', 'username specialization')
      .sort({ createdAt: -1 });
    res.status(200).json(emergencyPatients);
  } catch (error) {
    console.error("Erreur r√©cup√©ration patients:", error);
    res.status(500).json({ message: "Erreur serveur" });
  }
});

// GET /:id/details
router.get('/:id/details', async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID invalide" });
  }
  try {
    const patient = await EmergencyPatient.findById(id)
      .populate('assignedDoctor', 'username specialization email profileImage');
    if (!patient) return res.status(404).json({ message: "Patient non trouv√©" });
    res.status(200).json(patient);
  } catch (error) {
    console.error("Erreur d√©tails patient:", error);
    res.status(500).json({ message: "Erreur serveur" });
  }
});
// GET /:id/medical-record
router.get('/:id/medical-record', authenticateToken, async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID patient invalide" });
  }
  try {
    const patient = await EmergencyPatient.findById(id);
    if (!patient) return res.status(404).json({ message: "Patient non trouv√©" });

    const medicalRecord = await MedicalRecord.findOne({ patientId: id })
      .populate('patientId', 'firstName lastName dateOfBirth gender phoneNumber email address')
      .lean();

    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√© pour ce patient" });
    }

    if (medicalRecord.creator) {
      try {
        medicalRecord.creator = await User.findById(medicalRecord.creator)
          .select('username role specialization')
          .lean();
      } catch (userError) {
        console.warn(`Could not populate creator ${medicalRecord.creator}: ${userError.message}`);
        medicalRecord.creator = { _id: medicalRecord.creator, username: 'Utilisateur inconnu' };
      }
    }

    const patientFiles = await PatientFile.find({ medicalRecord: medicalRecord._id })
      .populate('creator', 'username role')
      .sort({ createdAt: -1 })
      .lean();

    const result = { ...medicalRecord, patientFiles };

    res.status(200).json(result);
  } catch (error) {
    console.error("Erreur r√©cup√©ration dossier m√©dical:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// DELETE /:id
router.delete('/:id', async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID invalide" });
  }
  try {
    const deletedPatient = await EmergencyPatient.findByIdAndDelete(id);
    if (!deletedPatient) return res.status(404).json({ message: "Patient non trouv√©" });

    if (deletedPatient.assignedDoctor) {
      try {
        await User.findByIdAndUpdate(deletedPatient.assignedDoctor, { isAvailable: true });
        console.log(`‚úÖ M√©decin ${deletedPatient.assignedDoctor} rendu disponible apr√®s suppression du cas ${id}.`);
      } catch (docError) {
        console.error(`‚ö†Ô∏è Erreur lors de la remise √† dispo du m√©decin ${deletedPatient.assignedDoctor}: ${docError.message}`);
      }
    }
    res.status(200).json({ message: "Patient d'urgence supprim√© avec succ√®s", deletedId: id });
  } catch (error) {
    console.error("Erreur suppression patient:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// GET /by-doctor/:doctorId
router.get('/by-doctor/:doctorId', authenticateToken, async (req, res) => {
  const { doctorId } = req.params;
  if (!mongoose.Types.ObjectId.isValid(doctorId)) {
    return res.status(400).json({ message: "ID m√©decin invalide" });
  }
  try {
    const patients = await EmergencyPatient.find({ assignedDoctor: doctorId })
      .populate('assignedDoctor', 'username specialization email profileImage')
      .populate('medicalRecord', '_id')
      .sort({ createdAt: -1 });
    res.status(200).json(patients);
  } catch (error) {
    console.error("Erreur r√©cup√©ration patients par m√©decin:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// GET /stats/total
router.get('/stats/total', async (req, res) => {
  try {
    const totalPatients = await EmergencyPatient.countDocuments();
    res.status(200).json({ total: totalPatients });
  } catch (error) {
    console.error("Erreur r√©cup√©ration nombre total de patients:", error);
    res.status(500).json({ message: "Erreur serveur" });
  }
});

// GET /stats/today
router.get('/stats/today', async (req, res) => {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const patientsToday = await EmergencyPatient.countDocuments({
      createdAt: { $gte: today, $lt: tomorrow },
    });
    res.status(200).json({ today: patientsToday });
  } catch (error) {
    console.error("Erreur r√©cup√©ration nombre de patients aujourd'hui:", error);
    res.status(500).json({ message: "Erreur serveur" });
  }
});

// GET /:id/estimated-wait-time
router.get('/:id/estimated-wait-time', async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID patient invalide" });
  }
  try {
    const estimatedTime = await getEstimatedWaitTime(id);
    res.json({ estimatedWaitTime: estimatedTime });
  } catch (error) {
    console.error(`Erreur API get wait time pour ${id}:`, error);
    if (error.message === "Patient non trouv√©.") {
      return res.status(404).json({ message: error.message });
    }
    res.status(500).json({ message: "Erreur lors du calcul du temps d'attente estim√©." });
  }
});

// GET /stats/levels
router.get('/stats/levels', async (req, res) => {
  try {
    const stats = await EmergencyPatient.getEmergencyLevelStats();
    res.json(stats);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// GET /stats/trends
router.get('/stats/trends', async (req, res) => {
  try {
    const { period = 'day' } = req.query;
    const trends = await EmergencyPatient.getEmergencyTrends(period);
    res.json(trends);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
export default router;
</file>

<file path="routes/feedback.js">
import express from "express";
import Feedback from "../models/FeedBack.js";
import { authenticateToken, authorize } from "../middleware/authMiddleware.js";
import { User } from "../models/User.js";
const router = express.Router();

// Get all feedback with user details (accessible √† tous)
router.get("/", async (req, res) => {
  try {
    const feedbacks = await Feedback.find()
      .populate('user', 'username profileImage role') // Ajout du r√¥le pour l'affichage
      .sort({ createdAt: -1 });
    
    res.json(feedbacks);
  } catch (error) {
    console.error("Error fetching feedback:", error);
    res.status(500).json({ message: "Server error" });
  }
});

// Submit new feedback (prot√©g√© par authentification)
router.post("/", authenticateToken, async (req, res) => {
  try {
    const { feedback, rating } = req.body;
    const userId = req.user.id;

    // V√©rifier si l'utilisateur a d√©j√† soumis un feedback
    const existingFeedback = await Feedback.findOne({ user: userId });
    if (existingFeedback) {
      return res.status(400).json({ 
        message: "Vous avez d√©j√† soumis un feedback",
        existingFeedback
      });
    }

    const newFeedback = new Feedback({
      user: userId,
      feedback,
      rating,
    });

    const savedFeedback = await newFeedback.save();

    // Populate user details before sending response
    const populatedFeedback = await Feedback.populate(savedFeedback, {
      path: 'user',
      select: 'username profileImage role'
    });

    // Emit new feedback to all connected clients via Socket.IO
    if (req.io) {
      req.io.emit("newFeedback", populatedFeedback);
    }

    res.status(201).json(populatedFeedback);
  } catch (error) {
    console.error("Error submitting feedback:", error);
    res.status(500).json({ message: "Server error" });
  }
});

// Get feedback for current user (prot√©g√© par authentification)
router.get("/my-feedback", authenticateToken, async (req, res) => {
  try {
    const feedback = await Feedback.findOne({ user: req.user.id })
      .populate('user', 'username profileImage');
      
    res.json(feedback || { message: "Vous n'avez pas encore soumis de feedback" });
  } catch (error) {
    console.error("Error fetching user feedback:", error);
    res.status(500).json({ message: "Server error" });
  }
});

// Get average rating (accessible √† tous)
router.get("/average", async (req, res) => {
  try {
    const result = await Feedback.aggregate([
      {
        $group: {
          _id: null,
          averageRating: { $avg: "$rating" },
          count: { $sum: 1 },
        },
      },
    ]);

    if (result.length > 0) {
      res.json({
        averageRating: Math.round(result[0].averageRating * 10) / 10,
        count: result[0].count,
      });
    } else {
      res.json({ averageRating: 0, count: 0 });
    }
  } catch (error) {
    console.error("Error calculating average rating:", error);
    res.status(500).json({ message: "Server error" });
  }
});

// Route admin pour supprimer un feedback (optionnel)
router.delete("/:id", authenticateToken, authorize(['Administrator']), async (req, res) => {
  try {
    const deletedFeedback = await Feedback.findByIdAndDelete(req.params.id);
    
    if (!deletedFeedback) {
      return res.status(404).json({ message: "Feedback non trouv√©" });
    }

    if (req.io) {
      req.io.emit("feedbackDeleted", { id: req.params.id });
    }

    res.json({ message: "Feedback supprim√© avec succ√®s" });
  } catch (error) {
    console.error("Error deleting feedback:", error);
    res.status(500).json({ message: "Server error" });
  }
});

export default router;
</file>

<file path="routes/medicalRecords.js">
import express from "express";
import mongoose from "mongoose";
import { authenticateToken } from "../middleware/authMiddleware.js";
import MedicalRecord from "../models/MedicalRecord.js";
import EmergencyPatient from "../models/EmergencyPatient.js";
import PatientFile from "../models/PatientFile.js";
import { User } from "../models/User.js"; // <-- Ajoutez cette ligne

const router = express.Router();

// Cr√©er un MedicalRecord
router.post("/", authenticateToken, async (req, res) => {
  try {
    const { patientId } = req.body;

    if (!mongoose.Types.ObjectId.isValid(patientId)) {
      return res.status(400).json({ message: "ID patient invalide" });
    }

    const patient = await EmergencyPatient.findById(patientId);
    if (!patient) {
      return res.status(404).json({ message: "Patient non trouv√©" });
    }

    // V√©rifier si un MedicalRecord existe d√©j√†
    const existingRecord = await MedicalRecord.findOne({ patientId });
    if (existingRecord) {
      return res.status(400).json({ message: "Un dossier m√©dical existe d√©j√† pour ce patient" });
    }

    const medicalRecord = new MedicalRecord({
      patientId,
      creator: req.user._id,
      emergencyContact: patient.emergencyContact ? { phone: patient.emergencyContact } : undefined,
      knownAllergies: patient.allergies ? patient.allergies.split(',') : [],
      bloodType: patient.bloodType,
    });

    await medicalRecord.save();

    // Mettre √† jour le patient avec la r√©f√©rence au MedicalRecord
    patient.medicalRecord = medicalRecord._id;
    await patient.save();

    res.status(201).json(medicalRecord);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// R√©cup√©rer tous les MedicalRecords
router.get("/", authenticateToken, async (req, res) => {
  try {
    const records = await MedicalRecord.find()
      .populate('patientId', 'firstName lastName dateOfBirth')
      .populate('creator', 'username specialization');
    res.status(200).json(records);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

router.get("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    // 1. R√©cup√©rer le dossier m√©dical de base
    const record = await MedicalRecord.findById(id)
      .populate('patientId', 'firstName lastName dateOfBirth gender phoneNumber')
      .populate('creator', 'username role specialization')
      .lean();

    if (!record) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    // 2. R√©cup√©rer les fichiers patients s√©par√©ment avec les cr√©ateurs
    const patientFiles = await PatientFile.aggregate([
      { $match: { medicalRecord: new mongoose.Types.ObjectId(id) } },
      { $sort: { createdAt: -1 } },
      {
        $lookup: {
          from: "users",
          localField: "creator",
          foreignField: "_id",
          as: "creatorInfo"
        }
      },
      { $unwind: { path: "$creatorInfo", preserveNullAndEmptyArrays: true } },
      {
        $project: {
          type: 1,
          notes: 1,
          details: 1,
          createdAt: 1,
          updatedAt: 1,
          creator: {
            username: "$creatorInfo.username",
            role: "$creatorInfo.role"
          }
        }
      }
    ]);

    // 3. Combiner les r√©sultats
    const result = {
      ...record,
      patientFiles
    };

    res.status(200).json(result);

  } catch (error) {
    console.error("Error fetching medical record:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});
// Mettre √† jour un MedicalRecord
router.put("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const updatedRecord = await MedicalRecord.findByIdAndUpdate(id, updateData, {
      new: true,
      runValidators: true
    });

    if (!updatedRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    res.status(200).json(updatedRecord);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Supprimer un MedicalRecord (avec ses PatientFiles associ√©s)
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    // Supprimer d'abord les PatientFiles associ√©s
    await PatientFile.deleteMany({ medicalRecord: id });

    // Puis supprimer le MedicalRecord
    const deletedRecord = await MedicalRecord.findByIdAndDelete(id);

    if (!deletedRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    // Mettre √† jour le patient en retirant la r√©f√©rence
    await EmergencyPatient.updateOne(
      { medicalRecord: id },
      { $unset: { medicalRecord: "" } }
    );

    res.status(200).json({ message: "Dossier m√©dical et fichiers associ√©s supprim√©s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
/**
 * @route POST /api/medical-records/:recordId/files
 * @description Ajoute un fichier patient √† un dossier m√©dical
 * @body {type, notes, details}
 * @access Prot√©g√© (authentification requise)
 */
router.post('/:recordId/files', authenticateToken, async (req, res) => {
  const { recordId } = req.params;
  const { type, notes, details } = req.body;

  try {
    // V√©rifier que le dossier m√©dical existe
    const medicalRecord = await MedicalRecord.findById(recordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    // Cr√©er le nouveau fichier patient
    const newFile = new PatientFile({
      medicalRecord: recordId,
      creator: req.user._id, // L'utilisateur authentifi√©
      type,
      notes,
      details,
      dateRecorded: new Date()
    });

    // Sauvegarder le fichier
    await newFile.save();

    // Mettre √† jour la date de derni√®re modification du dossier m√©dical
    medicalRecord.lastUpdated = new Date();
    await medicalRecord.save();

    res.status(201).json(newFile);

  } catch (error) {
    console.error("Erreur cr√©ation fichier patient:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
});
// Nouvelle route pour acc√©der au dossier m√©dical par code
router.get('/by-access-code/:accessCode', async (req, res) => {
  try {
      const { accessCode } = req.params;
      
      // 1. Trouver le dossier m√©dical de base
      const medicalRecord = await MedicalRecord.findOne({ accessCode })
          .populate('patientId', 'firstName lastName dateOfBirth gender phoneNumber email')
          .populate('creator', 'username role specialization')
          .lean();

      if (!medicalRecord) {
          return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
      }

      // 2. R√©cup√©rer les fichiers patients s√©par√©ment
      const patientFiles = await PatientFile.find({ 
          medicalRecord: medicalRecord._id 
      })
      .sort({ createdAt: -1 })
      .lean();

      // 3. R√©cup√©rer les informations des cr√©ateurs des fichiers
      const creatorIds = patientFiles.map(file => file.creator).filter(Boolean);
      const creators = creatorIds.length > 0 ? await User.find({ 
          _id: { $in: creatorIds } 
      }).select('username role').lean() : [];

      // 4. Cr√©er un mapping des cr√©ateurs
      const creatorMap = creators.reduce((map, creator) => {
          map[creator._id.toString()] = creator;
          return map;
      }, {});

      // 5. Combiner les r√©sultats
      const result = {
          ...medicalRecord,
          patientFiles: patientFiles.map(file => ({
              ...file,
              creator: file.creator ? creatorMap[file.creator.toString()] : null
          }))
      };

      res.status(200).json(result);
  } catch (error) {
      console.error("Erreur r√©cup√©ration dossier m√©dical:", error);
      res.status(500).json({ 
          message: "Erreur serveur", 
          error: error.message 
      });
  }
});
router.get('/:recordId/files', authenticateToken, async (req, res) => {
  const { recordId } = req.params;

  try {
    // V√©rifier que le dossier m√©dical existe
    const medicalRecord = await MedicalRecord.findById(recordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    // R√©cup√©rer les fichiers sans populate
    const patientFiles = await PatientFile.find({ medicalRecord: recordId })
      .sort({ dateRecorded: -1 })
      .lean(); // Convertit en objets JavaScript simples

    // R√©cup√©rer tous les cr√©ateurs en une seule requ√™te
    const creatorIds = patientFiles.map(file => file.creator).filter(id => id);
    const creators = await User.find({ _id: { $in: creatorIds } })
      .select('username role')
      .lean();

    // Cr√©er un map pour un acc√®s rapide
    const creatorMap = creators.reduce((map, creator) => {
      map[creator._id] = creator;
      return map;
    }, {});

    // Combiner les fichiers avec leurs cr√©ateurs
    const filesWithCreators = patientFiles.map(file => ({
      ...file,
      creator: file.creator ? creatorMap[file.creator.toString()] : null
    }));

    res.status(200).json(filesWithCreators);

  } catch (error) {
    console.error("Erreur r√©cup√©ration fichiers patients:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
});
// Dans medicalRecordRoutes.js
import { generateMedicalRecordPDF } from '../utils/pdfGenerator.js'; // Ajoutez cette ligne en haut

router.get('/by-access-code/:accessCode/download-pdf', async (req, res) => {
  try {
    const { accessCode } = req.params;
    
    const medicalRecord = await MedicalRecord.findOne({ accessCode })
      .populate('patientId')
      .lean();

    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    const patientFiles = await PatientFile.find({ 
      medicalRecord: medicalRecord._id 
    }).lean();

    const pdfBuffer = await generateMedicalRecordPDF(medicalRecord, patientFiles);

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename=dossier_medical_${accessCode}.pdf`);
    res.send(pdfBuffer);

  } catch (error) {
    console.error("Erreur g√©n√©ration PDF:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});


export default router;
</file>

<file path="routes/notifications.js">
// routes/notifications.js
import express from 'express';
import { authenticateToken } from '../middleware/authMiddleware.js';
import Notification from '../models/Notification.js';
import mongoose from 'mongoose';

const router = express.Router();

// GET /api/notifications - R√©cup√©rer les notifications pour l'utilisateur connect√©
router.get('/', authenticateToken, async (req, res) => {
    try {
        const notifications = await Notification.find({ recipientId: req.user.id })
            .sort({ createdAt: -1 }) // Les plus r√©centes en premier
            .limit(50); // Limiter √† 50 pour la performance
        const unreadCount = await Notification.countDocuments({ recipientId: req.user.id, isRead: false });

        res.json({ notifications, unreadCount });
    } catch (error) {
        console.error("Error fetching notifications:", error);
        res.status(500).json({ message: "Erreur serveur lors de la r√©cup√©ration des notifications." });
    }
});

// PATCH /api/notifications/:id/read - Marquer une notification comme lue
router.patch('/:id/read', authenticateToken, async (req, res) => {
    try {
        const notification = await Notification.findOneAndUpdate(
            { _id: req.params.id, recipientId: req.user.id }, // S'assurer que la notif appartient √† l'utilisateur
            { isRead: true },
            { new: true }
        );
        if (!notification) {
            return res.status(404).json({ message: "Notification non trouv√©e ou acc√®s non autoris√©." });
        }
        res.json(notification);
    } catch (error) {
        console.error("Error marking notification as read:", error);
        res.status(500).json({ message: "Erreur serveur." });
    }
});

// PATCH /api/notifications/read-all - Marquer toutes les notifications comme lues
router.patch('/read-all', authenticateToken, async (req, res) => {
    try {
        await Notification.updateMany(
            { recipientId: req.user.id, isRead: false },
            { isRead: true }
        );
        res.json({ message: "Toutes les notifications ont √©t√© marqu√©es comme lues." });
    } catch (error) {
        console.error("Error marking all notifications as read:", error);
        res.status(500).json({ message: "Erreur serveur." });
    }
});

// DELETE /api/notifications/:id - Supprimer une notification (optionnel)
router.delete('/:id', authenticateToken, async (req, res) => {
    try {
        const result = await Notification.findOneAndDelete({ _id: req.params.id, recipientId: req.user.id });
        if (!result) {
            return res.status(404).json({ message: "Notification non trouv√©e ou acc√®s non autoris√©." });
        }
        res.json({ message: "Notification supprim√©e." });
    } catch (error) {
        console.error("Error deleting notification:", error);
        res.status(500).json({ message: "Erreur serveur." });
    }
});

export default router;
</file>

<file path="routes/ocr.js">
import express from "express";
import { uploadImage } from "../middleware/fileUpload.js";
import { processImage } from "../services/ocrService.js";
import OcrResult from "../models/OcrResult.js";
import PatientFile from "../models/PatientFile.js";
import { authenticateToken } from "../middleware/authMiddleware.js";
import mongoose from "mongoose";

const router = express.Router();

router.post(
  "/process-image",
  authenticateToken,
  uploadImage.single("medicalImage"),
  async (req, res) => {
    try {
      const { medicalRecordId } = req.body;

      // Validation
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          error: "Aucune image t√©l√©charg√©e" 
        });
      }

      if (!medicalRecordId) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de dossier m√©dical requis" 
        });
      }

      if (!mongoose.Types.ObjectId.isValid(medicalRecordId)) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de dossier m√©dical invalide" 
        });
      }

      // Traitement OCR
      const result = await processImage(req.file.path, medicalRecordId);

      // Transaction MongoDB
      const session = await mongoose.startSession();
      let savedOcr, savedFile;

      try {
        await session.withTransaction(async () => {
          // Sauvegarde r√©sultat OCR
          const ocrRecord = new OcrResult({
            medicalRecord: medicalRecordId,
            originalFilename: req.file.originalname,
            textResult: result.data.text,
            extractedData: result.data.extractedData
          });

          savedOcr = await ocrRecord.save({ session });

          // Sauvegarde fichier patient
          const patientFile = new PatientFile({
            medicalRecord: medicalRecordId,
            type: "Diagnostic",
            isOCRProcessed: true,
            ocrResults: savedOcr._id,
            details: {
              diagnosis: result.data.extractedData.diagnosis,
              diagnosticTests: result.data.extractedData.tests,
              patientInfo: {
                firstName: result.data.extractedData.patientName?.split(' ')[0] || 'Inconnu',
                lastName: result.data.extractedData.patientName?.split(' ').slice(1).join(' ') || 'Inconnu'
              }
            }
          });

          savedFile = await patientFile.save({ session });
        });
      } finally {
        await session.endSession();
      }

      // R√©ponse r√©ussie
      res.json({
        success: true,
        data: {
          text: result.data.text,
          extractedData: result.data.extractedData,
          databaseIds: {
            ocrId: savedOcr._id,
            fileId: savedFile._id
          }
        }
      });

    } catch (error) {
      console.error("Erreur OCR:", error);
      const errorMessage = error.message.includes("ENOENT") 
        ? "Fichier introuvable" 
        : error.message;
      
      res.status(500).json({
        success: false,
        error: `√âchec du traitement OCR: ${errorMessage}`
      });
    }
  }
);

export default router;
</file>

<file path="routes/patient.js">
import express from 'express';
import PatientFile from '../models/PatientFile.js';
import MedicalRecord from '../models/MedicalRecord.js';
import { classifyPatientNeeds } from '../services/classifierService.js'; // still using this name

const router = express.Router();

// POST /api/patients/:patientId/recommend
router.post('/:patientId/recommend', async (req, res) => {
  try {
    const { patientId } = req.params;
    const { noteOverride } = req.body;

    // 1. Find the MedicalRecord
    const medRecord = await MedicalRecord.findOne({ patientId });
    if (!medRecord) {
      return res.status(404).send({ error: 'Medical record not found for this patient' });
    }

    // 2. Fetch latest unarchived PatientFile
    const patientFile = await PatientFile.findOne({
      medicalRecord: medRecord._id,
      isArchived: false,
    }).sort({ dateRecorded: -1 });

    if (!patientFile) {
      return res.status(404).send({ error: 'Patient file not found for this record' });
    }

    // 3. Build prompt
    const prompt = noteOverride || 
      `Chief complaint: ${patientFile.details?.chiefComplaint || 'N/A'}. ` +
      `Vitals: ${JSON.stringify(patientFile.details?.vitalSigns || {})}. ` +
      `Notes: ${patientFile.notes || 'None'}.`;

    // 4. Generate recommendations
    const recommendations = await classifyPatientNeeds(prompt); // returns top 3 suggestions
    console.log('Recommendations:', recommendations);
    return res.send({ recommendations });

  } catch (err) {
    console.error('Error in recommend route:', err);
    return res.status(500).send({ error: 'Server error' });
  }
});

export default router;
</file>

<file path="routes/patientFile.js">
import express from "express";
import mongoose from "mongoose";
import { authenticateToken } from "../middleware/authMiddleware.js";
import PatientFile from "../models/PatientFile.js";
import MedicalRecord from "../models/MedicalRecord.js";

const router = express.Router();

// Cr√©er un PatientFile (associ√© √† un MedicalRecord)
router.post("/", authenticateToken, async (req, res) => {
  try {
    const { medicalRecordId, type, details, notes } = req.body;

    if (!mongoose.Types.ObjectId.isValid(medicalRecordId)) {
      return res.status(400).json({ message: "ID dossier m√©dical invalide" });
    }

    // V√©rifier que le MedicalRecord existe
    const medicalRecord = await MedicalRecord.findById(medicalRecordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    const patientFile = new PatientFile({
      medicalRecord: medicalRecordId,
      creator: req.user._id,
      type,
      details,
      notes
    });

    await patientFile.save();

    res.status(201).json(patientFile);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// R√©cup√©rer tous les PatientFiles d'un MedicalRecord
router.get("/medical-record/:medicalRecordId", authenticateToken, async (req, res) => {
  try {
    const { medicalRecordId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(medicalRecordId)) {
      return res.status(400).json({ message: "ID dossier m√©dical invalide" });
    }

    const files = await PatientFile.find({ medicalRecord: medicalRecordId })
      .sort({ dateRecorded: -1 })
      .populate('creator', 'username');

    res.status(200).json(files);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// R√©cup√©rer un PatientFile sp√©cifique
router.get("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const file = await PatientFile.findById(id).populate('creator', 'username');

    if (!file) {
      return res.status(404).json({ message: "Fichier patient non trouv√©" });
    }

    res.status(200).json(file);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Mettre √† jour un PatientFile
router.put("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const updatedFile = await PatientFile.findByIdAndUpdate(id, updateData, {
      new: true,
      runValidators: true
    });

    if (!updatedFile) {
      return res.status(404).json({ message: "Fichier patient non trouv√©" });
    }

    res.status(200).json(updatedFile);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Supprimer un PatientFile
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const deletedFile = await PatientFile.findByIdAndDelete(id);

    if (!deletedFile) {
      return res.status(404).json({ message: "Fichier patient non trouv√©" });
    }

    res.status(200).json({ message: "Fichier patient supprim√©" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

export default router;
</file>

<file path="routes/profile.js">
// routes/profile.js
import express from 'express';
import { User } from '../models/User.js'; // User model already includes donationCount and unlockedBadges
import { authenticateToken } from '../middleware/authMiddleware.js';
import cors from "cors";
import dotenv from "dotenv";

const router = express.Router();
router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();

// GET current user's profile
router.get('/profile', authenticateToken, async (req, res) => {
  console.log("üì© Requ√™te GET /api/profile re√ßue pour l'utilisateur ID:", req.user.id);
  try {
    const user = await User.findById(req.user.id)
                           .select('-password -resetPasswordToken -resetPasswordExpires -otp -otpExpires') // Exclude sensitive fields
                           .lean(); // Use .lean() for plain JS object, good for response
    
    if (!user) {
      console.log(`Utilisateur non trouv√© pour ID: ${req.user.id}`);
      return res.status(404).json({ message: "Profil non trouv√©" });
    }

    // Construct the base personal profile data
    let profileData = {
      personal: {
        _id: user._id, // Good to include user's own ID
        username: user.username,
        email: user.email,
        phoneNumber: user.phoneNumber,
        role: user.role,
        profileImage: user.profileImage, // This path should be relative to your uploads folder on the frontend or a full URL from backend
        donationCount: user.donationCount || 0,         // <-- ADDED
        unlockedBadges: user.unlockedBadges || [],      // <-- ADDED
        // Add other base UserSchema fields if needed in 'personal'
      },
      // Initialize other potential sections to prevent frontend errors if they don't exist for a role
      contact: {}, 
      emergencyContacts: {},
      settings: {},
      medical: {},
      professional: {},
      certifications: {},
      appointments: {}
    };

    // Add role-specific data. Mongoose discriminators mean role-specific fields are directly on the 'user' object.
    switch (user.role) {
      case 'Patient':
        // For 'Patient', role-specific data is often in a 'medical' section in your frontend
        // The 'User' model for 'Patient' discriminator already has these fields.
        profileData.medical = {
          name: user.name, // Patient's full name if different from username
          dateOfBirth: user.dateOfBirth,
          gender: user.gender,
          address: user.address,
          emergencyContact: user.emergencyContact, // This might be a string or an object {name, phone, relationship}
          bloodType: user.bloodType,
          allergies: user.allergies || []
        };
        // Populate other patient-specific sections if your frontend expects them
        // e.g., profileData.appointments = await fetchAppointments(user._id);
        break;

      case 'Doctor':
        profileData.professional = {
          badgeNumber: user.badgeNumber,
          specialization: user.specialization,
          licenseNumber: user.licenseNumber,
          isAvailable: typeof user.isAvailable === 'boolean' ? user.isAvailable : true // Default to true if not set
        };
        // e.g., profileData.certifications = await fetchCertifications(user._id);
        break;

      case 'Nurse':
        profileData.professional = {
          badgeNumber: user.badgeNumber,
          shift: user.shift,
          licenseNumber: user.licenseNumber
        };
        break;

      case 'Administrator':
        profileData.professional = {
          badgeNumber: user.badgeNumber
        };
        break;
    }

    console.log("Donn√©es de profil envoy√©es:", JSON.stringify(profileData, null, 2));
    res.status(200).json(profileData);
  } catch (error) {
    console.error("Erreur serveur lors de la r√©cup√©ration du profil:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// PUT update current user's profile
router.put('/profile', authenticateToken, async (req, res) => {
  console.log("üì© Requ√™te PUT /api/profile re√ßue pour l'utilisateur ID:", req.user.id);
  console.log("Donn√©es re√ßues pour la mise √† jour:", JSON.stringify(req.body, null, 2));

  try {
    // Fetch user document (not .lean(), as we need to .save() it)
    const user = await User.findById(req.user.id);

    if (!user) {
      return res.status(404).json({ message: "Profil non trouv√©" });
    }

    const { personal, medical, professional, contact, emergencyContacts, settings, certifications, appointments } = req.body;

    // Update common personal fields from 'personal' object
    if (personal) {
      if (typeof personal.username !== 'undefined') user.username = personal.username;
      // Email change requires careful consideration (verification, uniqueness)
      // For now, let's assume email is not changed here or handled separately
      // if (typeof personal.email !== 'undefined' && personal.email !== user.email) {
      //   // Add logic for email change verification if needed
      //   user.email = personal.email;
      // }
      if (typeof personal.phoneNumber !== 'undefined') user.phoneNumber = personal.phoneNumber;
      if (typeof personal.profileImage !== 'undefined') user.profileImage = personal.profileImage; // Path to new image
      // donationCount and unlockedBadges are managed by the system, not directly by user profile edit.
    }

    // Update role-specific fields
    switch (user.role) {
      case 'Patient':
        if (medical) {
          if (typeof medical.name !== 'undefined') user.name = medical.name;
          if (typeof medical.dateOfBirth !== 'undefined') user.dateOfBirth = medical.dateOfBirth;
          if (typeof medical.gender !== 'undefined') user.gender = medical.gender;
          if (typeof medical.address !== 'undefined') user.address = medical.address;
          if (typeof medical.emergencyContact !== 'undefined') user.emergencyContact = medical.emergencyContact;
          if (typeof medical.bloodType !== 'undefined') user.bloodType = medical.bloodType;
          if (typeof medical.allergies !== 'undefined') user.allergies = medical.allergies;
        }
        // Update other patient-specific sections if they are part of the User model or handled here
        // For example, if `contact` and `emergencyContacts` are direct fields or simple objects on User model:
        if (contact) {
          // Example: user.contactInfo = { ...user.contactInfo, ...contact };
          // Or if they are direct fields: user.street = contact.street || user.street;
        }
        if (emergencyContacts) {
           // Example: user.emergencyContactDetails = { ...user.emergencyContactDetails, ...emergencyContacts};
        }
        break;
      case 'Doctor':
        if (professional) {
          if (typeof professional.badgeNumber !== 'undefined') user.badgeNumber = professional.badgeNumber;
          if (typeof professional.specialization !== 'undefined') user.specialization = professional.specialization;
          if (typeof professional.licenseNumber !== 'undefined') user.licenseNumber = professional.licenseNumber;
          if (typeof professional.isAvailable !== 'undefined') user.isAvailable = professional.isAvailable;
        }
        if (certifications) { /* update certifications */ }
        break;
      case 'Nurse':
        if (professional) {
          if (typeof professional.badgeNumber !== 'undefined') user.badgeNumber = professional.badgeNumber;
          if (typeof professional.shift !== 'undefined') user.shift = professional.shift;
          if (typeof professional.licenseNumber !== 'undefined') user.licenseNumber = professional.licenseNumber;
        }
        break;
      case 'Administrator':
        if (professional) {
          if (typeof professional.badgeNumber !== 'undefined') user.badgeNumber = professional.badgeNumber;
        }
        break;
    }

    // Update general settings if provided
    if (settings) {
        // Example: if (typeof settings.language !== 'undefined') user.settings.language = settings.language;
        // This assumes 'user.settings' is an object. Adjust based on your User schema.
    }


    const updatedUser = await user.save();
    console.log("Profil mis √† jour avec succ√®s, utilisateur:", updatedUser.username);
    
    // To ensure the response has the exact same structure as GET /profile,
    // we re-fetch and re-format. This is slightly less efficient but guarantees consistency.
    // Alternatively, manually construct the response object like in the GET route.
    // For now, let's redirect to the GET route to re-fetch.
    // However, redirecting a PUT request to GET is not standard. Better to return the updated data.

    // Re-fetch the user to get the lean object with populated fields if necessary,
    // and structure it exactly like the GET /profile response.
    const userForResponse = await User.findById(updatedUser._id)
                                   .select('-password -resetPasswordToken -resetPasswordExpires -otp -otpExpires')
                                   .lean();

    let responseProfileData = {
      personal: {
        _id: userForResponse._id,
        username: userForResponse.username,
        email: userForResponse.email,
        phoneNumber: userForResponse.phoneNumber,
        role: userForResponse.role,
        profileImage: userForResponse.profileImage,
        donationCount: userForResponse.donationCount || 0,
        unlockedBadges: userForResponse.unlockedBadges || [],
      },
      contact: {}, medical: {}, professional: {}, emergencyContacts: {}, settings: {}, certifications: {}, appointments: {} // Initialize all
    };
     switch (userForResponse.role) {
      case 'Patient':
        responseProfileData.medical = {
          name: userForResponse.name, dateOfBirth: userForResponse.dateOfBirth, gender: userForResponse.gender,
          address: userForResponse.address, emergencyContact: userForResponse.emergencyContact,
          bloodType: userForResponse.bloodType, allergies: userForResponse.allergies || []
        };
        // Populate contact, emergencyContacts, settings, appointments if they are part of patient data structure
        break;
      case 'Doctor':
        responseProfileData.professional = {
          badgeNumber: userForResponse.badgeNumber, specialization: userForResponse.specialization,
          licenseNumber: userForResponse.licenseNumber, isAvailable: userForResponse.isAvailable
        };
        // Populate certifications, appointments
        break;
      case 'Nurse':
        responseProfileData.professional = {
          badgeNumber: userForResponse.badgeNumber, shift: userForResponse.shift,
          licenseNumber: userForResponse.licenseNumber
        };
        break;
      case 'Administrator':
        responseProfileData.professional = { badgeNumber: userForResponse.badgeNumber };
        break;
    }

    res.status(200).json(responseProfileData);

  } catch (error) {
    console.error("Erreur serveur lors de la mise √† jour du profil:", error);
    if (error.name === 'ValidationError') {
        console.error("Mongoose Validation Errors:", JSON.stringify(error.errors, null, 2));
        return res.status(400).json({ message: "Validation Error", errors: error.errors });
    }
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

export default router;
</file>

<file path="routes/resource.js">
import express from "express";
import mongoose from "mongoose";
import cors from "cors";
import dotenv from "dotenv";
import { authenticateToken } from "../middleware/authMiddleware.js";
import Resource from "../models/Resource.js";

const router = express.Router();

// Enable CORS for frontend
router.use(cors({ origin: process.env.FRONTEND_URL || "http://localhost:3000", credentials: true }));
dotenv.config();

/**
 * Create a new resource (admin only)
 */
router.post("/", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Access denied" });
    }
    const newRes = new Resource(req.body);
    const saved = await newRes.save();
    res.status(201).json(saved);
  } catch (error) {
    console.error("Error creating resource:", error);
    res.status(400).json({ message: "Invalid data", error: error.message });
  }
});

/**
 * Get all resources (admin, doctor, nurse)
 */
router.get("/", authenticateToken, async (req, res) => {
  try {
    const allowed = ["Administrator", "Doctor", "Nurse"];
    if (!allowed.includes(req.user.role)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const list = await Resource.find();
    res.status(200).json(list);
  } catch (error) {
    console.error("Error fetching resources:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
});

/**
 * Get a resource by ID
 */
router.get("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "Invalid resource ID" });
    }
    const resrc = await Resource.findById(id);
    if (!resrc) {
      return res.status(404).json({ message: "Resource not found" });
    }
    res.status(200).json(resrc);
  } catch (error) {
    console.error("Error fetching resource:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
});

/**
 * Update a resource by ID (admin, nurse)
 */
router.put("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const allowed = ["Administrator", "Nurse"];
    if (!allowed.includes(req.user.role)) {
      return res.status(403).json({ message: "Access denied" });
    }
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "Invalid resource ID" });
    }
    const updated = await Resource.findByIdAndUpdate(id, req.body, { new: true, runValidators: true });
    if (!updated) {
      return res.status(404).json({ message: "Resource not found" });
    }
    res.status(200).json(updated);
  } catch (error) {
    console.error("Error updating resource:", error);
    res.status(400).json({ message: "Invalid data", error: error.message });
  }
});

/**
 * Delete a resource by ID (admin only)
 */
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Access denied" });
    }
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "Invalid resource ID" });
    }
    const deleted = await Resource.findByIdAndDelete(id);
    if (!deleted) {
      return res.status(404).json({ message: "Resource not found" });
    }
    res.status(200).json({ message: "Resource deleted successfully" });
  } catch (error) {
    console.error("Error deleting resource:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
});
router.post("/:id/allocate", authenticateToken, async (req, res) => {
    try {
      const allowed = ['Administrator','Nurse'];
      if (!allowed.includes(req.user.role)) return res.status(403).json({ message: 'Access denied' });
      const { id } = req.params;
      const { patientId } = req.body;
      if (!mongoose.Types.ObjectId.isValid(id) || !mongoose.Types.ObjectId.isValid(patientId)) {
        return res.status(400).json({ message: 'Invalid ID(s)' });
      }
      const resource = await Resource.findById(id);
      if (!resource) return res.status(404).json({ message: 'Resource not found' });
      resource.allocatedTo = patientId;
      resource.status = 'in-maintenance';
      await resource.save();
      res.status(200).json(resource);
    } catch (error) {
      console.error('Allocation error:', error);
      res.status(500).json({ message: 'Server error', error: error.message });
    }
  });
  
// Export the router
export default router;
</file>

<file path="routes/users.js">
import express from "express";
import { User } from "../models/User.js";
import { authenticateToken } from "../middleware/authMiddleware.js";
import cors from "cors";
import dotenv from "dotenv";
import mongoose from "mongoose";
import SharedMedicalRecord from "../models/SharedMedicalRecord.js";
import AuditLog from "../models/AuditLog.js";
import MedicalRecord from "../models/MedicalRecord.js"; // <-- Import crucial ici


const router = express.Router();
router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();

// Get all doctors (accessible to doctors and admins)
router.get("/doctor/doctors", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const doctors = await User.find({ role: "Doctor" }).select("_id username");
    res.status(200).json(doctors);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Partager un dossier m√©dical avec un autre m√©decin
router.post('/medical-records/:recordId/share', authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== 'Doctor') {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins" });
    }

    const { recordId } = req.params;
    const { recipientId, note } = req.body;

    // Validation de l'ID du destinataire
    if (!mongoose.Types.ObjectId.isValid(recipientId)) {
      return res.status(400).json({ message: "ID m√©decin destinataire invalide" });
    }

    // R√©cup√©ration du m√©decin destinataire
    const recipientDoctor = await User.findOne({
      _id: recipientId,
      role: 'Doctor'
    });

    if (!recipientDoctor) {
      return res.status(404).json({ message: "M√©decin destinataire introuvable" });
    }

    // V√©rification de l'auto-partage (corrig√©)
    if (recipientId === req.user.id) { // <-- Correction ici
      return res.status(400).json({ message: "Impossible de partager avec vous-m√™me" });
    }

    // V√©rification du dossier m√©dical
    const medicalRecord = await MedicalRecord.findById(recordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical introuvable" });
    }

    // Cr√©ation du partage
    const newShare = new SharedMedicalRecord({
      medicalRecordId: recordId,
      sharerId: req.user.id, // Utilisation de .id
      recipientId: recipientId,
      note: note || "Partage de dossier m√©dical"
    });

    await newShare.save();

    // Journalisation
    await AuditLog.create({
      action: 'SHARE_MEDICAL_RECORD',
      userId: req.user.id, // Utilisation de .id
      details: `Partage du dossier ${recordId} avec le Dr. ${recipientDoctor.username}`
    });

    res.status(201).json({
      message: "Dossier partag√© avec succ√®s",
      shareDetails: newShare
    });

  } catch (error) {
    console.error("Erreur lors du partage du dossier:", error);
    res.status(500).json({
      message: "Erreur serveur",
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});
// R√©cup√©rer les dossiers partag√©s avec le m√©decin connect√©
router.get('/medical-records/shared', authenticateToken, async (req, res) => {
  try {
    // V√©rifier que l'utilisateur est un m√©decin
    if (req.user.role !== 'Doctor') {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins" });
    }

    const sharedRecords = await SharedMedicalRecord.find({ recipientId: req.user._id })
      .populate({
        path: 'medicalRecordId',
        populate: [
          {
            path: 'patientId',
            model: 'EmergencyPatient',
            select: 'firstName lastName dateOfBirth gender'
          },
          {
            path: 'creator',
            model: 'User',
            select: 'username specialization'
          }
        ]
      })
      .populate('sharerId', 'username role')
      .sort({ sharedAt: -1 });

    // Formater la r√©ponse
    const formattedRecords = sharedRecords.map(record => ({
      _id: record._id,
      sharedAt: record.sharedAt,
      note: record.note,
      sharer: record.sharerId,
      medicalRecord: {
        _id: record.medicalRecordId._id,
        patient: record.medicalRecordId.patientId,
        creator: record.medicalRecordId.creator,
        bloodType: record.medicalRecordId.bloodType,
        lastUpdated: record.medicalRecordId.lastUpdated
      }
    }));

    res.status(200).json(formattedRecords);

  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des dossiers partag√©s:", error);
    res.status(500).json({
      message: "Erreur serveur",
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});
function formatFileDetails(file) {
  const baseDetails = {
    id: file._id,
    type: file.type,
    createdAt: file.createdAt,
    updatedAt: file.updatedAt
  };

  switch(file.type) {
    case 'Triage':
      return {
        ...baseDetails,
        priorityLevel: file.details.priorityLevel,
        chiefComplaint: file.details.chiefComplaint
      };
    case 'Diagnostic':
      return {
        ...baseDetails,
        diagnosis: file.details.diagnosis,
        tests: file.details.diagnosticTests
      };
    case 'Treatment':
      return {
        ...baseDetails,
        procedures: file.details.procedures
      };
    case 'VitalSigns':
      return {
        ...baseDetails,
        vitalSigns: file.details.vitalSigns
      };
    case 'Prescription':
      return {
        ...baseDetails,
        medications: file.details.medications
      };
    default:
      return baseDetails;
  }
}
// R√©cup√©rer les dossiers partag√©s avec le m√©decin connect√©
router.get('/medical-records/shared-with-me', authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== 'Doctor') {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins" });
    }

    const sharedRecords = await SharedMedicalRecord.find({ recipientId: req.user.id })
      .populate({
        path: 'medicalRecordId',
        populate: [
          {
            path: 'patientId',
            model: 'EmergencyPatient',
            select: 'firstName lastName dateOfBirth gender'
          },
          {
            path: 'creator',
            model: 'User',
            select: 'username specialization'
          },
          {
            path: 'patientFiles',
            model: 'PatientFile',
            options: { 
              sort: { dateRecorded: -1 },
              match: { medicalRecord: { $exists: true } } // Filtre suppl√©mentaire
            }
          }
        ]
      })
      .populate('sharerId', 'username role')
      .sort({ sharedAt: -1 });

    // Ajouter une validation suppl√©mentaire
    const formattedRecords = sharedRecords.map(record => {
      if (!record.medicalRecordId?.patientFiles) {
        console.warn(`Dossier ${record._id} a une structure invalide`);
        return null;
      }

      return {
        // ... autres champs ...,
        medicalRecord: {
          // ... autres champs ...,
          files: record.medicalRecordId.patientFiles
            .filter(file => file) // Filtrer les fichiers null
            .map(file => ({
              id: file._id,
              type: file.type,
              dateRecorded: file.dateRecorded,
              notes: file.notes,
              details: formatFileDetails(file)
            }))
        }
      };
    }).filter(record => record !== null); // Filtrer les entr√©es invalides

    res.status(200).json(formattedRecords);

  } catch (error) {
    console.error("Erreur de r√©cup√©ration :", error);
    res.status(500).json({
      message: "Erreur serveur",
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Ajouter cette m√©thode de formatage

router.get("/doctors", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const doctors = await User.find({ role: "Doctor" }); // Find users with role "Doctor"
    res.status(200).json(doctors);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
// Obtenir tous les utilisateurs (admin uniquement)
router.get("/", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const users = await User.find();
    res.status(200).json(users);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Obtenir un utilisateur par ID
router.get("/users/:id", authenticateToken, async (req, res) => {
  try {
    const userId = mongoose.Types.ObjectId(req.params.id); // Ensure the id is cast to ObjectId
    const user = await User.findById(userId).exec();

    if (!user) {
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    res.status(200).json(user);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration de l'utilisateur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Mettre √† jour un utilisateur
router.put("/:id", authenticateToken, async (req, res) => {
  try {
  

    const updatedUser = await User.findByIdAndUpdate(req.params.id, req.body, { new: true });
    res.status(200).json(updatedUser);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Supprimer un utilisateur (admin uniquement)
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    await User.findByIdAndDelete(req.params.id);
    res.status(200).json({ message: "Utilisateur supprim√©" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Route de validation d'utilisateur (admin uniquement)
router.post("/validate-user", authenticateToken, async (req, res) => {
  try {
    // V√©rifier si l'utilisateur est un administrateur
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const { userId } = req.body;
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Valider l'utilisateur
    user.isValidated = true;
    await user.save();

    res.status(200).json({ message: "Utilisateur valid√© avec succ√®s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
router.get("/patients/count", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const patientCount = await User.countDocuments({ role: "Patient" });
    res.status(200).json({ count: patientCount });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
router.get("/patients", authenticateToken, async (req, res) => {
  try {
    // Ensure the user is an Administrator, Doctor, or Nurse
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    // Fetch patients from the database
    const patients = await User.find({ role: "Patient" }).exec();

    // Check if patients were found
    if (!patients || patients.length === 0) {
      return res.status(404).json({ message: "Aucun patient trouv√©" });
    }

    // Return the list of patients
    res.status(200).json(patients);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des patients:", error); // Log the error
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Delete a patient (admin only)
router.delete("/patients/:id", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const patient = await User.findById(req.params.id);
    if (!patient || patient.role !== "Patient") {
      return res.status(404).json({ message: "Patient non trouv√©" });
    }

    await User.findByIdAndDelete(req.params.id);
    res.status(200).json({ message: "Patient supprim√© avec succ√®s" });
  } catch (error) {
    console.error("Erreur lors de la suppression du patient:", error); // Log the error
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update a patient (admin only)
router.put("/patients/:id", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const patient = await User.findById(req.params.id);
    if (!patient || patient.role !== "Patient") {
      return res.status(404).json({ message: "Patient non trouv√©" });
    }

    const updatedPatient = await User.findByIdAndUpdate(req.params.id, req.body, { new: true });
    res.status(200).json(updatedPatient);
  } catch (error) {
    console.error("Erreur lors de la mise √† jour du patient:", error); // Log the error
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
router.put("/:id/availability", authenticateToken, async (req, res) => {
    const targetUserId = req.params.id;
    const requesterUserId = req.user.id; // ID de celui qui fait la requ√™te
    const requesterRole = req.user.role; // R√¥le de celui qui fait la requ√™te
    const { isAvailable } = req.body; // Valeur attendue : true ou false

    // 1. Validation de l'ID cible
    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
        return res.status(400).json({ message: "ID utilisateur cible invalide." });
    }

    // 2. V√©rification d'autorisation : Admin OU le m√©decin lui-m√™me
    if (requesterRole !== "Administrator" && requesterUserId !== targetUserId) {
        console.log(`Acc√®s refus√© pour ${requesterUserId} (r√¥le ${requesterRole}) tentant de modifier ${targetUserId}`);
        return res.status(403).json({ message: "Acc√®s refus√©. Vous ne pouvez modifier que votre propre disponibilit√© ou √™tre administrateur." });
    }

    // 3. Validation de la valeur 'isAvailable' re√ßue
    if (typeof isAvailable !== 'boolean') {
        return res.status(400).json({ message: "La valeur fournie pour 'isAvailable' est invalide (doit √™tre true ou false)." });
    }

    try {
        // 4. Trouver l'utilisateur cible
        const userToUpdate = await User.findById(targetUserId);

        if (!userToUpdate) {
             return res.status(404).json({ message: "L'utilisateur cible n'a pas √©t√© trouv√©." });
        }

        // 5. V√©rifier si l'utilisateur cible est bien un m√©decin
        if (userToUpdate.role !== 'Doctor') {
           return res.status(400).json({ message: "La disponibilit√© ne peut √™tre modifi√©e que pour un utilisateur ayant le r√¥le 'Doctor'." });
        }

        // 6. Mettre √† jour la disponibilit√© et sauvegarder
        userToUpdate.isAvailable = isAvailable;
        await userToUpdate.save();
        console.log(`Disponibilit√© de ${userToUpdate.username} (ID: ${targetUserId}) mise √† jour √† ${isAvailable} par ${requesterUserId}`);

        // 7. Renvoyer une r√©ponse de succ√®s
        res.status(200).json({
            message: `Disponibilit√© de ${userToUpdate.username} mise √† jour √† ${isAvailable ? 'Disponible' : 'Occup√©'}.`,
            user: { // Renvoyer seulement les infos n√©cessaires
                _id: userToUpdate._id,
                username: userToUpdate.username,
                isAvailable: userToUpdate.isAvailable
            }
        });

    } catch (error) {
        console.error(`Erreur PUT /${targetUserId}/availability:`, error);
        res.status(500).json({ message: "Erreur serveur lors de la mise √† jour de la disponibilit√©.", error: error.message });
    }
});
router.get("/nurses", authenticateToken, async (req, res) => {
  try {
    // Find users with the role "Nurse"
    const nurses = await User.find({ role: "Nurse" });
    res.status(200).json(nurses);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Nouvelle route pour les statistiques des utilisateurs
router.get("/stats", authenticateToken, async (req, res) => {
  try {
      if (req.user.role !== "Administrator") {
          return res.status(403).json({ message: "Acc√®s refus√©" });
      }

      const [patients, doctors, nurses, admins, emergencyPatients] = await Promise.all([
          User.countDocuments({ role: "Patient" }),
          User.countDocuments({ role: "Doctor" }),
          User.countDocuments({ role: "Nurse" }),
          User.countDocuments({ role: "Administrator" }),
          mongoose.model('EmergencyPatient').countDocuments()
      ]);

      const totalUsers = patients + doctors + nurses + admins;
      
      const stats = [
          { name: "Patients", count: patients, percentage: (patients / totalUsers * 100).toFixed(2) },
          { name: "Doctors", count: doctors, percentage: (doctors / totalUsers * 100).toFixed(2) },
          { name: "Nurses", count: nurses, percentage: (nurses / totalUsers * 100).toFixed(2) },
          { name: "Admins", count: admins, percentage: (admins / totalUsers * 100).toFixed(2) },
          { name: "Emergency", count: emergencyPatients, percentage: (emergencyPatients / (totalUsers + emergencyPatients) * 100).toFixed(2) }
      ];

      res.status(200).json(stats);
  } catch (error) {
      console.error("Erreur r√©cup√©ration stats utilisateurs:", error);
      res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Ajoutez cette route dans votre fichier de routes (users.js)
// Dans users.js (backend)
router.get("/me", authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.id)
      .select("-password -resetPasswordToken -resetPasswordExpires -otp -otpExpires");

    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    res.status(200).json({
      id: user._id,
      username: user.username,
      email: user.email,
      role: user.role,
      // Ajoutez d'autres champs si n√©cessaire
    });
    
  } catch (error) {
    console.error("Erreur r√©cup√©ration utilisateur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
export default router;
</file>

<file path="sendSMS.js">
import { parsePhoneNumberFromString, isValidPhoneNumber } from 'libphonenumber-js';
import dotenv from 'dotenv';
import twilio from 'twilio';

dotenv.config();

const accountSid = process.env.TWILIO_ACCOUNT_SID;
const authToken = process.env.TWILIO_AUTH_TOKEN;
const client = twilio(accountSid, authToken);

const sendSMS = async (body, userPhoneNumber) => {
    try {
        // Parse le num√©ro
        const phoneNumber = parsePhoneNumberFromString(userPhoneNumber, 'TN'); // 'TN' pour Tunisie.  Change si n√©cessaire.

        // V√©rifie si le num√©ro est valide
        if (!phoneNumber || !isValidPhoneNumber(phoneNumber.number, phoneNumber.country)) {
            console.error("Num√©ro de t√©l√©phone invalide :", userPhoneNumber);
            return { success: false, message: 'Num√©ro de t√©l√©phone invalide.' };
        }

        // Formate le num√©ro en E.164 (le format requis par Twilio)
        const formattedPhoneNumber = phoneNumber.format('E.164');

        const msgOptions = {
            from: process.env.TWILIO_FROM_NUMBER,
            to: formattedPhoneNumber,
            body: body
        };

        const message = await client.messages.create(msgOptions);
        console.log("‚úÖ SMS envoy√© avec succ√®s :", message.sid);
        return { success: true, message: 'Message sent successfully' };

    } catch (error) {
        console.error("‚ùå Erreur d'envoi SMS ou de validation du num√©ro:", error);

        // G√©rer les erreurs sp√©cifiques √† libphonenumber et Twilio s√©par√©ment
        if (error.message === "INVALID_COUNTRY") { // Exemple d'erreur libphonenumber-js
            return { success: false, message: 'Code pays invalide pour le num√©ro de t√©l√©phone.' };
        }

        if (error.code === 21211) {
            return { success: false, message: 'Num√©ro de t√©l√©phone invalide pour Twilio.' };
        }
        //Ajoute d'autre  gestion d'erreur si n√©cessaire
        return { success: false, message: '√âchec de l\'envoi du SMS', error: error.message };
    }
};

export default sendSMS;
</file>

<file path="server.js">
import express from "express";
import mongoose from "mongoose";
import cors from "cors";
import dotenv from "dotenv";
import http from "http";
import cookieParser from "cookie-parser";
import path from "path";
import { fileURLToPath } from "url";
import { Server as SocketIOServer } from "socket.io"; // Use the alias you defined
import jwt from 'jsonwebtoken'; // Keep JWT import
import ocrRouter from "./routes/ocr.js"
import connectDB from "./db.js";

// Route Imports
import authRoutes from "./routes/auth.js";
import userRoutes from "./routes/users.js";
import profileRoutes from "./routes/profile.js";
import emergencyPatientRoutes from "./routes/emergencyPatients.js";
import aiRoutes from "./routes/ai.js";
import ambulanceRoutes from "./routes/ambulance.js";
import medicalRecordRoutes from "./routes/medicalRecords.js";
import patientFileRoutes from "./routes/patientFile.js";
import alertsRoutes from "./routes/alerts.js";
import notificationRoutes from './routes/notifications.js';
import staffChatbotRoutes from './routes/chatbot.js';

// --- Model Imports ---
import annotationsRoutes from "./routes/annotation.js";
import archiveRoutes from "./routes/archive.js";
import ambulanceRequestRoutes from "./routes/ambulanceRequests.js";
import Ambulance from "./models/Ambulance.js";
import AmbulanceRequest from "./models/AmbulanceRequest.js"

import Feedback from "./models/FeedBack.js";
import feedbackRoutes from "./routes/feedback.js";
import { User } from "./models/User.js";
import Alert from "./models/Alert.js";
import Resource from "./routes/resource.js";
import patientRoutes from "./routes/patient.js"
import bloodRequestRoutes from "./routes/bloodRequests.js";
// --- Helpers ---
dotenv.config();
connectDB();

const app = express();
const server = http.createServer(app);

// Get __dirname in ES module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize Socket.IO server
const io = new SocketIOServer(server, {
  cors: {
    origin: "http://localhost:3000",
    methods: ["GET", "POST"],
    credentials: true,
  },
});

// User-socket mapping
const userSockets = new Map();

// Middleware
app.use(
  cors({
    origin: "http://localhost:3000",
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", " PATCH", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  })
);
app.use(express.json());
app.use(cookieParser());

// Serve static files from 'Uploads' directory
app.use("/uploads", express.static(path.join(__dirname, "Uploads")));

// Attach io and userSockets to request object
app.use((req, res, next) => {
  req.io = io;
  req.userSockets = userSockets;
  next();
});

// REST API routes
app.use("/api/auth", authRoutes);
app.use("/api/users", userRoutes);
app.use("/api", profileRoutes);
app.use("/api/emergency-patients", emergencyPatientRoutes);
app.use("/api/ambulance", ambulanceRoutes);
app.use("/api/ambulance-requests", ambulanceRequestRoutes);
app.use("/api/medical-records", medicalRecordRoutes);
app.use("/api/patient-files", patientFileRoutes);
app.use("/api/alerts", alertsRoutes);
app.use("/api/annotations", annotationsRoutes);
app.use("/api/archive", archiveRoutes);
app.use("/api/resources", Resource);
app.use("/api/ocr", ocrRouter);
app.use("/api/patients", patientRoutes);
app.use("/api/ai", aiRoutes); // Note: Remove duplicate aiRoutes entries

// Socket.IO Authentication Middleware
app.use("/api/resources", Resource);
app.use('/api/ocr', ocrRouter); // Mount the router under /api/ocr
app.use('/api/patients', patientRoutes);
app.use('/api/feedback', feedbackRoutes);
app.use('/api/ai', aiRoutes);
app.use('/api/chatbot', staffChatbotRoutes);


app.use("/api/blood-requests", bloodRequestRoutes);

app.use('/api/ai', aiRoutes);

app.use('/api/ai', aiRoutes);
app.use('/api/notifications', notificationRoutes);

// --- ‚ú® Socket.IO Authentication Middleware ---
io.use((socket, next) => {
  const token =
    socket.handshake.auth.token ||
    socket.handshake.headers.cookie?.split("; ").find((row) => row.startsWith("token="))?.split("=")[1];

  if (!token) {
    console.error("‚ùå Socket Auth Error: No token provided");
    return next(new Error("Authentication error: No token"));
  }
  try {
    const verified = jwt.verify(token, process.env.JWT_SECRET);
    socket.userId = verified.id;
    socket.userRole = verified.role;
    console.log(`üîí Socket authenticated: User ${socket.userId} (${socket.userRole})`);
    next();
  } catch (error) {
    console.error("‚ùå Socket Auth Error: Invalid token -", error.message);
    return next(new Error("Authentication error: Invalid token"));
  }
});

// Socket.IO Connection Logic
io.on("connection", (socket) => {
  console.log(`‚ö° Socket connected: ${socket.id} for User ID: ${socket.userId} (${socket.userRole})`);

  // Associate userId with socket
  if (socket.userId) {
    userSockets.set(socket.userId.toString(), socket.id);
    console.log(`üó∫Ô∏è User ${socket.userId} mapped to socket ${socket.id}`);
  } else {
    console.warn(`‚ö†Ô∏è Socket ${socket.id} connected without a valid userId after authentication.`);
  }

  // Join Role-Based Rooms
  if (socket.userRole) {
    const roomName = `${socket.userRole.toLowerCase()}-room`;
    socket.join(roomName);
    console.log(`üö™ Socket ${socket.id} (User ${socket.userId}) joined room: ${roomName}`);
    socket.join(`user_${socket.userId}`);
    console.log(`üö™ Socket ${socket.id} (User ${socket.userId}) joined personal room: user_${socket.userId}`);
  }

  // Ambulance location update
  socket.on("locationUpdate", async (data) => {
    console.log("Received locationUpdate:", data);
    if (!data || !data.id || data.latitude == null || data.longitude == null) {
      console.error("Invalid locationUpdate data received:", data);
      return;
    }
    try {
      await Ambulance.findByIdAndUpdate(data.id, {
        latitude: data.latitude,
        longitude: data.longitude,
        lastUpdated: data.timestamp || new Date(),
      });
      io.emit(`ambulance_${data.id}`, {
        type: "LOCATION_UPDATE",
        data: { latitude: data.latitude, longitude: data.longitude },
      });
    } catch (err) {
      console.error("‚ùå Error saving location:", err);
    }
  });

  // Ambulance destination update
  socket.on("destinationUpdate", async (data) => {
    console.log("Received destinationUpdate:", data);
    if (!data || !data.id || data.destinationLatitude == null || data.destinationLongitude == null) {
      console.error("Invalid destinationUpdate data received:", data);
      return;
    }
    try {
      const destination = `${data.destinationLatitude},${data.destinationLongitude}`;
      await Ambulance.findByIdAndUpdate(data.id, {
        destination,
        lastUpdated: Date.now(),
      });
      io.emit("destinationUpdate", data);
    } catch (err) {
      console.error("‚ùå Error saving destination:", err);
    }
  });

  // Patient location update (from socketManager.js)
  socket.on("updatePatientLocation", async (data) => {
    try {
      const { requestId, latitude, longitude } = data;
      const request = await AmbulanceRequest.findById(requestId);
      if (request) {
        request.patient.location = { latitude, longitude };
        await request.save();

        const ambulance = await Ambulance.findById(request.ambulance);
        if (ambulance) {
          ambulance.destination = `${latitude},${longitude}`;
          await ambulance.save();

          io.emit(`ambulance_${ambulance._id}`, {
            type: "LOCATION_UPDATE",
            data: { latitude, longitude },
          });
        }
      }
    } catch (error) {
      console.error("Error updating patient location:", error);
    }
  });

  // New ambulance request (from socketManager.js)
  socket.on("newAmbulanceRequest", async (data) => {
    try {
      const request = await AmbulanceRequest.create(data);
      const ambulance = await Ambulance.findOne({ status: "AVAILABLE" });
      if (ambulance) {
        request.ambulance = ambulance._id;
        request.status = "ACCEPTED";
        await request.save();

        ambulance.status = "ON_MISSION";
        ambulance.destination = `${request.patient.location.latitude},${request.patient.location.longitude}`;
        await ambulance.save();

        io.emit("ambulanceRequestUpdate", {
          type: "NEW_REQUEST",
          data: request,
        });

        io.emit(`ambulance_${ambulance._id}`, {
          type: "NEW_MISSION",
          data: request,
        });
      }
    } catch (error) {
      console.error("Error creating ambulance request:", error);
    }
  });

  // Ambulance alert
  socket.on("alert", async ({ message, source }) => {
    console.log("Received alert:", { message, source });
    if (!message || !source) {
      console.error("Invalid alert data received:", { message, source });
      return;
    }
    try {
      const alert = await Alert.create({ message, source });
      io.emit("alert", {
        _id: alert._id,
        message: alert.message,
        source: alert.source,
        timestamp: alert.timestamp,
      });
    } catch (err) {
      console.error("‚ùå Error saving alert:", err);
    }
  });

  // Ping-pong test
  socket.on("ping_server", (data) => {
    console.log("Received ping_server from:", socket.id, data);
    socket.emit("pong_client", {
      message: "Pong from server!",
      timestamp: Date.now(),
    });
  });

  socket.on("disconnect", (reason) => {
    console.log(`üî• Socket disconnected: ${socket.id}. Reason: ${reason}`);
    if (socket.userId) {
      if (userSockets.get(socket.userId.toString()) === socket.id) {
        userSockets.delete(socket.userId.toString());
        console.log(`üó∫Ô∏è User ${socket.userId} removed from socket map.`);
      }
    }
    for (let [key, value] of userSockets.entries()) {
      if (value === socket.id) {
        userSockets.delete(key);
        console.log(`üó∫Ô∏è Cleaned up map entry for disconnected socket ${socket.id}`);
        break;
      }
    }
  });
});

// Server Listen
const PORT = process.env.PORT || 8089;
server.listen(PORT, () => {
  console.log(`‚úÖ Server (with Socket.IO) running on port ${PORT}`);
});
</file>

<file path="services/aiService.js">
// backend/services/aiService.js
import OpenAI from 'openai';
import dotenv from 'dotenv';

dotenv.config(); // Charger les variables d'environnement

// Initialiser le client OpenAI
const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Analyse le texte des sympt√¥mes fourni par un patient √† l'aide d'un LLM.
 * @param {string} symptomText - La description des sympt√¥mes fournie par le patient.
 * @returns {Promise<object>} Un objet contenant les mots-cl√©s et les questions sugg√©r√©es.
 *                          Ex: { keywords: ["douleur poitrine", "essoufflement"], suggestedQuestions: ["La douleur s'√©tend-elle au bras ?", ...] }
 * @throws {Error} Si l'analyse √©choue.
 */
export const analyzeSymptoms = async (symptomText) => {
    if (!symptomText || typeof symptomText !== 'string' || symptomText.trim().length < 10) {
        // Ne pas appeler l'API si le texte est trop court ou invalide
        console.log("Texte de sympt√¥me trop court ou invalide, analyse annul√©e.");
        return { keywords: [], suggestedQuestions: [] };
    }

    const systemPrompt = `
    You are a helpful medical assistant bot integrated into an emergency registration system.
    Your role is to analyze a patient's symptom description to extract key information and suggest clarifying questions.
    You MUST follow these instructions strictly:
    1.  Identify the main keywords or symptoms mentioned by the patient. List them concisely.
    2.  Suggest 2-3 relevant follow-up questions that a medical professional MIGHT ask to get more details about the symptoms described. These questions should be open-ended and aimed at clarification (e.g., "Where exactly is the pain located?", "When did the symptoms start?").
    3.  **CRITICAL: DO NOT provide any diagnosis, medical advice, assessment of severity, or treatment recommendations.** Do not use phrases like "you might have", "it sounds like", "you should".
    4.  **CRITICAL: Your output MUST be a valid JSON object ONLY, with the following structure:**
        {
          "keywords": ["symptom1", "symptom2", ...],
          "suggestedQuestions": ["question1?", "question2?", ...]
        }
    5.  If the input text is vague or doesn't seem like symptoms, return empty arrays for keywords and questions in the JSON structure.
    6.  Keep keywords and questions concise and clear.
  `;

    try {
        console.log(`[AI Service] Analyse des sympt√¥mes demand√©e pour: "${symptomText.substring(0, 50)}..."`);
        const completion = await openai.chat.completions.create({
            model: "gpt-3.5-turbo-0125", // Mod√®le √©conomique et rapide, suffisant pour cette t√¢che. Vous pouvez tester gpt-4o si besoin.
            messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: symptomText }
            ],
            temperature: 0.3, // Faible temp√©rature pour des r√©ponses plus factuelles/pr√©visibles
            max_tokens: 150, // Limiter la longueur de la r√©ponse
            response_format: { type: "json_object" } // Essayer de forcer le JSON (marche avec certains mod√®les)
        });

        const responseContent = completion.choices[0]?.message?.content;
        console.log("[AI Service] R√©ponse brute de l'API:", responseContent);

        if (!responseContent) {
            throw new Error("R√©ponse vide de l'API OpenAI.");
        }

        // Essayer de parser la r√©ponse JSON
        let parsedResponse;
        try {
            parsedResponse = JSON.parse(responseContent);
            // Valider la structure attendue
            if (!parsedResponse || !Array.isArray(parsedResponse.keywords) || !Array.isArray(parsedResponse.suggestedQuestions)) {
                console.error("[AI Service] Structure JSON invalide re√ßue:", parsedResponse);
                throw new Error("Format de r√©ponse JSON invalide de l'API.");
            }
            console.log("[AI Service] R√©ponse analys√©e:", parsedResponse);
            return parsedResponse;
        } catch (parseError) {
            console.error("[AI Service] Erreur de parsing JSON:", parseError);
            console.error("[AI Service] Contenu re√ßu non-JSON:", responseContent);
            // Fallback: essayer d'extraire manuellement si c'est possible (peu fiable)
            // Ou simplement retourner un objet vide/erreur structur√©e
            return { keywords: [], suggestedQuestions: [], error: "Format de r√©ponse invalide de l'IA." };
        }

    } catch (error) {
        console.error("[AI Service] Erreur lors de l'appel √† l'API OpenAI:", error);
        // Remonter une erreur plus g√©n√©rique pour ne pas exposer de d√©tails sensibles
        throw new Error("L'analyse des sympt√¥mes par l'IA a √©chou√©.");
    }
};
</file>

<file path="services/classifierService.js">
import dotenv from 'dotenv';
dotenv.config();

import { pipeline } from '@xenova/transformers';

let classifierPromise = null;

async function getClassifier() {
  if (!classifierPromise) {
    const options = {};
    if (process.env.HF_HUB_TOKEN) {
      options.auth_token = process.env.HF_HUB_TOKEN;
    }

    classifierPromise = pipeline(
      'zero-shot-classification',
      'Xenova/nli-deberta-v3-xsmall',
      options
    );
  }
  return classifierPromise;
}

export async function classifyPatientNeeds(prompt) {
  const candidateLabels = ['bed', 'icu', 'ct-scan', 'xray', 'ventilator'];
  const classifier = await getClassifier();
  
  // Call the classifier with all candidate labels
  const result = await classifier(prompt, candidateLabels);
  
  console.log('Raw classifier result:', JSON.stringify(result, null, 2));

  // Check if the result has both labels and scores arrays
  if (!result.labels || !result.scores) {
    console.error("Error: Expected structure not found in classifier result");
    return null;
  }

  // Find the index of the highest score
  let maxScoreIndex = 0;
  for (let i = 1; i < result.scores.length; i++) {
    if (result.scores[i] > result.scores[maxScoreIndex]) {
      maxScoreIndex = i;
    }
  }
  
  // Return only the top label
  return result.labels[maxScoreIndex];
}

// Example usage
async function test() {
  const prompt = "Chief complaint: Headache and fever. Vitals: {\"bloodPressure\":{\"systolic\":118,\"diastolic\":76},\"temperature\":38.2,\"heartRate\":92,\"respiratoryRate\":20,\"oxygenSaturation\":97}. Notes: Initial diagnostic notes..";
  const topRecommendation = await classifyPatientNeeds(prompt);
  console.log("Top recommendation:", topRecommendation);
}

// Uncomment to run test
// test().catch(console.error);
</file>

<file path="services/emailService.js">
// services/emailService.js
import nodemailer from "nodemailer";
import dotenv from "dotenv";

dotenv.config();

// Configurer le transporteur d'email
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD,
  },
});

// Envoyer l'OTP par email
export const sendOTP = async (email, otp) => {
  const mailOptions = {
    from: process.env.EMAIL_USER,
    to: email,
    subject: "Your OTP Code",
    html: `<!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>OTP Verification</title>
          <style>
              body {
                  font-family: Arial, sans-serif;
                  background-color: #f4f4f4;
                  padding: 40px;
                  margin: 0;
                  text-align: center;
              }
              .container {
                  max-width: 600px;
                  margin: 0 auto;
                  background-color: #ffffff;
                  border-radius: 8px;
                  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                  padding: 30px;
                  text-align: center;
              }
              h1 {
                  color: #333;
                  font-size: 24px;
                  margin-bottom: 20px;
              }
              .otp-code {
                  font-size: 32px;
                  font-weight: bold;
                  color: #007BFF;
                  padding: 10px;
                  border: 2px solid #007BFF;
                  display: inline-block;
                  margin-bottom: 20px;
              }
              .expiration {
                  color: #555;
                  font-size: 14px;
                  margin-top: 10px;
              }
              .footer {
                  margin-top: 30px;
                  color: #888;
                  font-size: 12px;
              }
              .footer a {
                  color: #007BFF;
                  text-decoration: none;
              }
          </style>
      </head>
      <body>
          <div class="container">
              <h1>OTP Verification</h1>
              <p>Your OTP code is:</p>
              <div class="otp-code">${otp}</div>
              <p class="expiration">It will expire in 5 minutes.</p>
              <div class="footer">
                  <p>If you didn't request this, please ignore this email.</p>
              </div>
          </div>
      </body>
      </html>`,
  };

  await transporter.sendMail(mailOptions);
};
</file>

<file path="services/huggingFaceQAService.js">
// backend/services/huggingFaceQAService.js

import { InferenceClient } from '@huggingface/inference';
import dotenv from 'dotenv';
dotenv.config();

// 1. On lit le token AVANT toute utilisation
const HF_TOKEN = process.env.HF_ACCESS_TOKEN;
if (!HF_TOKEN) {
  console.warn("‚ö†Ô∏è HF_ACCESS_TOKEN n‚Äôest pas d√©fini dans .env");
}

// 2. Instanciation correcte du client avec la string du token
const hf = new InferenceClient(HF_TOKEN);

// 3. Choix du mod√®le QA (public ou priv√©)
const QA_MODEL = process.env.HF_QA_MODEL || 'deepset/roberta-base-squad2';

export const getAnswerFromContext = async (question, context) => {
  // 4. V√©rifications
  if (!HF_TOKEN) {
    throw new Error("Token Hugging Face manquant.");
  }
  if (!question || !context) {
    throw new Error("Question et contexte sont requis.");
  }

  // 5. Convertir en string si besoin
  const q = String(question);
  const c = String(context);
  console.log(`[HF QA] Question: "${q}"`);

  try {
    // 6. Appel au pipeline QA
    const raw = await hf.questionAnswering({
      model: QA_MODEL,
      inputs: { question: q, context: c },
    });

    // 7. Normalisation de la sortie
    const { answer, score } = Array.isArray(raw) ? raw[0] : raw;
    console.log("[HF QA] R√©ponse:", answer, "(score:", score, ")");
    return { answer, score };

  } catch (err) {
    const errMsg = err.response?.data?.error || err.message;
    console.error("[HF QA] Erreur :", errMsg);
    throw new Error(`QA pipeline failed: ${errMsg}`);
  }
};
</file>

<file path="services/ocrService.js">
import { createWorker } from 'tesseract.js';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { extractMedicalData } from '../utils/textParser.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const imagesUploadDir = path.resolve(__dirname, '../../../uploads/images');
const tessdataDir = path.resolve(__dirname, '../../../tessdata');
const tesscacheDir = path.resolve(__dirname, '../../../tesscache');

const verifyEnvironment = async () => {
    try {
        const requiredDirs = [
            imagesUploadDir,
            tessdataDir
        ];

        for (const dir of requiredDirs) {
            await fs.ensureDir(dir);
        }

        return true;
    } catch (error) {
        throw new Error(`Erreur de configuration: ${error.message}`);
    }
};

export const processImage = async (imagePath, medicalRecordId) => {
    let worker = null;

    try {
        // V√©rification de l'existence du fichier image
        await fs.access(imagePath, fs.constants.R_OK);

        await verifyEnvironment();

        worker = await createWorker({
            cachePath: tesscacheDir,
            logger: m => console.log('[TESSERACT]', m),
            errorHandler: err => console.error('[TESSERACT ERROR]', err),
            tessdataDir: tessdataDir
        });

        await worker.loadLanguage('fra+eng');
        await worker.initialize('fra+eng');

        await worker.setParameters({
            tessedit_pageseg_mode: '6', // Mode traitement de bloc unique (adapter si n√©cessaire)
            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√â√à√ä√ã√Ä√Ç√Ñ√é√è√î√ñ√ô√õ√ú√á√©√®√™√´√†√¢√§√Æ√Ø√¥√∂√π√ª√º√ß0123456789-/,.:;()\'" ',
            preserve_interword_spaces: '1'
        });

        const extractionStartTime = Date.now();

        const { data } = await worker.recognize(imagePath, {
            rotateAuto: true,
            pdfTitle: "Image" // Le titre PDF n'est plus pertinent ici
        });

        const fullText = data.text;

        console.log(`OCR compl√©t√© en ${((Date.now() - extractionStartTime) / 1000).toFixed(1)}s`);

        const extractedData = extractMedicalData(fullText); // Tu peux adapter cette fonction si n√©cessaire pour des images

        return {
            success: true,
            data: {
                text: fullText,
                extractedData: extractedData // Les donn√©es extraites d√©pendront du contenu de l'image
            }
        };

    } catch (error) {
        console.error('Erreur de traitement OCR sur image:', {
            error: error.message,
            imagePath,
            stack: error.stack
        });
        throw new Error(`√âchec du traitement OCR sur image: ${error.message}`);
    } finally {
        if (worker) {
            await worker.terminate();
        }
    }
};
</file>

<file path="services/otpService.js">
// services/otpService.js
import bcrypt from "bcrypt";
import { User } from "../models/User.js";

// G√©n√©rer un OTP
export const generateOTP = async () => {
  const otp = Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit OTP
  const salt = await bcrypt.genSalt(10);
  const hashedOTP = await bcrypt.hash(otp, salt);
  return { otp, hashedOTP };
};

// Sauvegarder l'OTP dans la base de donn√©es
export const saveOTPToUser = async (email, hashedOTP) => {
  const user = await User.findOne({ email });
  if (!user) throw new Error("User not found");

  // Stocker l'OTP et d√©finir une date d'expiration (10 minutes)
  user.otp = hashedOTP;
  user.otpExpires = Date.now() + 10 * 60 * 1000; // 10 minutes
  await user.save();
};

// V√©rifier l'OTP
export const verifyOTP = async (inputOTP, storedHashedOTP) => {
  return await bcrypt.compare(inputOTP, storedHashedOTP);
};
</file>

<file path="services/simpleSymptomHelper.js">
// backend/services/simpleSymptomHelper.js

// --- D√©finition des Mappings ---
// On d√©finit d'abord les questions communes pour √©viter la r√©p√©tition
const commonQuestions = {
    respiratory: [
        'Est-ce apparu soudainement ou progressivement ?',
        'Avez-vous de la toux ou une douleur en respirant ?',
        'Est-ce pire en position allong√©e ?'
    ],
    chestPain: [
        'La douleur s\'√©tend-elle √† d\'autres parties (bras, dos, m√¢choire) ?',
        'Quand la douleur a-t-elle commenc√© exactement ?',
        'Avez-vous des difficult√©s √† respirer, des sueurs ou des naus√©es ?'
    ],
    headache: [
        'O√π se situe la douleur dans la t√™te ?',
        'Avez-vous des naus√©es, vomissements ou sensibilit√© √† la lumi√®re ?',
        'Avez-vous eu un choc √† la t√™te r√©cemment ?'
    ],
    abdominalPain: [
        'O√π se situe pr√©cis√©ment la douleur dans l\'abdomen ?',
        'Avez-vous de la fi√®vre, des naus√©es ou des diarrh√©es ?',
        'Depuis quand avez-vous mal ?'
    ],
    fever: [
        'Avez-vous pris votre temp√©rature ? Si oui, combien ?',
        'Avez-vous d\'autres sympt√¥mes (toux, courbatures) ?',
        'Depuis combien de temps avez-vous de la fi√®vre ?'
    ],
    fall: [
        'Avez-vous perdu connaissance, m√™me bri√®vement ?',
        'Vous √™tes-vous cogn√© la t√™te ou une autre partie du corps ?',
        'Avez-vous des douleurs ou difficult√©s √† bouger ?'
    ],
    allergy: [
        '√Ä quoi pensez-vous √™tre allergique ?',
        'Avez-vous des difficult√©s √† respirer ou un gonflement (visage, gorge) ?',
        'Avez-vous une √©ruption cutan√©e ? O√π ?'
    ],
    nausea: [
            'Avez-vous vomi ? Si oui, combien de fois et √† quoi ressemblaient les vomissements ?',
            'Avez-vous d\'autres sympt√¥mes (douleur ventre, diarrh√©e, fi√®vre) ?',
            'Depuis quand avez-vous des naus√©es ?'
    ]
    // Ajouter d'autres groupes de questions communes si n√©cessaire
};

const symptomMappings = {
    // Douleurs
    'poitrine': {
        keywords: ['douleur poitrine', 'pression thoracique', 'serrement poitrine'],
        questions: commonQuestions.chestPain
    },
    'c≈ìur': { // Nouveau: li√© √† poitrine
        keywords: ['douleur cardiaque', 'palpitations', 'probl√®me c≈ìur', 'douleur poitrine'],
        questions: commonQuestions.chestPain // R√©utiliser ou adapter les questions
    },
    't√™te': {
        keywords: ['mal de t√™te', 'c√©phal√©e', 'migraine'],
        questions: commonQuestions.headache
    },
    'ventre': {
        keywords: ['douleur abdominale', 'mal de ventre', 'crampes estomac'],
        questions: commonQuestions.abdominalPain
    },
    'estomac': { // Variante de ventre
        keywords: ['douleur estomac', 'br√ªlure estomac'],
        questions: commonQuestions.abdominalPain
    },
    'dos': {
        keywords: ['mal de dos', 'douleur lombaire', 'douleur dorsale'],
        questions: [
            'O√π exactement dans le dos avez-vous mal ? (Bas, milieu, haut)',
            'La douleur descend-elle dans une jambe ?',
            'Est-ce apparu apr√®s un effort ou une chute ?',
        ]
    },

    // Respiration
    'respire': {
        keywords: ['difficult√© respiratoire', 'essoufflement', 'manque d\'air', 'souffle court'],
        questions: commonQuestions.respiratory
    },
    'souffle': { // Variante
        keywords: ['difficult√© respiratoire', 'essoufflement', 'manque d\'air'],
        questions: commonQuestions.respiratory
    },
    'toux': {
        keywords: ['toux', 'tousse'],
        questions: [
            'La toux est-elle s√®che ou grasse (avec crachats) ?',
            'Depuis combien de temps toussez-vous ?',
            'Avez-vous de la fi√®vre ou des difficult√©s √† respirer associ√©es ?'
        ]
    },

    // Fi√®vre
    'fi√®vre': {
        keywords: ['fi√®vre', 'chaud', 'temp√©rature √©lev√©e'],
        questions: commonQuestions.fever
    },
    'temp√©rature': { // Nouveau: li√© √† fi√®vre
        keywords: ['temp√©rature', 'fi√®vre'],
        questions: commonQuestions.fever
    },
    'frisson': { // Variante fi√®vre
        keywords: ['frissons', 'fi√®vre'],
        questions: commonQuestions.fever
    },

    // Traumatisme / Blessures
    'tomber': {
        keywords: ['chute', 'tomb√©(e)', 'perte d\'√©quilibre'],
        questions: commonQuestions.fall
    },
     'chute': { // Variante
        keywords: ['chute', 'tomb√©(e)'],
        questions: commonQuestions.fall
    },
    'cogn√©': {
        keywords: ['choc', 'coup', 'contusion'],
        questions: [
            'Quelle partie du corps a re√ßu le choc ?',
            'Y a-t-il un gonflement, un bleu ou une plaie ouverte ?',
            'Avez-vous des douleurs intenses ou des difficult√©s √† bouger ?'
        ]
    },
     'coupure': { /* ... */ }, // Garder vos d√©finitions pr√©c√©dentes ou les adapter
     'plaie': { /* ... */ },
     'br√ªlure': { /* ... */ },
     'saigne': { /* ... */ },

    // Neuro / Conscience
    'vertige': { /* ... */ },
    '√©vanoui': { /* ... */ },
    'connaissance': { /* ... */ },

    // Allergies
    'allergie': {
        keywords: ['r√©action allergique', 'allergie', '√©ruption'],
        questions: commonQuestions.allergy
    },
    'gonflement': {
         keywords: ['gonflement', '≈ìd√®me'],
         questions: [ /* ... gardez les questions pr√©c√©dentes pour gonflement ... */
             'Quelle partie du corps est gonfl√©e ?',
             'Est-ce apparu soudainement ?',
             'Est-ce douloureux, rouge ou chaud ?',
             'Avez-vous des difficult√©s √† respirer ?'
         ]
    },

    // Digestif
    'naus√©e': { // Mot-cl√© pour les naus√©es
        keywords: ['naus√©e', 'envie de vomir', 'mal au c≈ìur'], // Ajout "mal au c≈ìur" ici
        questions: commonQuestions.nausea
    },
     'vomi': { // Variante
        keywords: ['vomissements', 'naus√©e'],
        questions: commonQuestions.nausea
    },
    'diarrh√©e': { /* ... */ },

    // Ajoutez d'autres...
};

/**
 * Analyse SIMPLEMENT le texte des sympt√¥mes bas√© sur des mots-cl√©s pr√©d√©finis.
 * @param {string} symptomText - La description des sympt√¥mes.
 * @returns {object} Un objet { keywords: string[], suggestedQuestions: string[] }.
 */
export const analyzeSymptomsSimple = (symptomText) => {
    if (!symptomText || typeof symptomText !== 'string' || symptomText.trim().length < 5) {
         console.log("[Simple Analysis] Texte trop court ou invalide, retour vide.");
        return { keywords: [], suggestedQuestions: [] };
    }

    console.log(`[Simple Analysis] Analyse du texte: "${symptomText.substring(0, 70)}..."`);
    const textLower = symptomText.toLowerCase();
    const foundKeywords = new Set();
    const suggestedQuestions = new Set();
    let questionCount = 0;
    const maxQuestions = 3; // Limite du nombre total de questions √† sugg√©rer

    // Parcourir les mots d√©clencheurs d√©finis
    for (const triggerWord in symptomMappings) {
        // Utiliser includes() pour une recherche de sous-cha√Æne simple et robuste
        if (textLower.includes(triggerWord)) {
            console.log(`[Simple Analysis] Mot d√©clencheur trouv√©: "${triggerWord}"`);

            // Ajouter les mots-cl√©s associ√©s (√©vite les doublons gr√¢ce au Set)
            symptomMappings[triggerWord].keywords.forEach(kw => foundKeywords.add(kw));

            // Ajouter les questions associ√©es sans d√©passer la limite et sans doublons
            symptomMappings[triggerWord].questions.forEach(q => {
                if (questionCount < maxQuestions && !suggestedQuestions.has(q)) {
                    suggestedQuestions.add(q);
                    questionCount++;
                }
            });
        }
         // Optionnel: sortir de la boucle si on a d√©j√† assez de questions
         // if (questionCount >= maxQuestions) break;
    }

    // Optionnel: ajouter une question g√©n√©rique si absolument rien n'a √©t√© trouv√©
    if (foundKeywords.size === 0 && suggestedQuestions.size === 0 && textLower.length > 15) {
        console.log("[Simple Analysis] Aucun mot-cl√© trouv√©, ajout de questions g√©n√©riques.");
        suggestedQuestions.add("Pouvez-vous d√©crire plus pr√©cis√©ment le sympt√¥me principal ?");
        if (suggestedQuestions.size < maxQuestions) {
             suggestedQuestions.add("Quand ces sympt√¥mes ont-ils commenc√© ?");
        }
    }

    // Convertir les Sets en Array pour le retour JSON
    const result = {
        keywords: [...foundKeywords],
        suggestedQuestions: [...suggestedQuestions]
    };

    console.log("[Simple Analysis] R√©sultat final:", result);
    return result;
};
</file>

<file path="services/waitTimeService.js">
// backend/services/waitTimeService.js
import EmergencyPatient from '../models/EmergencyPatient.js';
// Correction: Utiliser l'import nomm√© avec les accolades
import { User } from '../models/User.js'; // Assurez-vous que le chemin est correct

// --- Logique Heuristique Simple ---
// Ces valeurs sont des exemples, √† ajuster selon la r√©alit√© de l'h√¥pital
const BASE_WAIT_TIME_MINUTES = {
    critical: 5, // Temps incompressible pour pr√©parer
    high: 15,
    medium: 30,
    low: 60,
    default: 45 // Si niveau non d√©fini ou invalide
};

const PEAK_HOURS_START = 8; // 8h du matin
const PEAK_HOURS_END = 18; // 18h (6 PM)
const PEAK_HOUR_FACTOR = 1.5; // Augmente le temps de 50% pendant les heures de pointe
const WEEKEND_FACTOR = 1.2; // Augmente le temps de 20% le week-end (Samedi/Dimanche)
const PATIENT_LOAD_FACTOR_PER_PATIENT = 5; // Ajoute 5 minutes par autre patient en attente r√©cente
const DOCTOR_AVAILABILITY_FACTOR = 0.8; // R√©duit le temps de 20% si plus de 2 m√©decins sont disponibles
const MIN_WAIT_TIME = 5; // Temps d'attente minimum absolu (en minutes)
const MAX_WAIT_TIME = 180; // Temps d'attente maximum pour √©viter les estimations excessives (en minutes)

/**
 * Estime le temps d'attente pour un patient donn√© bas√© sur des heuristiques simples.
 * @param {string} patientId - L'ID du patient d'urgence.
 * @returns {Promise<string>} Une estimation textuelle du temps d'attente (ex: "environ 20-30 minutes").
 * @throws {Error} Si le patient n'est pas trouv√© ou en cas d'erreur.
 */
export const getEstimatedWaitTime = async (patientId) => {
    console.log(`[WaitTime] D√©but estimation pour patient ID: ${patientId}`);
    try {
        const patient = await EmergencyPatient.findById(patientId);
        if (!patient) {
            console.error(`[WaitTime] Patient non trouv√©: ${patientId}`);
            throw new Error("Patient non trouv√©.");
        }

        // 1. Temps de base selon le niveau d'urgence
        // Utiliser 'toLowerCase()' pour la robustesse et g√©rer le cas o√π le niveau est null/undefined
        const emergencyLevel = patient.emergencyLevel?.toLowerCase() || 'default';
        let estimatedTime = BASE_WAIT_TIME_MINUTES[emergencyLevel] || BASE_WAIT_TIME_MINUTES.default;
        console.log(`[WaitTime] Base time for level "${emergencyLevel}": ${estimatedTime.toFixed(0)} min`);

        // 2. Ajustement selon l'heure et le jour
        const submissionTime = new Date(patient.createdAt || Date.now()); // Utiliser createdAt, fallback sur maintenant
        const hour = submissionTime.getHours();
        const day = submissionTime.getDay(); // 0 = Dimanche, 6 = Samedi

        if (hour >= PEAK_HOURS_START && hour < PEAK_HOURS_END) {
            estimatedTime *= PEAK_HOUR_FACTOR;
            console.log(`[WaitTime] Peak hour adjustment applied: ${estimatedTime.toFixed(0)} min`);
        }
        if (day === 0 || day === 6) {
            estimatedTime *= WEEKEND_FACTOR;
            console.log(`[WaitTime] Weekend adjustment applied: ${estimatedTime.toFixed(0)} min`);
        }

        // 3. Ajustement selon la charge (patients en attente)
        // Compter les patients enregistr√©s r√©cemment et non trait√©s/annul√©s
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
        let waitingPatientsCount = 0;
        try {
             waitingPatientsCount = await EmergencyPatient.countDocuments({
                createdAt: { $gte: oneHourAgo },
                 // Statuts consid√©r√©s comme "en attente" ou "en cours"
                status: { $in: ['Demande Enregistr√©e', 'En Cours d\'Examen', 'M√©decin Assign√©', 'M√©decin En Route'] },
                _id: { $ne: patientId } // Exclure le patient actuel du compte
            });
            estimatedTime += waitingPatientsCount * PATIENT_LOAD_FACTOR_PER_PATIENT;
            console.log(`[WaitTime] Load adjustment (+${waitingPatientsCount} waiting patients): ${estimatedTime.toFixed(0)} min`);
        } catch (countError) {
             console.error("[WaitTime] Erreur lors du comptage des patients en attente:", countError);
             // Continuer sans cet ajustement si le comptage √©choue
        }


        // 4. Ajustement (simplifi√©) selon les m√©decins disponibles
        try {
             const availableDoctorsCount = await User.countDocuments({
                 role: 'Doctor',
                 isAvailable: true, // Le champ cl√©
                 isValidated: true // S'assurer qu'ils sont actifs/valid√©s
             });
             console.log(`[WaitTime] M√©decins disponibles: ${availableDoctorsCount}`);
             // Ajustement simple: si peu de m√©decins dispo, le temps peut augmenter l√©g√®rement
             // Si beaucoup de m√©decins dispo, le temps peut diminuer l√©g√®rement
             if (availableDoctorsCount <= 1 && waitingPatientsCount > 0) { // Si peu de m√©decins et charge
                 estimatedTime *= 1.15; // Augmentation modeste
                 console.log(`[WaitTime] Low doctor availability adjustment applied: ${estimatedTime.toFixed(0)} min`);
             } else if (availableDoctorsCount > 3) { // Si > 3 m√©decins dispo
                estimatedTime *= DOCTOR_AVAILABILITY_FACTOR; // R√©duction
                console.log(`[WaitTime] High doctor availability adjustment applied: ${estimatedTime.toFixed(0)} min`);
             }
        } catch (userError) {
            console.error("[WaitTime] Erreur lors de la r√©cup√©ration des m√©decins dispos:", userError);
            // Ne pas planter si la r√©cup√©ration des users √©choue, continuer sans cet ajustement
        }


        // 5. Assurer un temps minimum, appliquer un plafond maximum et arrondir
        estimatedTime = Math.max(MIN_WAIT_TIME, estimatedTime); // Appliquer minimum
        estimatedTime = Math.min(MAX_WAIT_TIME, estimatedTime); // Appliquer maximum
        estimatedTime = Math.round(estimatedTime / 5) * 5; // Arrondir aux 5 minutes les plus proches

        console.log(`[WaitTime] Final estimated (rounded, capped) for ${patientId}: ${estimatedTime} min`);

        // 6. Retourner une fourchette textuelle pour g√©rer l'incertitude
        // Cr√©er une fourchette simple autour du temps estim√©
        const lowerBound = Math.max(MIN_WAIT_TIME, estimatedTime - 5);
        const upperBound = Math.min(MAX_WAIT_TIME, estimatedTime + 10); // Plafonner aussi la borne sup

        // G√©rer le cas o√π la borne inf > sup apr√®s plafonnement
        if (lowerBound >= upperBound) {
            return `environ ${upperBound} minutes`;
        }

        return `environ ${lowerBound}-${upperBound} minutes`;

    } catch (error) {
        // Log l'erreur compl√®te c√¥t√© serveur pour le d√©bogage
        console.error(`[WaitTime] Erreur finale dans getEstimatedWaitTime pour ${patientId}:`, error);
        // Retourner un message g√©n√©rique au client
        return "Estimation indisponible";
    }
};
</file>

<file path="socketManager.js">
import { Server } from 'socket.io';
import Ambulance from './models/Ambulance.js';
import AmbulanceRequest from './models/AmbulanceRequest.js';

let io;

export const initializeSocket = (server) => {
  io = new Server(server, {
    cors: {
      origin: process.env.FRONTEND_URL || "http://localhost:5173",
      methods: ["GET", "POST"]
    }
  });

  io.on('connection', (socket) => {
    console.log('Client connected:', socket.id);

    // Handle patient location updates
    socket.on('updatePatientLocation', async (data) => {
      try {
        const { requestId, latitude, longitude } = data;
        const request = await AmbulanceRequest.findById(requestId);
        
        if (request) {
          request.patient.location = { latitude, longitude };
          await request.save();

          // Update ambulance destination
          const ambulance = await Ambulance.findById(request.ambulance);
          if (ambulance) {
            ambulance.destination = `${latitude},${longitude}`;
            await ambulance.save();
            
            // Notify ambulance about new location
            io.emit(`ambulance_${ambulance._id}`, {
              type: 'LOCATION_UPDATE',
              data: { latitude, longitude }
            });
          }
        }
      } catch (error) {
        console.error('Error updating patient location:', error);
      }
    });

    // Handle new ambulance requests
    socket.on('newAmbulanceRequest', async (data) => {
      try {
        const request = await AmbulanceRequest.create(data);
        
        // Find available ambulance
        const ambulance = await Ambulance.findOne({ status: 'AVAILABLE' });
        
        if (ambulance) {
          request.ambulance = ambulance._id;
          request.status = 'ACCEPTED';
          await request.save();

          ambulance.status = 'ON_MISSION';
          ambulance.destination = `${request.patient.location.latitude},${request.patient.location.longitude}`;
          await ambulance.save();

          // Notify relevant parties
          io.emit('ambulanceRequestUpdate', {
            type: 'NEW_REQUEST',
            data: request
          });

          io.emit(`ambulance_${ambulance._id}`, {
            type: 'NEW_MISSION',
            data: request
          });
        }
      } catch (error) {
        console.error('Error creating ambulance request:', error);
      }
    });

    socket.on('disconnect', () => {
      console.log('Client disconnected:', socket.id);
    });
  });

  return io;
};

export const getIO = () => {
  if (!io) {
    throw new Error('Socket.io not initialized!');
  }
  return io;
};
</file>

<file path="templates/medicalRecordTemplate.html">
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dossier M√©dical - {{patientName}}</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      line-height: 1.6; 
      padding: 20px;
      color: #333;
    }
    .header { 
      text-align: center; 
      margin-bottom: 30px; 
      border-bottom: 2px solid #42A5FF; 
      padding-bottom: 20px; 
    }
    .patient-info { 
      margin-bottom: 30px; 
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
    }
    .file-section { 
      margin-bottom: 30px; 
      border: 1px solid #eee;
      padding: 15px;
      border-radius: 5px;
    }
    .file-header {
      background-color: #f0f7ff;
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
    }
    .logo { 
      max-width: 150px;
      height: auto;
    }
    h1 { color: #42A5FF; }
    h2 { color: #42A5FF; border-bottom: 1px solid #eee; padding-bottom: 5px; }
    h3 { color: #6DDDCF; margin-bottom: 5px; }
    h4 { color: #555; margin-bottom: 5px; margin-top: 15px; }
    hr { border: 0.5px solid #eee; margin: 20px 0; }
    .footer { 
      text-align: center; 
      margin-top: 30px; 
      font-size: 0.8em; 
      color: #777;
      border-top: 1px solid #eee;
      padding-top: 20px;
    }
    .info-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    .info-item {
      margin-bottom: 10px;
    }
    .info-label {
      font-weight: bold;
      color: #555;
      font-size: 0.9em;
    }
    .info-value {
      margin-top: 3px;
    }
    .card {
      border: 1px solid #eee;
      border-radius: 5px;
      padding: 10px;
      margin-bottom: 10px;
      background-color: #fff;
    }
    .card-title {
      font-weight: bold;
      margin-bottom: 5px;
      color: #42A5FF;
    }
    .card-subtitle {
      font-size: 0.8em;
      color: #777;
      margin-bottom: 8px;
    }
    .badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 0.8em;
      font-weight: bold;
    }
    .badge-primary {
      background-color: #E6F3FF;
      color: #42A5FF;
    }
    .badge-secondary {
      background-color: #E6F9F7;
      color: #6DDDCF;
    }
    .badge-warning {
      background-color: #FFF5E6;
      color: #FF9F42;
    }
    .badge-danger {
      background-color: #FFEBEB;
      color: #FF4242;
    }
    .vital-signs-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .vital-sign-card {
      border: 1px solid #eee;
      border-radius: 5px;
      padding: 10px;
      background-color: #f8f9fa;
    }
    .vital-sign-title {
      font-size: 0.8em;
      color: #777;
    }
    .vital-sign-value {
      font-weight: bold;
      font-size: 1.1em;
      color: #333;
    }
    .notes-section {
      background-color: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
      font-style: italic;
    }
    .section-title {
      font-weight: bold;
      margin-bottom: 10px;
      color: #555;
    }
    .allergy-item, .condition-item, .medication-item {
      padding: 8px;
      margin-bottom: 5px;
      border-radius: 5px;
    }
    .allergy-item {
      background-color: #FFEBEB;
      border-left: 3px solid #FF4242;
    }
    .condition-item {
      background-color: #E6F9F7;
      border-left: 3px solid #6DDDCF;
    }
    .medication-item {
      background-color: #E6F3FF;
      border-left: 3px solid #42A5FF;
    }
    .page-break {
      page-break-after: always;
    }
    .confidential {
      text-align: center;
      font-size: 0.7em;
      color: #FF4242;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="header">
    <img src="{{logo}}" class="logo" alt="Logo du site">
    <div class="header-text">
      <h1>Dossier M√©dical √âlectronique</h1>
      <p>Code d'acc√®s: <strong>{{accessCode}}</strong></p>
      <p class="confidential">DOCUMENT CONFIDENTIEL</p>
    </div>
  </div>

  <div class="patient-info">
    <h2>Informations Patient</h2>
    <div class="info-grid">
      <div>
        <div class="info-item">
          <div class="info-label">Nom complet</div>
          <div class="info-value"><strong>{{patientName}}</strong></div>
        </div>
        <div class="info-item">
          <div class="info-label">Date de naissance</div>
          <div class="info-value">{{birthDate}}</div>
        </div>
        <div class="info-item">
          <div class="info-label">Sexe</div>
          <div class="info-value">{{gender}}</div>
        </div>
      </div>
      <div>
        <div class="info-item">
          <div class="info-label">T√©l√©phone</div>
          <div class="info-value">{{phoneNumber}}</div>
        </div>
        <div class="info-item">
          <div class="info-label">Email</div>
          <div class="info-value">{{email}}</div>
        </div>
        <div class="info-item">
          <div class="info-label">Groupe sanguin</div>
          <div class="info-value"><strong>{{bloodType}}</strong></div>
        </div>
      </div>
    </div>
  </div>

  <div class="medical-info">
    <h2>Informations M√©dicales</h2>
    
    {{#if allergies}}
    <h4>Allergies connues :</h4>
    <ul>
      {{#each allergies}}
        <li>{{@index}}. {{this.name}}</li>
      {{/each}}
    </ul>
    {{/if}}
    
    {{#if chronicConditions}}
    <h4>Conditions Chroniques</h4>
    <div>
      {{#each chronicConditions}}
      <div class="condition-item">{{this}}</div>
      {{/each}}
    </div>
    {{/if}}
    
    {{#if medications}}
    <h4>M√©dicaments Actuels</h4>
    <div>
      {{#each medications}}
      <div class="medication-item">
        <div><strong>{{this.name}}</strong></div>
        <div style="font-size: 0.9em;">{{this.dosage}}, {{this.frequency}}</div>
      </div>
      {{/each}}
    </div>
    {{/if}}
  </div>

  {{#if emergencyContact}}
  <div class="emergency-info">
    <h2>Contact d'Urgence</h2>
    <div class="card" style="border-left: 4px solid #FF4242;">
      <div class="info-grid">
        {{#if emergencyContact.name}}
        <div class="info-item">
          <div class="info-label">Nom</div>
          <div class="info-value"><strong>{{emergencyContact.name}}</strong></div>
        </div>
        {{/if}}
        {{#if emergencyContact.relationship}}
        <div class="info-item">
          <div class="info-label">Relation</div>
          <div class="info-value">{{emergencyContact.relationship}}</div>
        </div>
        {{/if}}
        {{#if emergencyContact.phone}}
        <div class="info-item">
          <div class="info-label">T√©l√©phone</div>
          <div class="info-value">{{emergencyContact.phone}}</div>
        </div>
        {{/if}}
      </div>
    </div>
  </div>
  {{/if}}

  <div class="page-break"></div>

  <h2>Documents M√©dicaux</h2>
  {{#each files}}
  <div class="file-section">
    <div class="file-header">
      <h3>{{this.type}}</h3>
      <span>{{this.dateFormatted}}</span>
    </div>

    {{#if this.details.patientInfo}}
    <!-- PatientInformation -->
    <div>
      <h4>Informations Personnelles</h4>
      <div class="info-grid">
        <div>
          {{#if this.details.patientInfo.firstName}}
          <div class="info-item">
            <div class="info-label">Pr√©nom</div>
            <div class="info-value">{{this.details.patientInfo.firstName}}</div>
          </div>
          {{/if}}
          {{#if this.details.patientInfo.lastName}}
          <div class="info-item">
            <div class="info-label">Nom</div>
            <div class="info-value">{{this.details.patientInfo.lastName}}</div>
          </div>
          {{/if}}
          {{#if this.details.patientInfo.dateOfBirth}}
          <div class="info-item">
            <div class="info-label">Date de naissance</div>
            <div class="info-value">{{this.details.patientInfo.dateOfBirth}}</div>
          </div>
          {{/if}}
        </div>
        <div>
          {{#if this.details.patientInfo.gender}}
          <div class="info-item">
            <div class="info-label">Genre</div>
            <div class="info-value">{{this.details.patientInfo.gender}}</div>
          </div>
          {{/if}}
          {{#if this.details.patientInfo.phoneNumber}}
          <div class="info-item">
            <div class="info-label">T√©l√©phone</div>
            <div class="info-value">{{this.details.patientInfo.phoneNumber}}</div>
          </div>
          {{/if}}
          {{#if this.details.patientInfo.email}}
          <div class="info-item">
            <div class="info-label">Email</div>
            <div class="info-value">{{this.details.patientInfo.email}}</div>
          </div>
          {{/if}}
        </div>
      </div>

      {{#if this.details.patientInfo.medicalHistory}}
      <h4>Ant√©c√©dents M√©dicaux</h4>
      <div class="card">
        {{this.details.patientInfo.medicalHistory}}
      </div>
      {{/if}}

      {{#if this.details.patientInfo.currentSymptoms}}
      <h4>Sympt√¥mes Actuels</h4>
      <div class="card">
        {{this.details.patientInfo.currentSymptoms}}
      </div>
      {{/if}}

      <div class="info-grid">
        {{#if this.details.patientInfo.painLevel}}
        <div class="info-item">
          <div class="info-label">Niveau de douleur</div>
          <div class="info-value"><strong>{{this.details.patientInfo.painLevel}}/10</strong></div>
        </div>
        {{/if}}
        {{#if this.details.patientInfo.emergencyLevel}}
        <div class="info-item">
          <div class="info-label">Niveau d'urgence</div>
          <div class="info-value"><strong>{{this.details.patientInfo.emergencyLevel}}</strong></div>
        </div>
        {{/if}}
      </div>
    </div>
    {{/if}}

    {{#if this.details.diagnosis}}
    <!-- Diagnostic -->
    <div>
      <h4>Diagnostic Principal</h4>
      <div class="card">
        {{this.details.diagnosis}}
      </div>

      {{#if this.details.diagnosticTests}}
      <h4>Tests Diagnostiques</h4>
      {{#each this.details.diagnosticTests}}
      <div class="card">
        <div class="card-title">{{this.testName}}</div>
        <div class="card-subtitle">{{this.dateFormatted}}</div>
        <div><strong>R√©sultat:</strong> {{this.result}}</div>
      </div>
      {{/each}}
      {{/if}}
    </div>
    {{/if}}

    {{#if this.details.procedures}}
    <!-- Treatment -->
    <div>
      <h4>Proc√©dures</h4>
      {{#each this.details.procedures}}
      <div class="card">
        <div class="card-title">{{this.name}}</div>
        <div class="card-subtitle">{{this.dateFormatted}}</div>
        {{#if this.notes}}
        <div><strong>Notes:</strong> {{this.notes}}</div>
        {{/if}}
      </div>
      {{/each}}
    </div>
    {{/if}}

    {{#if this.details.vitalSigns}}
    <!-- VitalSigns -->
    <div>
      <h4>Signes Vitaux</h4>
      <div class="vital-signs-grid">
        {{#if this.details.vitalSigns.temperature}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Temp√©rature</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.temperature}} ¬∞C</div>
        </div>
        {{/if}}
        
        {{#if this.details.vitalSigns.bloodPressure}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Pression art√©rielle</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.bloodPressure.systolic}}/{{this.details.vitalSigns.bloodPressure.diastolic}} mmHg</div>
        </div>
        {{/if}}
        
        {{#if this.details.vitalSigns.heartRate}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Fr√©quence cardiaque</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.heartRate}} bpm</div>
        </div>
        {{/if}}
        
        {{#if this.details.vitalSigns.respiratoryRate}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Fr√©quence respiratoire</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.respiratoryRate}} resp/min</div>
        </div>
        {{/if}}
        
        {{#if this.details.vitalSigns.oxygenSaturation}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Saturation en oxyg√®ne</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.oxygenSaturation}}%</div>
        </div>
        {{/if}}
      </div>
    </div>
    {{/if}}

    {{#if this.details.priorityLevel}}
    <!-- Triage -->
    <div>
      <h4>Niveau de Priorit√©</h4>
      <div class="card">
        <div><strong>{{this.details.priorityLevel}}</strong></div>
      </div>
      
      {{#if this.details.chiefComplaint}}
      <h4>Plainte Principale</h4>
      <div class="card">
        {{this.details.chiefComplaint}}
      </div>
      {{/if}}
    </div>
    {{/if}}

    {{#if this.details.dischargeInstructions}}
    <!-- Discharge -->
    <div>
      <h4>Instructions de Sortie</h4>
      <div class="card">
        {{this.details.dischargeInstructions}}
      </div>
      
      {{#if this.details.followUpDate}}
      <h4>Rendez-vous de Suivi</h4>
      <div class="card">
        {{this.details.followUpDateFormatted}}
      </div>
      {{/if}}
    </div>
    {{/if}}

    {{#if this.details.medications}}
    <!-- Prescription or medications from other types -->
    <div>
      <h4>M√©dicaments</h4>
      {{#each this.details.medications}}
      <div class="card">
        <div class="card-title">{{this.name}}</div>
        <div><strong>Dosage:</strong> {{this.dosage}}</div>
        <div><strong>Fr√©quence:</strong> {{this.frequency}}</div>
        {{#if this.duration}}
        <div><strong>Dur√©e:</strong> {{this.duration}}</div>
        {{/if}}
      </div>
      {{/each}}
    </div>
    {{/if}}

    {{#if this.notes}}
    <div class="notes-section">
      <div class="section-title">Notes</div>
      {{this.notes}}
    </div>
    {{/if}}
  </div>

  {{#unless @last}}
  <hr>
  {{/unless}}
  {{/each}}

  <div class="footer">
    <p>Document g√©n√©r√© le {{currentDate}}</p>
    <p>Ce document est strictement confidentiel et prot√©g√© par le secret m√©dical.</p>
  </div>
</body>
</html>
</file>

<file path="utils/pdfGenerator.js">
import pdf from "html-pdf-node"
import fs from "fs"
import path from "path"
import { fileURLToPath } from "url"
import Handlebars from "handlebars"

const __dirname = path.dirname(fileURLToPath(import.meta.url))

// Fonction pour formater une date
const formatDate = (dateString) => {
  if (!dateString) return "Non sp√©cifi√©"
  return new Date(dateString).toLocaleDateString("fr-FR", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  })
}

// Enregistrer les helpers Handlebars
Handlebars.registerHelper("if", function (conditional, options) {
  if (conditional) {
    return options.fn(this)
  } else {
    return options.inverse(this)
  }
})

Handlebars.registerHelper("unless", function (conditional, options) {
  if (!conditional) {
    return options.fn(this)
  } else {
    return options.inverse(this)
  }
})

Handlebars.registerHelper("each", (context, options) => {
  let ret = ""

  for (let i = 0, j = context.length; i < j; i++) {
    // Ajouter une propri√©t√© @index et @last
    context[i]["@index"] = i
    context[i]["@last"] = i === context.length - 1
    ret = ret + options.fn(context[i])
  }

  return ret
})

export const generateMedicalRecordPDF = async (medicalRecord, patientFiles) => {
  const templatePath = path.join(__dirname, "../../backend/templates/medicalRecordTemplate.html")
  const logoPath = path.join(__dirname, "../../backend/utils/logo1.png")

  // Formatage des donn√©es
  const currentDate = formatDate(new Date())

  // Lire le logo et le convertir en base64
  const logoBuffer = fs.readFileSync(logoPath)
  const base64Logo = logoBuffer.toString("base64")
  const logoDataURI = `data:image/png;base64,${base64Logo}`

  // Pr√©parer les fichiers avec des dates format√©es
  const formattedFiles = patientFiles.map((file) => {
    // Cr√©er une copie profonde du fichier pour √©viter de modifier l'original
    const formattedFile = JSON.parse(JSON.stringify(file))

    // Formater la date d'enregistrement
    formattedFile.dateFormatted = formatDate(file.dateRecorded)

    // Formater les dates dans les tests diagnostiques
    if (file.details?.diagnosticTests?.length > 0) {
      formattedFile.details.diagnosticTests.forEach((test) => {
        test.dateFormatted = formatDate(test.date)
      })
    }

    // Formater les dates dans les proc√©dures
    if (file.details?.procedures?.length > 0) {
      formattedFile.details.procedures.forEach((procedure) => {
        procedure.dateFormatted = formatDate(procedure.date)
      })
    }

    // Formater la date de suivi
    if (file.details?.followUpDate) {
      formattedFile.details.followUpDateFormatted = formatDate(file.details.followUpDate)
    }

    return formattedFile
  })

  // Pr√©parer les donn√©es pour le template
  const templateData = {
    logo: logoDataURI,
    patientName: `${medicalRecord.patientId?.firstName || ""} ${medicalRecord.patientId?.lastName || ""}`,
    birthDate: formatDate(medicalRecord.patientId?.dateOfBirth),
    gender: medicalRecord.patientId?.gender || "Non sp√©cifi√©",
    phoneNumber: medicalRecord.patientId?.phoneNumber || "Non sp√©cifi√©",
    email: medicalRecord.patientId?.email || "Non sp√©cifi√©",
    bloodType: medicalRecord.bloodType || "Non sp√©cifi√©",
    accessCode: medicalRecord.accessCode,
    currentDate: currentDate,
    allergies: medicalRecord.knownAllergies?.map(allergy => ({ name: allergy })) || null,
    chronicConditions: medicalRecord.chronicConditions?.map(condition => ({ name: condition })) || null,
    medications: medicalRecord.currentMedications?.map(med => ({
      name: med.name,
      dosage: med.dosage,
      frequency: med.frequency
    })) || null,
        emergencyContact: medicalRecord.emergencyContact || null,
    files: formattedFiles,
  }

  // Lire le template
  const templateSource = fs.readFileSync(templatePath, "utf8")

  // Compiler le template avec Handlebars
  const template = Handlebars.compile(templateSource)

  // G√©n√©rer le HTML final
  const html = template(templateData)

  const options = {
    format: "A4",
    printBackground: true,
    margin: {
      top: "10mm",
      right: "10mm",
      bottom: "10mm",
      left: "10mm",
    },
    displayHeaderFooter: false,
  }

  return new Promise((resolve, reject) => {
    pdf.generatePdf({ content: html }, options, (err, buffer) => {
      if (err) reject(err)
      else resolve(buffer)
    })
  })
}
</file>

<file path="utils/pdfProcessor.js">
// utils/pdfProcessor.js
import fs from 'fs-extra';
import path from 'path';
import { PDFDocument } from 'pdf-lib';
import { exec } from 'child_process';
import util from 'util';
import sharp from 'sharp';

const execPromise = util.promisify(exec);

export const convertPDFToImages = async (pdfPath) => {
  try {
    const outputDir = path.join(path.dirname(pdfPath), 'temp_images');
    await fs.ensureDir(outputDir); // Cr√©er le dossier temporaire
    
    // Utiliser le chemin absolu pour Ghostscript
    const absolutePdfPath = path.resolve(pdfPath);
    
    const { stdout, stderr } = await execPromise(
      `gs -dNOPAUSE -sDEVICE=png16m -r300 -sOutputFile="${path.join(outputDir, 'page-%d.png')}" "${absolutePdfPath}" -dBATCH`
    );


    const files = await fs.readdir(tempDir);
    const imagePaths = files
      .filter(file => file.endsWith('.png'))
      .map(file => path.join(tempDir, file))
      .sort();

    // Optimiser les images pour l'OCR
    const optimizedImages = [];
    for (const imgPath of imagePaths) {
      const optimizedPath = imgPath.replace('.png', '-optimized.png');
      await sharp(imgPath)
        .normalize()  // Am√©liore le contraste
        .linear(1.1, -(128 * 0.1))  // Ajuste la luminosit√©
        .threshold(128, { grayscale: true })  // Binarisation pour certains documents
        .toFile(optimizedPath);
      optimizedImages.push(optimizedPath);
    }

    return optimizedImages;
  } catch (error) {
    console.error('Erreur lors de la conversion PDF en images:', error);
    throw error;
  }
};
</file>

<file path="utils/textParser.js">
// utils/textParser.js
export const extractMedicalData = (text) => {
  const result = {
    patientName: '',
    diagnosis: '',
    tests: [],
    treatments: []
  };

  // Extraire le nom du patient
  const nameMatch = text.match(/Nom et pr√©nom:\s*(.+)/i);
  if (nameMatch) {
    result.patientName = nameMatch[1].trim();
  }

  // Extraire le diagnostic
  const diagnosisMatch = text.match(/DIAGNOSTIQUE\s*([^\n]+)/i);
  if (diagnosisMatch) {
    result.diagnosis = diagnosisMatch[1].trim();
  }

  // Extraire les r√©sultats de test
  const resultMatch = text.match(/RESULTAT\s*([^\n]+)/i);
  if (resultMatch) {
    result.tests.push({
      testName: 'R√©sultats diagnostiques',
      result: resultMatch[1].trim(),
      date: new Date()
    });
  }

  return result;
};
</file>

</files>
