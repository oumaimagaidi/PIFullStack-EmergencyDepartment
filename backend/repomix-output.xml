This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.babelrc
config/tesseract.config.js
db.js
middleware/authMiddleware.js
middleware/fileUpload.js
middleware/uploadMiddleware.js
models/Alert.js
models/Ambulance.js
models/Annotation.js
models/AuditLog.js
models/EmergencyPatient.js
models/MedicalRecord.js
models/Notification.js
models/OcrResult.js
models/PatientFile.js
models/pdfGenerator.js
models/Resource.js
models/SharedMedicalRecord.js
models/User.js
package.json
routes/ai.js
routes/alerts.js
routes/ambulance.js
routes/annotation.js
routes/archive.js
routes/auth copy.js
routes/auth.js
routes/chatbot.js
routes/emergencyPatients.js
routes/medicalRecords.js
routes/notifications.js
routes/ocr.js
routes/patient.js
routes/patientFile.js
routes/profile.js
routes/resource.js
routes/users.js
sendSMS.js
server.js
services/aiService.js
services/chatbotService.js
services/classifierService.js
services/emailService.js
services/ocrService.js
services/otpService.js
services/simpleSymptomHelper.js
services/waitTimeService.js
templates/medicalRecordTemplate.html
utils/pdfGenerator.js
utils/pdfProcessor.js
utils/textParser.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".babelrc">
{
    "presets": ["@babel/preset-env"]
  }
</file>

<file path="config/tesseract.config.js">
import multer from "multer";
import { v4 as uuidv4 } from "uuid";
import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    try {
      const uploadPath = path.resolve(__dirname, "../../../uploads/pdfs");
      await fs.ensureDir(uploadPath);
      cb(null, uploadPath);
    } catch (err) {
      cb(err);
    }
  },
  filename: (req, file, cb) => {
    const uniqueName = `${uuidv4()}${path.extname(file.originalname)}`;
    cb(null, uniqueName);
  }
});

const fileFilter = (req, file, cb) => {
  if (file.mimetype === "application/pdf") {
    cb(null, true);
  } else {
    cb(new Error("Seuls les fichiers PDF sont autoris√©s"), false);
  }
};

export const uploadPDF = multer({
  storage,
  fileFilter,
  limits: { fileSize: 25 * 1024 * 1024 } // 25MB
});
</file>

<file path="db.js">
import mongoose from "mongoose";

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log("Connected to database successfully");
  } catch (error) {
    console.error("Could not connect to database!", error);
    process.exit(1);
  }
};

export default connectDB;
</file>

<file path="middleware/authMiddleware.js">
import jwt from "jsonwebtoken";
import dotenv from "dotenv";

dotenv.config();

export const authenticateToken = (req, res, next) => {
  // Try to get the token from cookies first, then check Authorization header
  const token = req.cookies?.token || req.header("Authorization")?.split(" ")[1];
  if (!token) {
    return res.status(401).json({ message: "Acc√®s refus√©, aucun token fourni" });
  }

  try {
    const verified = jwt.verify(token, process.env.JWT_SECRET);
    req.user = verified; // Attach user data to request object
    next();
  } catch (error) {
    return res.status(403).json({ message: "Token invalide", error });
  }
};
export const authorize = (roles) => {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s interdit : r√¥le non autoris√©" });
    }
    next();
  };
};
</file>

<file path="middleware/fileUpload.js">
import multer from 'multer';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs-extra';

// Configuration __dirname pour ES Modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Configuration stockage pour images
const imageStorage = multer.diskStorage({
  destination: async (req, file, cb) => {
    try {
      const uploadDir = join(__dirname, '../uploads/images');
      await fs.ensureDir(uploadDir);
      cb(null, uploadDir);
    } catch (error) {
      cb(error);
    }
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  }
});

// Middleware d'upload pour images
export const uploadImage = multer({
  storage: imageStorage,
  fileFilter: (req, file, cb) => {
    const allowedMimeTypes = [
      'image/jpeg',
      'image/png',
      'image/webp'
    ];

    if (allowedMimeTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Type de fichier non autoris√©. Seules les images JPEG, PNG et WebP sont accept√©es.'));
    }
  },
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  }
});
</file>

<file path="middleware/uploadMiddleware.js">
import multer from "multer";
import path from "path";

// Configuration de Multer
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "uploads/"); // Dossier o√π enregistrer les images
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname)); // Nom unique
  },
});

const upload = multer({ storage: storage });

export default upload;
</file>

<file path="models/Alert.js">
import mongoose from "mongoose";

const AlertSchema = new mongoose.Schema({
  message: {
    type: String,
    required: true,
  },
  // optional free‚Äëform source identifier (e.g. "Ambulance #123", "System", etc.)
  source: {
    type: String,
    default: null,
  },
  timestamp: {
    type: Date,
    default: Date.now,
  },
});

export default mongoose.model("Alert", AlertSchema);
</file>

<file path="models/Ambulance.js">
import mongoose from 'mongoose';

const AmbulanceSchema = new mongoose.Schema({
  name : { type: String, required: true },
  latitude: { type: Number, required: true },
  longitude: { type: Number, required: true },
  status: { 
    type: String, 
    enum: ['OFF_DUTY', 'AVAILABLE', 'ON_MISSION', 'MAINTENANCE'], 
    required: true 
  },
  drivers: [{
    type: String,
    ref: "Driver",
    required: true
  }],
    mobile: {
    type: String,
    required: [true, "Mobile number is required"],
    match: [/^[0-9]{8,15}$/, "Please enter a valid mobile number (8-15 digits)"],
    unique: true
  },
  
  destination: { type: String, default: null },
  lastUpdated: { type: Date, default: Date.now },
  team: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
}); 

const Ambulance = mongoose.model('Ambulance', AmbulanceSchema);
export default Ambulance;
</file>

<file path="models/Annotation.js">
import mongoose from "mongoose"

const AnnotationSchema = new mongoose.Schema(
  {
    patientFileId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "PatientFile",
      required: true,
    },
    authorId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    text: {
      type: String,
      required: true,
    },
    position: {
      x: Number,
      y: Number,
    },
    type: {
      type: String,
      enum: ["comment", "highlight", "warning", "question"],
      default: "comment",
    },
    color: {
      type: String,
      default: "#FFD700", // Default yellow color
    },
    isResolved: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true },
)

export default mongoose.model("Annotation", AnnotationSchema)
</file>

<file path="models/AuditLog.js">
import mongoose from "mongoose";

const AuditLogSchema = new mongoose.Schema(
  {
    action: {
      type: String,
      required: true,
    },
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    details: {
      type: String,
      required: true,
    },
  },
  { timestamps: true }
);

export default mongoose.model("AuditLog", AuditLogSchema);
</file>

<file path="models/EmergencyPatient.js">
// backend/models/EmergencyPatient.js
import mongoose from 'mongoose';
import { v4 as uuidv4 } from 'uuid';

const emergencyPatientSchema = new mongoose.Schema({
    firstName: { type: String, required: true },
    lastName: { type: String, required: true },
    dateOfBirth: { type: String, required: true },
    gender: { type: String, required: true, enum: ['male', 'female', 'other'] },
    phoneNumber: { type: String, required: true },
    email: {
        type: String,
        validate: {
            validator: function (v) {
                return /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(v);
            },
            message: props => `${props.value} is not a valid email address!`
        }
    },
    address: { type: String, required: true },
    emergencyContact: { type: String, required: true },
    insuranceInfo: { type: String },
    allergies: { type: String },
    currentMedications: { type: String },
    medicalHistory: { type: String },
    currentSymptoms: { type: String, required: true },
    painLevel: { type: String, required: true, enum: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'] },
    emergencyLevel: { type: String, required: true, enum: ['low', 'medium', 'high', 'critical'] },
    status: { type: String, default: 'Demande Enregistr√©e' },
    assignedDoctor: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        default: null
    },
    medicalRecord: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'MedicalRecord',
        default: null,
    },
    patientCode: { 
        type: String, 
        unique: true,
        default: () => `EMP-${uuidv4().substr(0, 8).toUpperCase()}`
    },
    isNewPatient: { type: Boolean, default: true },
    previousVisits: [{
        visitDate: { type: Date, default: Date.now },
        symptoms: String,
        treatment: String,
        doctor: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
    }],
    createdAt: { type: Date, default: Date.now },
    arrivalTime: { type: Date, default: Date.now }
}, { timestamps: true });

// M√©thode pour trouver un patient existant
emergencyPatientSchema.statics.findExistingPatient = async function(firstName, lastName, email) {
    return this.findOne({ 
        firstName: { $regex: new RegExp(`^${firstName}$`, 'i') },
        lastName: { $regex: new RegExp(`^${lastName}$`, 'i') },
        email: { $regex: new RegExp(`^${email}$`, 'i') }
    }).populate('medicalRecord');
};
// Nouvelle m√©thode pour les statistiques par niveau d'urgence
emergencyPatientSchema.statics.getEmergencyLevelStats = async function() {
    return this.aggregate([
        {
            $group: {
                _id: "$emergencyLevel",
                count: { $sum: 1 },
                // Vous pouvez ajouter d'autres statistiques ici si n√©cessaire
                averagePainLevel: { $avg: { $toDouble: "$painLevel" } }
            }
        },
        {
            $project: {
                emergencyLevel: "$_id",
                count: 1,
                averagePainLevel: 1,
                _id: 0
            }
        },
        {
            $sort: { 
                emergencyLevel: 1 
            }
        }
    ]);
};

// M√©thode pour les statistiques temporelles (optionnelle)
emergencyPatientSchema.statics.getEmergencyTrends = async function(timePeriod = 'day') {
    let groupFormat;
    
    switch (timePeriod) {
        case 'hour':
            groupFormat = { hour: { $hour: "$createdAt" } };
            break;
        case 'day':
            groupFormat = { day: { $dayOfMonth: "$createdAt" }, month: { $month: "$createdAt" }, year: { $year: "$createdAt" } };
            break;
        case 'month':
            groupFormat = { month: { $month: "$createdAt" }, year: { $year: "$createdAt" } };
            break;
        default:
            groupFormat = { day: { $dayOfMonth: "$createdAt" }, month: { $month: "$createdAt" }, year: { $year: "$createdAt" } };
    }

    return this.aggregate([
        {
            $group: {
                _id: groupFormat,
                total: { $sum: 1 },
                levels: {
                    $push: {
                        level: "$emergencyLevel",
                        pain: "$painLevel"
                    }
                }
            }
        },
        { $sort: { "_id": 1 } }
    ]);
};
const EmergencyPatient = mongoose.model('EmergencyPatient', emergencyPatientSchema);

export default EmergencyPatient;
</file>

<file path="models/MedicalRecord.js">
// backend/models/MedicalRecord.js
import mongoose from "mongoose";
import { v4 as uuidv4 } from 'uuid';

const medicalRecordSchema = new mongoose.Schema({
    patientId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'EmergencyPatient',
        required: true,
    },
    creator: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
        required: true,
    },
    accessCode: {
        type: String,
        unique: true,
        default: () => `MR-${uuidv4().substr(0, 8).toUpperCase()}`
    },
    emergencyContact: {
        name: String,
        relationship: String,
        phone: String,
    },
    bloodType: {
        type: String,
        enum: ["A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-"],
    },
    knownAllergies: [String],
    chronicConditions: [String],
    currentMedications: [
        {
            name: String,
            dosage: String,
            frequency: String,
        },
    ],
    lastUpdated: {
        type: Date,
        default: Date.now,
    },
    
}, { 
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// ... autres m√©thodes et virtuals ...
medicalRecordSchema.virtual('patientFiles', {
    ref: 'PatientFile',
    localField: '_id',
    foreignField: 'medicalRecord'
  });
const MedicalRecord = mongoose.model("MedicalRecord", medicalRecordSchema);
export default MedicalRecord;
</file>

<file path="models/Notification.js">
// models/Notification.js
import mongoose from 'mongoose';

const NotificationSchema = new mongoose.Schema({
    recipientId: { // L'ID de l'utilisateur qui doit recevoir la notification
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true, // Important pour les requ√™tes
    },
    message: {
        type: String,
        required: true,
    },
    type: { // Ex: 'doctor_assignment', 'patient_status_update', 'new_emergency_case'
        type: String,
        enum: ['doctor_assignment', 'patient_status_update', 'new_emergency_case', 'ambulance_alert', 'generic'], // Ajoutez d'autres types si besoin
        default: 'generic',
    },
    relatedEntityId: { // ID du patient, de l'urgence, etc. li√© √† la notification
        type: mongoose.Schema.Types.ObjectId,
        default: null,
    },
    relatedEntityType: { // 'EmergencyPatient', 'Ambulance', etc.
        type: String,
        default: null
    },
    isRead: {
        type: Boolean,
        default: false,
    },
    createdAt: {
        type: Date,
        default: Date.now,
        expires: '30d' // Optionnel: les notifications expirent apr√®s 30 jours
    },
});

export default mongoose.model('Notification', NotificationSchema);
</file>

<file path="models/OcrResult.js">
import mongoose from "mongoose";

const ocrResultSchema = new mongoose.Schema({
  medicalRecord: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "MedicalRecord",
    required: true,
  },
  originalFilename: {
    type: String,
    required: true,
  },
  textResult: {
    type: String,
    required: true,
  },
  extractedData: {
    patientName: String,
    diagnosis: String,
    tests: [
      {
        testName: String,
        result: String,
        date: Date,
      },
    ],
    treatments: [
      {
        name: String,
        dosage: String,
        frequency: String,
      },
    ],
    confidence: Number,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

export default mongoose.model("OcrResult", ocrResultSchema);
</file>

<file path="models/PatientFile.js">
import mongoose from "mongoose";

const patientFileSchema = new mongoose.Schema(
  {
    medicalRecord: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "MedicalRecord",
      required: true,
    },
    ocrResults: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'OcrResult'
    },
    isOCRProcessed: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      required: true,
      enum: [
        "Triage",
        "Diagnostic",
        "Treatment",
        "VitalSigns",
        "Discharge",
        "Prescription",
        "PatientInformation",
      ],
    },

    notes: String,

    dateRecorded: {
      type: Date,
      default: Date.now,
    },

    // D√©tails sp√©cifiques selon le type
    details: {
      priorityLevel: {
        type: String,
        enum: ["Resuscitation", "Emergency", "Urgent", "Semi-urgent", "Non-urgent"],
      },
      treatments: [{
        name: String,
        dosage: String,
        frequency: String,
        startDate: Date,
        endDate: Date
      }],
      chiefComplaint: String,

      diagnosis: String,
      diagnosticTests: [
        {
          testName: String,
          result: String,
          date: Date,
        },
      ],

      procedures: [
        {
          name: String,
          date: Date,
          notes: String,
        },
      ],

      vitalSigns: {
        temperature: Number,
        bloodPressure: {
          systolic: Number,
          diastolic: Number,
        },
        heartRate: Number,
        respiratoryRate: Number,
        oxygenSaturation: Number,
      },

      dischargeInstructions: String,
      followUpDate: Date,

      medications: [
        {
          name: String,
          dosage: String,
          frequency: String,
          duration: String,
        },
      ],

      patientInfo: {
        firstName: String,
        lastName: String,
        dateOfBirth: String,
        gender: String,
        phoneNumber: String,
        email: String,
        address: String,
        emergencyContact: String,
        insuranceInfo: String,
        allergies: String,
        currentMedications: String,
        medicalHistory: String,
        currentSymptoms: String,
        painLevel: String,
        emergencyLevel: String,
      },
    },

    // üîí ARCHIVAGE
    isArchived: {
      type: Boolean,
      default: false,
    },
    archivedAt: {
      type: Date,
      default: null,
    },
    archivedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      default: null,
    },
    archiveReason: {
      type: String,
      default: null,
    },

    restoredAt: {
      type: Date,
      default: null,
    },
    restoredBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      default: null,
    },
    restoreReason: {
      type: String,
      default: null,
    },
  },
  { timestamps: true }
);

// M√©thodes personnalis√©es
patientFileSchema.methods.updateFile = function (updateData) {
  console.log(`Updating patient file ${this._id}`);
};

patientFileSchema.methods.getFileType = function () {
  return this.type;
};

const PatientFile = mongoose.model("PatientFile", patientFileSchema);

export default PatientFile;
</file>

<file path="models/pdfGenerator.js">
// backend/utils/pdfGenerator.js
import pdf from 'html-pdf-node';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export const generateMedicalRecordPDF = async (medicalRecord, patientFiles) => {
  const templatePath = path.join(__dirname, '../templates/medicalRecordTemplate.html');
  let template = fs.readFileSync(templatePath, 'utf8');

  // Formatage des donn√©es pour le template
  const patientName = `${medicalRecord.patientId?.firstName} ${medicalRecord.patientId?.lastName}`;
  const birthDate = new Date(medicalRecord.patientId?.dateOfBirth).toLocaleDateString('fr-FR');
  
  // Remplacement des placeholders dans le template
  template = template
    .replace('{{patientName}}', patientName)
    .replace('{{birthDate}}', birthDate)
    .replace('{{bloodType}}', medicalRecord.bloodType || 'Non sp√©cifi√©')
    .replace('{{accessCode}}', medicalRecord.accessCode);

  // G√©n√©ration des fichiers m√©dicaux
  let filesHtml = '';
  patientFiles.forEach(file => {
    filesHtml += `
      <div class="file-section">
        <h3>${file.type}</h3>
        <p>Cr√©√© le: ${new Date(file.createdAt).toLocaleDateString('fr-FR')}</p>
        ${file.notes ? `<p>Notes: ${file.notes}</p>` : ''}
      </div>
      <hr>
    `;
  });
  template = template.replace('{{files}}', filesHtml);

  const options = { format: 'A4' };
  const buffer = await new Promise((resolve, reject) => {
    pdf.generatePdf({ content: template }, options, (err, buffer) => {
      if (err) reject(err);
      else resolve(buffer);
    });
  });

  return buffer;
};
</file>

<file path="models/Resource.js">
import mongoose from "mongoose";

const resourceSchema = new mongoose.Schema({
  type: { type: String, required: true },       // e.g. 'bed', 'ventilator'
  name: { type: String, required: true },       // e.g. 'ICU Bed 1'
  quantity: { type: Number, required: true, min: 0 },
  location: { type: String, required: true },   
  status: { type: String, required: true, enum: ['available','in-maintenance'] },
  allocatedTo: { type: mongoose.Schema.Types.ObjectId, ref: 'Patient', default: null },

}, { timestamps: true });

export default mongoose.model('Resource', resourceSchema);
</file>

<file path="models/SharedMedicalRecord.js">
import mongoose from "mongoose";

const SharedMedicalRecordSchema = new mongoose.Schema(
  {
    medicalRecordId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "MedicalRecord",
      required: true,
    },
    sharerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    recipientId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    note: {
      type: String,
      default: "",
    },
    sharedAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true }
);

export default mongoose.model("SharedMedicalRecord", SharedMedicalRecordSchema);
</file>

<file path="models/User.js">
import mongoose from "mongoose";

const options = { discriminatorKey: "role", timestamps: true };

// D√©finition du sch√©ma de base User
const UserSchema = new mongoose.Schema(
	{
		username: { type: String, required: true, unique: true },
		email: { type: String, required: true, unique: true },
		password: { type: String, required: true },
		phoneNumber: { type: String, required: true },
		role: { type: String, required: true, enum: ["Patient", "Doctor", "Nurse", "Administrator"] },
		isValidated: { type: Boolean, default: false }, // Nouveau champ
		profileImage: { type: String },
		resetPasswordToken: String, // Nouveau champ
		resetPasswordExpires: Date, // Nouveau champ
		otp: { type: String, required: false, default: 0 },
		otpExpires: Date,
	},
	options
);
// M√©thodes communes
UserSchema.methods.login = function () {
	console.log(`${this.username} logged in.`);
};

UserSchema.methods.logout = function () {
	console.log(`${this.username} logged out.`);
};

UserSchema.methods.updateProfile = function () {
	console.log(`${this.username} updated profile.`);
};

UserSchema.methods.resetPassword = function () {
	console.log(`${this.username} reset password.`);
};

const User = mongoose.model("User", UserSchema);

// ------------------- Patient -------------------
const PatientSchema = new mongoose.Schema({
	name: { type: String, required: true },
	dateOfBirth: { type: Date, required: true },
	gender: { type: String, required: true, enum: ["Male", "Female", "Other"] },
	address: { type: String, required: true },
	emergencyContact: { type: String, required: true },
	bloodType: { type: String, required: true },
	allergies: [{ type: String }],
});

PatientSchema.methods.registerPatient = function () {
	console.log(`Patient ${this.name} registered.`);
};

PatientSchema.methods.updatePatientInfo = function () {
	console.log(`Patient ${this.name} info updated.`);
};

PatientSchema.methods.viewMedicalHistory = function () {
	console.log(`Viewing medical history of ${this.name}.`);
};

const Patient = User.discriminator("Patient", PatientSchema);

// ------------------- Doctor -------------------
const DoctorSchema = new mongoose.Schema({
	badgeNumber: { type: String, required: true },
	specialization: { type: String, required: true },
	licenseNumber: { type: String, required: true },
	isAvailable: { type: Boolean, default: true }, // New field
});

DoctorSchema.methods.assignTreatment = function () {
	console.log(`Doctor ${this.username} assigned treatment.`);
};

DoctorSchema.methods.changePatientStatus = function () {
	console.log(`Doctor ${this.username} changed patient status.`);
};

DoctorSchema.methods.assignResources = function () {
	console.log(`Doctor ${this.username} assigned resources.`);
};

DoctorSchema.methods.prescribeMedication = function () {
	console.log(`Doctor ${this.username} prescribed medication.`);
};

DoctorSchema.methods.viewSchedule = function () {
	console.log(`Doctor ${this.username} viewing schedule.`);
};

const Doctor = User.discriminator("Doctor", DoctorSchema);

// ------------------- Nurse -------------------
const NurseSchema = new mongoose.Schema({
	badgeNumber: { type: String, required: true },
	shift: { type: String, required: true },
	licenseNumber: { type: String, required: true },
});

NurseSchema.methods.addMedicalNotes = function () {
	console.log(`Nurse ${this.username} added medical notes.`);
};

NurseSchema.methods.assignPatientPriority = function () {
	console.log(`Nurse ${this.username} assigned patient priority.`);
};

NurseSchema.methods.updatePatientAllocation = function () {
	console.log(`Nurse ${this.username} updated patient allocation.`);
};

NurseSchema.methods.administerMedication = function () {
	console.log(`Nurse ${this.username} administered medication.`);
};

NurseSchema.methods.viewSchedule = function () {
	console.log(`Nurse ${this.username} viewing schedule.`);
};

const Nurse = User.discriminator("Nurse", NurseSchema);

// ------------------- Administrator -------------------
const AdminSchema = new mongoose.Schema({
	badgeNumber: { type: String, required: true },
});

AdminSchema.methods.manageResources = function () {
	console.log(`Administrator ${this.username} managing resources.`);
};

AdminSchema.methods.allocateNurses = function () {
	console.log(`Administrator ${this.username} allocating nurses.`);
};

AdminSchema.methods.allocateDoctors = function () {
	console.log(`Administrator ${this.username} allocating doctors.`);
};

AdminSchema.methods.calculateResourceUtilization = function () {
	console.log(`Administrator ${this.username} calculating resource utilization.`);
};

const Administrator = User.discriminator("Administrator", AdminSchema);

export { User, Patient, Doctor, Nurse, Administrator };
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "description": "",
  "dependencies": {
    "@huggingface/inference": "^3.9.2",
    "@tensorflow/tfjs": "^4.22.0",
    "@xenova/transformers": "^2.17.2",
    "bcrypt": "^5.1.1",
    "bcryptjs": "^3.0.0",
    "canvas": "^3.1.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "cross-env": "^7.0.3",
    "dotenv": "^16.5.0",
    "express": "^4.21.2",
    "express-fileupload": "^1.5.1",
    "fs-extra": "^11.3.0",
    "google-auth-library": "^9.15.1",
    "html-pdf-node": "^1.0.8",
    "joi": "^17.13.3",
    "joi-password-complexity": "^5.2.0",
    "jsonwebtoken": "^9.0.2",
    "libphonenumber-js": "^1.12.4",
    "mongoose": "^8.13.2",
    "multer": "^1.4.5-lts.1",
    "nodemailer": "^6.10.0",
    "otp-generator": "^4.0.1",
    "p-queue": "^8.1.0",
    "pdf-lib": "^1.17.1",
    "pdf2pic": "^3.1.4",
    "pdfjs-dist": "^3.11.174",
    "puppeteer": "^24.6.1",
    "sharp": "^0.34.1",
    "socket.io": "^4.8.1",
    "tesseract.js": "^4.1.1",
    "twilio": "^5.4.5",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  }
}
</file>

<file path="routes/ai.js">
// backend/routes/ai.js
import express from 'express';
// --- CORRECTION ICI ---
// Assurez-vous que cet import pointe vers le bon fichier et la bonne fonction
import { analyzeSymptomsSimple } from '../services/simpleSymptomHelper.js'; // <= Changer ceci !

const router = express.Router();

// POST /api/ai/analyze-symptoms
router.post('/analyze-symptoms', (req, res) => { // Pas besoin d'async
  const { symptomText } = req.body;

  if (!symptomText || typeof symptomText !== 'string' || symptomText.trim().length < 5) {
    console.log("[Simple Analysis] Texte trop court, retour vide.");
    return res.json({ keywords: [], suggestedQuestions: [] });
  }

  try {
    // --- CORRECTION ICI ---
    // Utiliser la fonction import√©e correctement
    const analysisResult = analyzeSymptomsSimple(symptomText); // <= Changer ceci !
    console.log("[Route AI Simple] R√©sultat envoy√©:", analysisResult);
    res.json(analysisResult);
  } catch (error) {
    console.error("Erreur inattendue dans l'analyse simple:", error);
    res.status(500).json({ message: "Erreur interne lors de l'analyse des sympt√¥mes." });
  }
});

export default router;
</file>

<file path="routes/alerts.js">
import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import Alert from "../models/Alert.js";
import { authenticateToken } from "../middleware/authMiddleware.js";

dotenv.config();
const router = express.Router();

// allow only our React app to hit these endpoints
router.use(
  cors({
    origin: "http://localhost:3000",
    credentials: true,
  })
);


router.get("/", authenticateToken, async (req, res) => {
  try {
    const alerts = await Alert.find().sort({ timestamp: -1 }).lean();
    res.json(alerts);
  } catch (err) {
    console.error("Failed to fetch alerts:", err);
    res.status(500).json({ error: "Server error" });
  }
});

router.post("/", authenticateToken, async (req, res) => {
  try {
    const { message, source } = req.body;
    const alert = await Alert.create({ message, source });

    // broadcast to all connected clients
    const io = req.app.get("io");
    io.emit("alert", {
      _id: alert._id,
      message: alert.message,
      source: alert.source,
      timestamp: alert.timestamp,
    });

    res.status(201).json(alert);
  } catch (err) {
    console.error("Failed to create alert:", err);
    res.status(500).json({ error: "Server error" });
  }
});

export default router;
</file>

<file path="routes/ambulance.js">
import express from "express";
import mongoose from "mongoose";
import cors from "cors";
import dotenv from "dotenv";
import { authenticateToken } from "../middleware/authMiddleware.js";
import  Ambulance  from "../models/Ambulance.js";

const router = express.Router();
router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();

// Create a new ambulance (admin only)
router.post("/", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }
    console.log("üì© Requ√™te re√ßue :", req.body);
    const newAmbulance = new Ambulance(req.body);
    const savedAmbulance = await newAmbulance.save();
    res.status(201).json(savedAmbulance);
  } catch (error) {
    console.error("Erreur lors de la cr√©ation de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Get all ambulances
router.get("/", authenticateToken, async (req, res) => {
  try {
    // Allow access to Administrator, Doctor, or Nurse roles
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }
    
    const ambulances = await Ambulance.find().populate("team", "username email role");
    res.status(200).json(ambulances);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des ambulances:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Get the ambulance assigned to the current nurse
router.get("/assigned", authenticateToken, async (req, res) => {
    try {
      // Only nurses are allowed to access this endpoint
      if (req.user.role !== "Nurse") {
        return res.status(403).json({ message: "Acc√®s refus√©" });
      }
  
      // Find an ambulance where the team includes the current nurse's id
      const ambulance = await Ambulance.findOne({ team: req.user.id }).populate("team", "username email role");
      if (!ambulance) {
        return res.status(404).json({ message: "Aucune ambulance assign√©e" });
      }
  
      res.status(200).json(ambulance);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de l'ambulance assign√©e:", error);
      res.status(500).json({ message: "Erreur serveur", error: error.message });
    }
  });
  
// Get ambulance by ID
router.get("/:id", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const ambulance = await Ambulance.findById(req.params.id).populate("team", "username email role");
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    res.status(200).json(ambulance);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update ambulance by ID
router.put("/:id", authenticateToken, async (req, res) => {
    console.log("üì© Requ√™te re√ßue :", req.user.role);

  try {
    if (!["Administrator", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const updatedAmbulance = await Ambulance.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    
    if (!updatedAmbulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    res.status(200).json(updatedAmbulance);
  } catch (error) {
    console.error("Erreur lors de la mise √† jour de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Delete ambulance by ID
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const deletedAmbulance = await Ambulance.findByIdAndDelete(req.params.id);
    
    if (!deletedAmbulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    res.status(200).json({ message: "Ambulance supprim√©e avec succ√®s" });
  } catch (error) {
    console.error("Erreur lors de la suppression de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update ambulance status
router.put("/:id/status", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const { status } = req.body;
    
    if (!status || !['IN_TRANSIT', 'AVAILABLE', 'ON_MISSION', 'MAINTENANCE'].includes(status)) {
      return res.status(400).json({ message: "Statut d'ambulance invalide" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    ambulance.status = status;
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    res.status(200).json({
      message: `Statut de l'ambulance mis √† jour √† ${status}`,
      ambulance: ambulance
    });
  } catch (error) {
    console.error("Erreur lors de la mise √† jour du statut de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update ambulance location
router.put("/:id/location", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const { latitude, longitude } = req.body;
    
    if (typeof latitude !== 'number' || typeof longitude !== 'number') {
      return res.status(400).json({ message: "Coordonn√©es de localisation invalides" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    ambulance.latitude = latitude;
    ambulance.longitude = longitude;
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    res.status(200).json({
      message: "Localisation de l'ambulance mise √† jour",
      ambulance: ambulance
    });
  } catch (error) {
    console.error("Erreur lors de la mise √† jour de la localisation de l'ambulance:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Add team member to ambulance
router.post("/:id/team", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const { userId } = req.body;
    
    if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ message: "ID utilisateur invalide" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    // Prevent duplicate team members
    if (ambulance.team.includes(userId)) {
      return res.status(400).json({ message: "Cet utilisateur fait d√©j√† partie de l'√©quipe" });
    }
    
    ambulance.team.push(userId);
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    const updatedAmbulance = await Ambulance.findById(req.params.id).populate("team", "username email role");
    
    res.status(200).json({
      message: "Membre ajout√© √† l'√©quipe",
      ambulance: updatedAmbulance
    });
  } catch (error) {
    console.error("Erreur lors de l'ajout d'un membre √† l'√©quipe:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Remove team member from ambulance
router.delete("/:id/team/:userId", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id) || !mongoose.Types.ObjectId.isValid(req.params.userId)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    // Check if user is in the team
    if (!ambulance.team.includes(req.params.userId)) {
      return res.status(400).json({ message: "Cet utilisateur ne fait pas partie de l'√©quipe" });
    }
    
    ambulance.team = ambulance.team.filter(id => id.toString() !== req.params.userId);
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    const updatedAmbulance = await Ambulance.findById(req.params.id).populate("team", "username email role");
    
    res.status(200).json({
      message: "Membre retir√© de l'√©quipe",
      ambulance: updatedAmbulance
    });
  } catch (error) {
    console.error("Erreur lors du retrait d'un membre de l'√©quipe:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Get available ambulances
router.get("/status/available", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }
    
    const availableAmbulances = await Ambulance.find({ status: "AVAILABLE" }).populate("team", "username email role");
    res.status(200).json(availableAmbulances);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des ambulances disponibles:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update estimated arrival time
router.put("/:id/eta", authenticateToken, async (req, res) => {
  try {
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res.status(400).json({ message: "ID d'ambulance invalide" });
    }

    const { estimatedArrival } = req.body;
    
    if (!estimatedArrival) {
      return res.status(400).json({ message: "Heure d'arriv√©e estim√©e requise" });
    }

    const ambulance = await Ambulance.findById(req.params.id);
    
    if (!ambulance) {
      return res.status(404).json({ message: "Ambulance non trouv√©e" });
    }
    
    ambulance.estimatedArrival = new Date(estimatedArrival);
    ambulance.lastUpdated = Date.now();
    await ambulance.save();
    
    res.status(200).json({
      message: "Heure d'arriv√©e estim√©e mise √† jour",
      ambulance: ambulance
    });
  } catch (error) {
    console.error("Erreur lors de la mise √† jour de l'heure d'arriv√©e estim√©e:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});


export default router;
</file>

<file path="routes/annotation.js">
import express from "express"
import { authenticateToken } from "../middleware/authMiddleware.js"
import Annotation from "../models/Annotation.js"
import PatientFile from "../models/PatientFile.js"
import AuditLog from "../models/AuditLog.js"
import mongoose from "mongoose"
import MedicalRecord from "../models/MedicalRecord.js";
const router = express.Router()

// Create a new annotation
router.post("/", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux professionnels de sant√©" })
    }

    const { patientFileId, text, position, type, color } = req.body

    // Validate patient file exists
    const patientFile = await PatientFile.findById(patientFileId)
    if (!patientFile) {
      return res.status(404).json({ message: "Document m√©dical introuvable" })
    }

    const newAnnotation = new Annotation({
      patientFileId,
      authorId: req.user.id,
      text,
      position,
      type: type || "comment",
      color: color || "#FFD700",
    })

    await newAnnotation.save()

    // Log the action
    await AuditLog.create({
      action: "CREATE_ANNOTATION",
      userId: req.user.id,
      details: `Annotation cr√©√©e pour le document ${patientFileId}`,
    })

    // Populate author information
    const populatedAnnotation = await Annotation.findById(newAnnotation._id).populate("authorId", "username role")

    res.status(201).json(populatedAnnotation)
  } catch (error) {
    console.error("Erreur lors de la cr√©ation de l'annotation:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Get all annotations for a specific patient file
router.get("/file/:patientFileId", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Nurse", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" })
    }

    const { patientFileId } = req.params

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(patientFileId)) {
      return res.status(400).json({ message: "Select file patient" })
    }

    const annotations = await Annotation.find({ patientFileId })
      .populate("authorId", "username role")
      .sort({ createdAt: -1 })

    res.status(200).json(annotations)
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des annotations:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Update an annotation
router.put("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params
    const { text, isResolved, color, type } = req.body

    // Find the annotation
    const annotation = await Annotation.findById(id)
    if (!annotation) {
      return res.status(404).json({ message: "Annotation introuvable" })
    }

    // Check if user is the author or an administrator
    if (annotation.authorId.toString() !== req.user.id && req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Vous n'√™tes pas autoris√© √† modifier cette annotation" })
    }

    // Update fields
    if (text) annotation.text = text
    if (isResolved !== undefined) annotation.isResolved = isResolved
    if (color) annotation.color = color
    if (type) annotation.type = type

    await annotation.save()

    // Log the action
    await AuditLog.create({
      action: "UPDATE_ANNOTATION",
      userId: req.user.id,
      details: `Annotation ${id} mise √† jour`,
    })

    // Return updated annotation with author info
    const updatedAnnotation = await Annotation.findById(id).populate("authorId", "username role")

    res.status(200).json(updatedAnnotation)
  } catch (error) {
    console.error("Erreur lors de la mise √† jour de l'annotation:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})
// Nouvelle route pour r√©cup√©rer les annotations par dossier m√©dical
router.get("/medical-record/:medicalRecordId", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Nurse", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const { medicalRecordId } = req.params;

    // Validation de l'ID du dossier m√©dical
    if (!mongoose.Types.ObjectId.isValid(medicalRecordId)) {
      return res.status(400).json({ message: "ID de dossier m√©dical invalide" });
    }

    // V√©rification de l'existence du dossier m√©dical
    const medicalRecord = await MedicalRecord.findById(medicalRecordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical introuvable" });
    }

    // R√©cup√©ration de tous les fichiers patients associ√©s
    const patientFiles = await PatientFile.find({ medicalRecord: medicalRecordId });
    const patientFileIds = patientFiles.map(file => file._id);

    // R√©cup√©ration de toutes les annotations pour ces fichiers
    const annotations = await Annotation.find({ patientFileId: { $in: patientFileIds } })
      .populate("authorId", "username role")
      .sort({ createdAt: -1 });

    res.status(200).json(annotations);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des annotations par dossier m√©dical:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Delete an annotation
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params

    // Find the annotation
    const annotation = await Annotation.findById(id)
    if (!annotation) {
      return res.status(404).json({ message: "Annotation introuvable" })
    }

    // Check if user is the author or an administrator
    if (annotation.authorId.toString() !== req.user.id && req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Vous n'√™tes pas autoris√© √† supprimer cette annotation" })
    }

    await Annotation.findByIdAndDelete(id)

    // Log the action
    await AuditLog.create({
      action: "DELETE_ANNOTATION",
      userId: req.user.id,
      details: `Annotation ${id} supprim√©e`,
    })

    res.status(200).json({ message: "Annotation supprim√©e avec succ√®s" })
  } catch (error) {
    console.error("Erreur lors de la suppression de l'annotation:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

export default router
</file>

<file path="routes/archive.js">
import express from "express"
import { authenticateToken } from "../middleware/authMiddleware.js"
import PatientFile from "../models/PatientFile.js"
import MedicalRecord from "../models/MedicalRecord.js"
import AuditLog from "../models/AuditLog.js"
import mongoose from "mongoose"

const router = express.Router()

// Archive a patient file
router.put("/patient-files/:id/archive", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins et administrateurs" })
    }

    const { id } = req.params
    const { reason } = req.body

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID de document invalide" })
    }

    // Find the patient file
    const patientFile = await PatientFile.findById(id)
    if (!patientFile) {
      return res.status(404).json({ message: "Document m√©dical introuvable" })
    }

    // Update the file status to archived
    patientFile.isArchived = true
    patientFile.archivedAt = new Date()
    patientFile.archiveReason = reason || "Document archiv√© par un professionnel de sant√©"
    patientFile.archivedBy = req.user.id

    await patientFile.save()

    // Log the action
    await AuditLog.create({
      action: "ARCHIVE_PATIENT_FILE",
      userId: req.user.id,
      details: `Document m√©dical ${id} archiv√©: ${reason || "Aucune raison sp√©cifi√©e"}`,
    })

    res.status(200).json({
      message: "Document archiv√© avec succ√®s",
      patientFile,
    })
  } catch (error) {
    console.error("Erreur lors de l'archivage du document:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Restore an archived patient file
router.put("/patient-files/:id/restore", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins et administrateurs" })
    }

    const { id } = req.params
    const { reason } = req.body

    // Find the patient file
    const patientFile = await PatientFile.findById(id)
    if (!patientFile) {
      return res.status(404).json({ message: "Document m√©dical introuvable" })
    }

    if (!patientFile.isArchived) {
      return res.status(400).json({ message: "Ce document n'est pas archiv√©" })
    }

    // Restore the file
    patientFile.isArchived = false
    patientFile.archivedAt = null
    patientFile.archiveReason = null
    patientFile.archivedBy = null
    patientFile.restoredAt = new Date()
    patientFile.restoredBy = req.user.id
    patientFile.restoreReason = reason || "Document restaur√© par un professionnel de sant√©"

    await patientFile.save()

    // Log the action
    await AuditLog.create({
      action: "RESTORE_PATIENT_FILE",
      userId: req.user.id,
      details: `Document m√©dical ${id} restaur√©: ${reason || "Aucune raison sp√©cifi√©e"}`,
    })

    res.status(200).json({
      message: "Document restaur√© avec succ√®s",
      patientFile,
    })
  } catch (error) {
    console.error("Erreur lors de la restauration du document:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Get all archived patient files for a medical record
router.get("/medical-records/:recordId/archived", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Administrator", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" })
    }

    const { recordId } = req.params

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(recordId)) {
      return res.status(400).json({ message: "ID de dossier m√©dical invalide" })
    }

    // Check if medical record exists
    const medicalRecord = await MedicalRecord.findById(recordId)
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical introuvable" })
    }

    // Get all archived files for this medical record
    const archivedFiles = await PatientFile.find({
      medicalRecord: recordId,
      isArchived: true,
    }).populate("archivedBy", "username role")

    res.status(200).json(archivedFiles)
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des documents archiv√©s:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

// Get all archived patient files (admin only)
router.get("/archived", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux administrateurs" })
    }

    // Optional query parameters for filtering
    const { before, after, medicalRecordId } = req.query

    const query = { isArchived: true }

    if (before) {
      query.archivedAt = { ...query.archivedAt, $lt: new Date(before) }
    }

    if (after) {
      query.archivedAt = { ...query.archivedAt, $gt: new Date(after) }
    }

    if (medicalRecordId && mongoose.Types.ObjectId.isValid(medicalRecordId)) {
      query.medicalRecord = medicalRecordId
    }

    const archivedFiles = await PatientFile.find(query)
      .populate("archivedBy", "username role")
      .populate("medicalRecord", "accessCode")
      .sort({ archivedAt: -1 })

    res.status(200).json(archivedFiles)
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des documents archiv√©s:", error)
    res.status(500).json({ message: "Erreur serveur", error: error.message })
  }
})

export default router
</file>

<file path="routes/auth copy.js">
import express from "express";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { User } from "../models/User.js";
import dotenv from "dotenv";
import crypto from "crypto"; // Utilisez cette syntaxe pour les modules ES
import nodemailer from "nodemailer";
import { generateOTP, saveOTPToUser, verifyOTP } from "../services/otpService.js";
import { sendOTP } from "../services/emailService.js";
import { OAuth2Client } from "google-auth-library";
import multer from "multer";
import upload from "../middleware/uploadMiddleware.js"
import { authenticateToken } from "../middleware/authMiddleware.js";
import sendSMS from "../sendSMS.js";

const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

// Middleware CORS pour assurer que toutes les routes acceptent les requ√™tes frontend
import cors from "cors";

const router = express.Router();
// üìÇ D√©finir le stockage des fichiers
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/'); // Dossier o√π enregistrer les images
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname)); // Nom unique
  }
});



router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Utilisateur non trouv√©" });

    if (!user.isValidated) {
      if (user.role === "Patient") return res.status(400).json({ message: "Votre compte est en attente de validation de mail via otp" });
      return res.status(400).json({ message: "Votre compte est en attente de validation par un administrateur" });
    }

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) return res.status(400).json({ message: "Mot de passe incorrect" });

    // Generate JWT Token
    const token = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "7d" });
    console.log("Generated Token:", token);
    // Store token in an HTTP-only cookie
    res.cookie("token", token, {
      httpOnly: false,
      secure: process.env.NODE_ENV === "production", // Set secure in production (HTTPS only)
      sameSite: "strict", // Protect against CSRF attacks
      maxAge: 7 * 24 * 60 * 60 * 1000, // Cookie expires in 7 days
    });
    

    res.status(200).json({ message: "Connexion r√©ussie", user },);
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
router.post("/logout", (req, res) => {
  console.log("Logout route hit");
  res.clearCookie("token", { httpOnly: true, sameSite: "strict", secure: process.env.NODE_ENV === "production" });
  res.status(200).json({ message: "D√©connexion r√©ussie" });
});
router.get("/me", authenticateToken, (req, res) => {
  try {
    // If the token is valid, `req.user` will have the decoded data
    const user = req.user;

    // Optionally, you can fetch the full user from the database if necessary
    res.status(200).json({
      id: user.id,
      username: user.username,
      email: user.email,
      role: user.role,
      profilePicture: user.profilePicture, // Add additional info as needed
    });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Route de login avec Google
router.post("/google-login", async (req, res) => {
  try {
    const { token } = req.body;
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID,
    });

    const { email, name, picture } = ticket.getPayload();

    let user = await User.findOne({ email });
    if (!user) {
      user = new User({ email, username: name, profilePicture: picture, isValidated: true });
      await user.save();
    }

    const jwtToken = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "7d" });

    res.status(200).json({ message: "Connexion r√©ussie avec Google", token: jwtToken, user });
  } catch (error) {
    console.error("Erreur Google Login:", error);
    res.status(500).json({ message: "Erreur lors de l'authentification Google", error: error.message });
  }
});





router.post("/register", upload.single("profileImage"), async (req, res) => {
  try {
    const { username, email, password, phoneNumber, role, ...roleSpecificData } = req.body;

    console.log("Donn√©es re√ßues :", req.body); // Log pour v√©rifier les donn√©es re√ßues

    // V√©rifier si l'utilisateur existe d√©j√†
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      console.log("Email d√©j√† utilis√© :", email);
      return res.status(400).json({ message: "Email d√©j√† utilis√©" });
    }

    // Hacher le mot de passe
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // Si le r√¥le est un r√¥le restreint (Doctor, Nurse, Admin), l'utilisateur doit √™tre en attente
    const isValidated = false; // Si r√¥le Patient, utilisateur est valid√©

    // Cr√©er un nouvel utilisateur
    const newUserData = {
      username,
      email,
      password: hashedPassword,
      phoneNumber,
      role,
      isValidated,
      profileImage: req.file ? `/uploads/${req.file.filename}` : null
    };

    // Ajouter les champs sp√©cifiques au r√¥le
    switch (role) {
      case "Patient":
        const { name, dateOfBirth, gender, address, emergencyContact, bloodType, allergies } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!name || !dateOfBirth || !gender || !address || !emergencyContact || !bloodType) {
          console.log("Champs obligatoires manquants pour un patient");
          return res.status(400).json({ message: "Tous les champs obligatoires pour un patient doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques au patient
        newUserData.name = name;
        newUserData.dateOfBirth = dateOfBirth;
        newUserData.gender = gender;
        newUserData.address = address;
        newUserData.emergencyContact = emergencyContact;
        newUserData.bloodType = bloodType;
        newUserData.allergies = allergies || []; // Les allergies sont optionnelles
        break;

      case "Doctor":
        const { badgeNumber: docBadgeNumber, specialization, licenseNumber: docLicenseNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!docBadgeNumber || !specialization || !docLicenseNumber) {
          console.log("Champs obligatoires manquants pour un m√©decin");
          return res.status(400).json({ message: "Tous les champs obligatoires pour un m√©decin doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques au m√©decin
        newUserData.badgeNumber = docBadgeNumber;
        newUserData.specialization = specialization;
        newUserData.licenseNumber = docLicenseNumber;
        break;

      case "Nurse":
        const { badgeNumber: nurseBadgeNumber, shift, licenseNumber: nurseLicenseNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!nurseBadgeNumber || !shift || !nurseLicenseNumber) {
          console.log("Champs obligatoires manquants pour une infirmi√®re");
          return res.status(400).json({ message: "Tous les champs obligatoires pour une infirmi√®re doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques √† l'infirmi√®re
        newUserData.badgeNumber = nurseBadgeNumber;
        newUserData.shift = shift;
        newUserData.licenseNumber = nurseLicenseNumber;
        break;

      case "Administrator":
        const { badgeNumber: adminBadgeNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!adminBadgeNumber) {
          console.log("Champs obligatoires manquants pour un administrateur");
          return res.status(400).json({ message: "Le num√©ro de badge est obligatoire pour un administrateur" });
        }

        // Ajouter les champs sp√©cifiques √† l'administrateur
        newUserData.badgeNumber = adminBadgeNumber;
        break;

      default:
        console.log("R√¥le invalide :", role);
        return res.status(400).json({ message: "R√¥le invalide" });
    }

    // Cr√©er un nouvel utilisateur
    const newUser = new User(newUserData);
    await newUser.save();
    console.log("Utilisateur cr√©√© avec succ√®s :", newUser);

    // G√©n√©rer et envoyer l'OTP
    const { otp, hashedOTP } = await generateOTP();
    console.log("OTP g√©n√©r√© :", otp);
    await saveOTPToUser(email, hashedOTP);
    console.log("OTP enregistr√© pour l'utilisateur :", email);
    await sendOTP(email, otp);
    console.log("OTP envoy√© √† :", email);

    // Envoyer un SMS de confirmation avec le num√©ro de t√©l√©phone
    const smsMessage = `Bienvenue ${username}, votre inscription a √©t√© r√©ussie !  Veuillez v√©rifier votre email pour l'OTP.`;
    await sendSMS(smsMessage, phoneNumber); // <--- CORRECT
    console.log("SMS envoy√© √† :", phoneNumber);

    res.status(201).json({ message: "Utilisateur cr√©√© avec succ√®s. Veuillez v√©rifier votre email pour l'OTP.", user: newUser });
  } catch (error) {
    console.error("Erreur lors de l'inscription :", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Route pour r√©initialiser le mot de passe
const transporter = nodemailer.createTransport({
  host: "smtp.gmail.com", // Serveur SMTP d'Outlook
  port: 587, // Port SMTP
  secure: false, // true pour le port 465, false pour les autres ports
  auth: {
    user: process.env.EMAIL_USER, // Votre adresse email
    pass: process.env.EMAIL_PASSWORD, // Votre mot de passe
  },
});
// üìå Route pour demander une r√©initialisation de mot de passe
router.post("/forgot-password", async (req, res) => {
  try {
    console.log("üì© Requ√™te re√ßue :", req.body);
    const { email } = req.body;

    // V√©rifier si l'utilisateur existe
    const user = await User.findOne({ email });
    if (!user) {
      console.log("‚ö† Utilisateur non trouv√© :", email);
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    // G√©n√©rer un token de r√©initialisation
    const resetToken = crypto.randomBytes(20).toString("hex");
    const resetTokenExpiry = Date.now() + 3600000; // 1 heure de validit√©

    // Enregistrer le token et sa date d'expiration dans la base de donn√©es
    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = resetTokenExpiry;
    await user.save();
    console.log("‚úÖ Token enregistr√© pour :", user.email);

    // üîó Construire le lien de r√©initialisation avec la syntaxe correcte
    const resetUrl = `http://localhost:3000/reset-password/${resetToken}`;

    // Envoyer un email avec le lien de r√©initialisation
    const mailOptions = {
      to: user.email,
      from: process.env.EMAIL_USER,
      subject: "R√©initialisation de mot de passe",
      html: `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R√©initialisation de mot de passe</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 0;
            text-align: center;
        }
        .container {
            width: 100%;
            max-width: 600px;
            margin: 50px auto;
            background-color: #ffffff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #333;
            font-size: 24px;
        }
        p {
            font-size: 16px;
            color: #555;
        }
        a {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            font-weight: bold;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            margin-top: 20px;
        }
        a:hover {
            background-color: #45a049;
        }
        .footer {
            font-size: 14px;
            color: #888;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>R√©initialisation de votre mot de passe</h2>
        <p>Vous avez demand√© une r√©initialisation de mot de passe. Cliquez sur le lien ci-dessous pour r√©initialiser votre mot de passe :</p>
        <a href="${resetUrl}">R√©initialiser votre mot de passe</a>
        <p class="footer">Si vous n'avez pas demand√© cette r√©initialisation, vous pouvez ignorer cet email.</p>
    </div>
</body>
</html>`,
    };

    console.log("üì® Envoi de l'email √† :", user.email);
    await transporter.sendMail(mailOptions);
    console.log("‚úÖ Email envoy√© avec succ√®s");

    res.status(200).json({ message: "Un email de r√©initialisation a √©t√© envoy√©" });
  } catch (error) {
    console.error("‚ùå Erreur dans /forgot-password :", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message || error });
  }
});

// Route pour r√©initialiser le mot de passe
router.post("/reset-password/:token", async (req, res) => {
  console.log("Reset password route hit");
  try {
    const { token } = req.params;
    const { newPassword } = req.body;
    console.log("Requ√™te re√ßue :", req.body); // Log pour v√©rifier la requ√™te
    // Trouver l'utilisateur avec le token valide
    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: Date.now() }, // V√©rifier que le token n'a pas expir√©
    });

    if (!user) return res.status(400).json({ message: "Token invalide ou expir√©" });

    // Hacher le nouveau mot de passe
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    // Mettre √† jour le mot de passe et effacer le token
    user.password = hashedPassword;
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    await user.save();

    res.status(200).json({ success: true, message: "Mot de passe r√©initialis√© avec succ√®s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});


// Route pour mettre √† jour le profil d'un utilisateur
router.put("/update-profile/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { username, phoneNumber, role, ...roleSpecificData } = req.body;

    // Trouver l'utilisateur par son ID
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Mettre √† jour les champs communs
    if (username) user.username = username;
    if (phoneNumber) user.phoneNumber = phoneNumber;

    // Mettre √† jour les champs sp√©cifiques au r√¥le
    switch (user.role) {
      case "Patient":
        const { name, dateOfBirth, gender, address, emergencyContact, bloodType, allergies } = roleSpecificData;

        if (name) user.name = name;
        if (dateOfBirth) user.dateOfBirth = dateOfBirth;
        if (gender) user.gender = gender;
        if (address) user.address = address;
        if (emergencyContact) user.emergencyContact = emergencyContact;
        if (bloodType) user.bloodType = bloodType;
        if (allergies) user.allergies = allergies;
        break;

      case "Doctor":
        const { badgeNumber: docBadgeNumber, specialization, licenseNumber: docLicenseNumber } = roleSpecificData;

        if (docBadgeNumber) user.badgeNumber = docBadgeNumber;
        if (specialization) user.specialization = specialization;
        if (docLicenseNumber) user.licenseNumber = docLicenseNumber;
        break;

      case "Nurse":
        const { badgeNumber: nurseBadgeNumber, shift, licenseNumber: nurseLicenseNumber } = roleSpecificData;

        if (nurseBadgeNumber) user.badgeNumber = nurseBadgeNumber;
        if (shift) user.shift = shift;
        if (nurseLicenseNumber) user.licenseNumber = nurseLicenseNumber;
        break;

      case "Administrator":
        const { badgeNumber: adminBadgeNumber } = roleSpecificData;

        if (adminBadgeNumber) user.badgeNumber = adminBadgeNumber;
        break;

      default:
        return res.status(400).json({ message: "R√¥le invalide" });
    }

    // Sauvegarder les modifications
    await user.save();

    res.status(200).json({ message: "Profil mis √† jour avec succ√®s", user });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
// Route pour changer le r√¥le d'un utilisateur (admin uniquement)
router.put("/change-role/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { role } = req.body;

    // Trouver l'utilisateur par son ID
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Changer le r√¥le de l'utilisateur
    user.role = role;
    await user.save();

    res.status(200).json({ message: "R√¥le de l'utilisateur mis √† jour avec succ√®s", user });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Send OTP Route
router.post("/send-otp", async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: "Email is required" });

    // Generate OTP
    const { otp, hashedOTP } = await generateOTP();

    // Store OTP with expiration (e.g., 5 minutes)
    saveOTPToUser(email, hashedOTP);

    // Send OTP to email
    await sendOTP(email, otp);

    res.status(200).json({ message: "OTP sent successfully" });
  } catch (error) {
    console.error("Error sending OTP:", error);
    res.status(500).json({ message: "Server error", error });
  }
});
router.post("/verify-otp", async (req, res) => {
  const { email, otp } = req.body;

  if (!email || !otp) {
    return res.status(400).json({ message: "Email et OTP sont requis" });
  }

  try {
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Utilisateur non trouv√©" });

    if (Date.now() > user.otpExpires) {
      return res.status(400).json({ message: "OTP expir√©" });
    }

    const isValid = await verifyOTP(otp, user.otp);
    if (!isValid) {
      if (user.role === "Patient") user.isValidated = true;
      return res.status(400).json({ message: "OTP incorrect" });

    }

    // Mettre √† jour l'utilisateur apr√®s v√©rification
    user.otpValidated = true;
    user.otp = undefined;
    user.otpExpires = undefined;
    user.isValidated = true;
    await user.save();

    res.status(200).json({ message: "OTP v√©rifi√© avec succ√®s. Vous pouvez maintenant vous connecter." });
  } catch (error) {
    console.error("Erreur lors de la v√©rification de l'OTP:", error);
    res.status(500).json({ message: "Erreur serveur", error });
  }
});


router.post('/send-sms', async (req, res) => {
  const { body, phoneNumber } = req.body;

  // V√©rifier que le corps du message et le num√©ro de t√©l√©phone sont fournis
  if (!body || !phoneNumber) {
    return res.status(400).json({ success: false, message: 'Body and phone number are required' });
  }

  try {
    const result = await sendSMS(body, phoneNumber);
    if (result.success) {
      return res.status(200).json(result);
    } else {
      return res.status(500).json(result);
    }
  } catch (error) {
    console.error(error);
    return res.status(500).json({ success: false, message: 'Failed to send SMS', error: error.message });
  }
});

///////router export 
export default router;
</file>

<file path="routes/auth.js">
import express from "express";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { User } from "../models/User.js";
import dotenv from "dotenv";
import crypto from "crypto"; // Utilisez cette syntaxe pour les modules ES
import nodemailer from "nodemailer";
import { generateOTP, saveOTPToUser, verifyOTP } from "../services/otpService.js";
import { sendOTP } from "../services/emailService.js";
import { OAuth2Client } from "google-auth-library";
import multer from "multer";
import upload from "../middleware/uploadMiddleware.js"
import { authenticateToken } from "../middleware/authMiddleware.js";
import sendSMS from "../sendSMS.js";

const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

// Middleware CORS pour assurer que toutes les routes acceptent les requ√™tes frontend
import cors from "cors";

const router = express.Router();
// üìÇ D√©finir le stockage des fichiers
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/'); // Dossier o√π enregistrer les images
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname)); // Nom unique
  }
});



router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();
router.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Utilisateur non trouv√©" });

    if (!user.isValidated) {
      if (user.role === "Patient") return res.status(400).json({ message: "Votre compte est en attente de validation de mail via otp" });
      return res.status(400).json({ message: "Votre compte est en attente de validation par un administrateur" });
    }

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) return res.status(400).json({ message: "Mot de passe incorrect" });

    // Generate JWT Token
    const token = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "7d" });
    console.log("Generated Token:", token);
    // Store token in an HTTP-only cookie
    res.cookie("token", token, {
      httpOnly: false,
      secure: process.env.NODE_ENV === "production", // Set secure in production (HTTPS only)
      sameSite: "strict", // Protect against CSRF attacks
      maxAge: 7 * 24 * 60 * 60 * 1000, // Cookie expires in 7 days
    });
    

    res.status(200).json({ message: "Connexion r√©ussie", user },);
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
router.post("/logout", (req, res) => {
  console.log("Logout route hit");
  res.clearCookie("token", { httpOnly: true, sameSite: "strict", secure: process.env.NODE_ENV === "production" });
  res.status(200).json({ message: "D√©connexion r√©ussie" });
});
router.get("/me", authenticateToken, (req, res) => {
  try {
    // If the token is valid, `req.user` will have the decoded data
    const user = req.user;

    // Optionally, you can fetch the full user from the database if necessary
    res.status(200).json({
      id: user.id,
      username: user.username,
      email: user.email,
      role: user.role,
      profilePicture: user.profilePicture, // Add additional info as needed
    });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Route de login avec Google
router.post("/google-login", async (req, res) => {
  try {
    const { token } = req.body;
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID,
    });

    const { email, name, picture } = ticket.getPayload();

    let user = await User.findOne({ email });
    if (!user) {
      user = new User({ email, username: name, profilePicture: picture, isValidated: true });
      await user.save();
    }

    const jwtToken = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "7d" });

    res.status(200).json({ message: "Connexion r√©ussie avec Google", token: jwtToken, user });
  } catch (error) {
    console.error("Erreur Google Login:", error);
    res.status(500).json({ message: "Erreur lors de l'authentification Google", error: error.message });
  }
});





router.post("/register", upload.single("profileImage"), async (req, res) => {
  try {
    const { username, email, password, phoneNumber, role, ...roleSpecificData } = req.body;

    console.log("Donn√©es re√ßues :", req.body); // Log pour v√©rifier les donn√©es re√ßues

    // V√©rifier si l'utilisateur existe d√©j√†
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      console.log("Email d√©j√† utilis√© :", email);
      return res.status(400).json({ message: "Email d√©j√† utilis√©" });
    }

    // Hacher le mot de passe
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // Si le r√¥le est un r√¥le restreint (Doctor, Nurse, Admin), l'utilisateur doit √™tre en attente
    const isValidated = false; // Si r√¥le Patient, utilisateur est valid√©

    // Cr√©er un nouvel utilisateur
    const newUserData = {
      username,
      email,
      password: hashedPassword,
      phoneNumber,
      role,
      isValidated,
      profileImage: req.file ? `/uploads/${req.file.filename}` : null
    };

    // Ajouter les champs sp√©cifiques au r√¥le
    switch (role) {
      case "Patient":
        const { name, dateOfBirth, gender, address, emergencyContact, bloodType, allergies } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!name || !dateOfBirth || !gender || !address || !emergencyContact || !bloodType) {
          console.log("Champs obligatoires manquants pour un patient");
          return res.status(400).json({ message: "Tous les champs obligatoires pour un patient doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques au patient
        newUserData.name = name;
        newUserData.dateOfBirth = dateOfBirth;
        newUserData.gender = gender;
        newUserData.address = address;
        newUserData.emergencyContact = emergencyContact;
        newUserData.bloodType = bloodType;
        newUserData.allergies = allergies || []; // Les allergies sont optionnelles
        break;

      case "Doctor":
        const { badgeNumber: docBadgeNumber, specialization, licenseNumber: docLicenseNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!docBadgeNumber || !specialization || !docLicenseNumber) {
          console.log("Champs obligatoires manquants pour un m√©decin");
          return res.status(400).json({ message: "Tous les champs obligatoires pour un m√©decin doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques au m√©decin
        newUserData.badgeNumber = docBadgeNumber;
        newUserData.specialization = specialization;
        newUserData.licenseNumber = docLicenseNumber;
        break;

      case "Nurse":
        const { badgeNumber: nurseBadgeNumber, shift, licenseNumber: nurseLicenseNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!nurseBadgeNumber || !shift || !nurseLicenseNumber) {
          console.log("Champs obligatoires manquants pour une infirmi√®re");
          return res.status(400).json({ message: "Tous les champs obligatoires pour une infirmi√®re doivent √™tre remplis" });
        }

        // Ajouter les champs sp√©cifiques √† l'infirmi√®re
        newUserData.badgeNumber = nurseBadgeNumber;
        newUserData.shift = shift;
        newUserData.licenseNumber = nurseLicenseNumber;
        break;

      case "Administrator":
        const { badgeNumber: adminBadgeNumber } = roleSpecificData;

        // V√©rifier que tous les champs obligatoires sont fournis
        if (!adminBadgeNumber) {
          console.log("Champs obligatoires manquants pour un administrateur");
          return res.status(400).json({ message: "Le num√©ro de badge est obligatoire pour un administrateur" });
        }

        // Ajouter les champs sp√©cifiques √† l'administrateur
        newUserData.badgeNumber = adminBadgeNumber;
        break;

      default:
        console.log("R√¥le invalide :", role);
        return res.status(400).json({ message: "R√¥le invalide" });
    }

    // Cr√©er un nouvel utilisateur
    const newUser = new User(newUserData);
    await newUser.save();
    console.log("Utilisateur cr√©√© avec succ√®s :", newUser);

    // G√©n√©rer et envoyer l'OTP
    const { otp, hashedOTP } = await generateOTP();
    console.log("OTP g√©n√©r√© :", otp);
    await saveOTPToUser(email, hashedOTP);
    console.log("OTP enregistr√© pour l'utilisateur :", email);
    await sendOTP(email, otp);
    console.log("OTP envoy√© √† :", email);

    // Envoyer un SMS de confirmation avec le num√©ro de t√©l√©phone
    const smsMessage = `Bienvenue ${username}, votre inscription a √©t√© r√©ussie !  Veuillez v√©rifier votre email pour l'OTP.`;
    await sendSMS(smsMessage, phoneNumber); // <--- CORRECT
    console.log("SMS envoy√© √† :", phoneNumber);

    res.status(201).json({ message: "Utilisateur cr√©√© avec succ√®s. Veuillez v√©rifier votre email pour l'OTP.", user: newUser });
  } catch (error) {
    console.error("Erreur lors de l'inscription :", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Route pour r√©initialiser le mot de passe
const transporter = nodemailer.createTransport({
  host: "smtp.gmail.com", // Serveur SMTP d'Outlook
  port: 587, // Port SMTP
  secure: false, // true pour le port 465, false pour les autres ports
  auth: {
    user: process.env.EMAIL_USER, // Votre adresse email
    pass: process.env.EMAIL_PASSWORD, // Votre mot de passe
  },
});
// üìå Route pour demander une r√©initialisation de mot de passe
router.post("/forgot-password", async (req, res) => {
  try {
    console.log("üì© Requ√™te re√ßue :", req.body);
    const { email } = req.body;

    // V√©rifier si l'utilisateur existe
    const user = await User.findOne({ email });
    if (!user) {
      console.log("‚ö† Utilisateur non trouv√© :", email);
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    // G√©n√©rer un token de r√©initialisation
    const resetToken = crypto.randomBytes(20).toString("hex");
    const resetTokenExpiry = Date.now() + 3600000; // 1 heure de validit√©

    // Enregistrer le token et sa date d'expiration dans la base de donn√©es
    user.resetPasswordToken = resetToken;
    user.resetPasswordExpires = resetTokenExpiry;
    await user.save();
    console.log("‚úÖ Token enregistr√© pour :", user.email);

    // üîó Construire le lien de r√©initialisation avec la syntaxe correcte
    const resetUrl = `http://localhost:3000/reset-password/${resetToken}`;

    // Envoyer un email avec le lien de r√©initialisation
    const mailOptions = {
      to: user.email,
      from: process.env.EMAIL_USER,
      subject: "R√©initialisation de mot de passe",
      html: `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R√©initialisation de mot de passe</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 0;
            text-align: center;
        }
        .container {
            width: 100%;
            max-width: 600px;
            margin: 50px auto;
            background-color: #ffffff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #333;
            font-size: 24px;
        }
        p {
            font-size: 16px;
            color: #555;
        }
        a {
            display: inline-block;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            font-weight: bold;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            margin-top: 20px;
        }
        a:hover {
            background-color: #45a049;
        }
        .footer {
            font-size: 14px;
            color: #888;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>R√©initialisation de votre mot de passe</h2>
        <p>Vous avez demand√© une r√©initialisation de mot de passe. Cliquez sur le lien ci-dessous pour r√©initialiser votre mot de passe :</p>
        <a href="${resetUrl}">R√©initialiser votre mot de passe</a>
        <p class="footer">Si vous n'avez pas demand√© cette r√©initialisation, vous pouvez ignorer cet email.</p>
    </div>
</body>
</html>`,
    };

    console.log("üì® Envoi de l'email √† :", user.email);
    await transporter.sendMail(mailOptions);
    console.log("‚úÖ Email envoy√© avec succ√®s");

    res.status(200).json({ message: "Un email de r√©initialisation a √©t√© envoy√©" });
  } catch (error) {
    console.error("‚ùå Erreur dans /forgot-password :", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message || error });
  }
});

// Route pour r√©initialiser le mot de passe
router.post("/reset-password/:token", async (req, res) => {
  console.log("Reset password route hit");
  try {
    const { token } = req.params;
    const { newPassword } = req.body;
    console.log("Requ√™te re√ßue :", req.body); // Log pour v√©rifier la requ√™te
    // Trouver l'utilisateur avec le token valide
    const user = await User.findOne({
      resetPasswordToken: token,
      resetPasswordExpires: { $gt: Date.now() }, // V√©rifier que le token n'a pas expir√©
    });

    if (!user) return res.status(400).json({ message: "Token invalide ou expir√©" });

    // Hacher le nouveau mot de passe
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    // Mettre √† jour le mot de passe et effacer le token
    user.password = hashedPassword;
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    await user.save();

    res.status(200).json({ success: true, message: "Mot de passe r√©initialis√© avec succ√®s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});


// Route pour mettre √† jour le profil d'un utilisateur
router.put("/update-profile/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { username, phoneNumber, role, ...roleSpecificData } = req.body;

    // Trouver l'utilisateur par son ID
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Mettre √† jour les champs communs
    if (username) user.username = username;
    if (phoneNumber) user.phoneNumber = phoneNumber;

    // Mettre √† jour les champs sp√©cifiques au r√¥le
    switch (user.role) {
      case "Patient":
        const { name, dateOfBirth, gender, address, emergencyContact, bloodType, allergies } = roleSpecificData;

        if (name) user.name = name;
        if (dateOfBirth) user.dateOfBirth = dateOfBirth;
        if (gender) user.gender = gender;
        if (address) user.address = address;
        if (emergencyContact) user.emergencyContact = emergencyContact;
        if (bloodType) user.bloodType = bloodType;
        if (allergies) user.allergies = allergies;
        break;

      case "Doctor":
        const { badgeNumber: docBadgeNumber, specialization, licenseNumber: docLicenseNumber } = roleSpecificData;

        if (docBadgeNumber) user.badgeNumber = docBadgeNumber;
        if (specialization) user.specialization = specialization;
        if (docLicenseNumber) user.licenseNumber = docLicenseNumber;
        break;

      case "Nurse":
        const { badgeNumber: nurseBadgeNumber, shift, licenseNumber: nurseLicenseNumber } = roleSpecificData;

        if (nurseBadgeNumber) user.badgeNumber = nurseBadgeNumber;
        if (shift) user.shift = shift;
        if (nurseLicenseNumber) user.licenseNumber = nurseLicenseNumber;
        break;

      case "Administrator":
        const { badgeNumber: adminBadgeNumber } = roleSpecificData;

        if (adminBadgeNumber) user.badgeNumber = adminBadgeNumber;
        break;

      default:
        return res.status(400).json({ message: "R√¥le invalide" });
    }

    // Sauvegarder les modifications
    await user.save();

    res.status(200).json({ message: "Profil mis √† jour avec succ√®s", user });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
// Route pour changer le r√¥le d'un utilisateur (admin uniquement)
router.put("/change-role/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { role } = req.body;

    // Trouver l'utilisateur par son ID
    const user = await User.findById(id);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Changer le r√¥le de l'utilisateur
    user.role = role;
    await user.save();

    res.status(200).json({ message: "R√¥le de l'utilisateur mis √† jour avec succ√®s", user });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Send OTP Route
router.post("/send-otp", async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ message: "Email is required" });

    // Generate OTP
    const { otp, hashedOTP } = await generateOTP();

    // Store OTP with expiration (e.g., 5 minutes)
    saveOTPToUser(email, hashedOTP);

    // Send OTP to email
    await sendOTP(email, otp);

    res.status(200).json({ message: "OTP sent successfully" });
  } catch (error) {
    console.error("Error sending OTP:", error);
    res.status(500).json({ message: "Server error", error });
  }
});
router.post("/verify-otp", async (req, res) => {
  const { email, otp } = req.body;

  if (!email || !otp) {
    return res.status(400).json({ message: "Email et OTP sont requis" });
  }

  try {
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Utilisateur non trouv√©" });

    if (Date.now() > user.otpExpires) {
      return res.status(400).json({ message: "OTP expir√©" });
    }

    const isValid = await verifyOTP(otp, user.otp);
    if (!isValid) {
      if (user.role === "Patient") user.isValidated = true;
      return res.status(400).json({ message: "OTP incorrect" });

    }

    // Mettre √† jour l'utilisateur apr√®s v√©rification
    user.otpValidated = true;
    user.otp = undefined;
    user.otpExpires = undefined;
    user.isValidated = true;
    await user.save();

    res.status(200).json({ message: "OTP v√©rifi√© avec succ√®s. Vous pouvez maintenant vous connecter." });
  } catch (error) {
    console.error("Erreur lors de la v√©rification de l'OTP:", error);
    res.status(500).json({ message: "Erreur serveur", error });
  }
});


router.post('/send-sms', async (req, res) => {
  const { body, phoneNumber } = req.body;

  // V√©rifier que le corps du message et le num√©ro de t√©l√©phone sont fournis
  if (!body || !phoneNumber) {
    return res.status(400).json({ success: false, message: 'Body and phone number are required' });
  }

  try {
    const result = await sendSMS(body, phoneNumber);
    if (result.success) {
      return res.status(200).json(result);
    } else {
      return res.status(500).json(result);
    }
  } catch (error) {
    console.error(error);
    return res.status(500).json({ success: false, message: 'Failed to send SMS', error: error.message });
  }
});

///////router export 
export default router;
</file>

<file path="routes/chatbot.js">
// backend/routes/chatbot.js
import express from 'express';
import { getSimpleChatbotResponse } from '../services/chatbotService.js';
import mongoose from 'mongoose';

const router = express.Router();

router.post('/query', async (req, res) => { // C'est bien un POST et le chemin est '/query'
    const { patientId, queryText } = req.body;

    if (!patientId || !queryText) {
        return res.status(400).json({ message: 'patientId et queryText sont requis.' });
    }
    if (!mongoose.Types.ObjectId.isValid(patientId)) {
        return res.status(400).json({ message: 'patientId invalide.' });
    }

    try {
        const responseText = await getSimpleChatbotResponse(patientId, queryText);
        res.json({ response: responseText });
    } catch (error) {
        console.error("[Chatbot Route] Erreur:", error);
        res.status(500).json({ message: "Erreur du serveur chatbot." });
    }
});

export default router;
</file>

<file path="routes/emergencyPatients.js">
import express from 'express';
import mongoose from 'mongoose';
import EmergencyPatient from '../models/EmergencyPatient.js';
import { User } from '../models/User.js';
import MedicalRecord from '../models/MedicalRecord.js';
import PatientFile from '../models/PatientFile.js';
import { authenticateToken } from '../middleware/authMiddleware.js';
import sendSMS from '../sendSMS.js';
import { getEstimatedWaitTime } from '../services/waitTimeService.js';

const router = express.Router();

// Helper function to find an available doctor
const findAvailableDoctor = async () => {
  try {
    const doctor = await User.findOne({
      role: 'Doctor',
      isValidated: true,
      isAvailable: true,
    });
    return doctor;
  } catch (error) {
    console.error("Erreur lors de la recherche d'un m√©decin disponible:", error);
    return null;
  }
};

// POST route to create/update emergency patient registration
router.post('/', async (req, res) => {
  const io = req.io;
  const userSockets = req.userSockets;

  try {
    const { firstName, lastName, email, currentSymptoms, emergencyLevel, address, phoneNumber } = req.body;

    // Check for existing patient using findExistingPatient (from second file)
    const existingPatient = await EmergencyPatient.findExistingPatient(firstName, lastName, email);
    let patient;
    let isNew = !existingPatient;

    if (existingPatient) {
      console.log(`Patient ${firstName} ${lastName} existe d√©j√†. Mise √† jour.`);
      patient = await EmergencyPatient.findByIdAndUpdate(
        existingPatient._id,
        {
          ...req.body,
          status: 'Demande Enregistr√©e',
          isNewPatient: false,
          $push: {
            previousVisits: {
              symptoms: currentSymptoms || 'N/A',
              visitDate: new Date(),
              doctor: existingPatient.assignedDoctor,
            },
          },
        },
        { new: true }
      );
    } else {
      console.log(`Nouveau patient: ${firstName} ${lastName}. Cr√©ation.`);
      patient = new EmergencyPatient({ ...req.body, isNewPatient: true });
      await patient.save();
    }

    const availableDoctor = await findAvailableDoctor();
    let assignedDoctorDetails = null;

    if (availableDoctor) {
      patient.assignedDoctor = availableDoctor._id;
      patient.status = 'M√©decin Assign√©';
      await patient.save();
      try {
        await User.findByIdAndUpdate(availableDoctor._id, { isAvailable: false });
        console.log(`M√©decin ${availableDoctor.username} (ID: ${availableDoctor._id}) mis √† jour √† 'Occup√©'.`);
      } catch (doctorUpdateError) {
        console.error(`ERREUR CRITIQUE: √âchec MAJ dispo m√©decin ${availableDoctor._id}.`, doctorUpdateError);
      }

      console.log(`M√©decin ${availableDoctor.username} assign√© au patient ${patient.firstName} ${patient.lastName}.`);

      assignedDoctorDetails = {
        _id: availableDoctor._id,
        username: availableDoctor.username,
        specialization: availableDoctor.specialization,
      };

      // WebSocket Notifications
      const doctorAssignmentPayload = {
        type: 'doctor_assignment',
        message: `You are assigned to patient: ${patient.firstName} ${patient.lastName}.`,
        patientId: patient._id,
        patientName: `${patient.firstName} ${patient.lastName}`,
      };
      const nurseNotificationPayload = {
        type: 'new_emergency_patient',
        message: `Patient: ${patient.firstName} ${patient.lastName} assigned to Dr. ${availableDoctor.username}.`,
        patientId: patient._id,
        patientName: `${patient.firstName} ${patient.lastName}`,
      };
      const doctorSocketId = userSockets.get(availableDoctor._id.toString());
      if (doctorSocketId) {
        io.to(doctorSocketId).emit('notification', doctorAssignmentPayload);
        console.log(`üì¨ WS Notif assignation envoy√©e m√©decin ${availableDoctor.username}`);
      } else {
        console.log(`‚ö†Ô∏è M√©decin assign√© ${availableDoctor.username} non connect√© (WS).`);
      }
      io.to('nurse-room').emit('notification', nurseNotificationPayload);
      console.log(`üì¨ WS Notif envoy√©e infirmi√®res.`);

      // SMS to Patient about Assigned Doctor
      if (phoneNumber) {
        const smsMessageToPatient = `Emergency Update: Dr. ${availableDoctor.username} (${availableDoctor.specialization || 'Doctor'}) has been assigned to your case. Please await further instructions or contact.`;
        try {
          console.log(`üì≤ Attempting SMS to PATIENT ${patient.firstName} ${patient.lastName} at ${phoneNumber} about assignment...`);
          const smsResultPatient = await sendSMS(smsMessageToPatient, phoneNumber);
          if (smsResultPatient.success) {
            console.log(`‚úÖ Assignment SMS sent successfully to PATIENT ${patient.firstName} ${patient.lastName}.`);
          } else {
            console.error(`‚ö†Ô∏è Failed assignment SMS to PATIENT ${patient.firstName} ${patient.lastName}: ${smsResultPatient.message || 'Unknown error'}`);
          }
        } catch (smsErrorPatient) {
          console.error(`‚ùå Critical error sending assignment SMS to PATIENT ${patient.firstName} ${patient.lastName}:`, smsErrorPatient);
        }
      } else {
        console.warn(`‚ö†Ô∏è Cannot send assignment SMS to patient ${patient.firstName} ${patient.lastName}: Phone number missing.`);
      }
    } else {
      console.warn(`‚ö†Ô∏è Aucun m√©decin disponible pour ${patient.firstName} ${patient.lastName}.`);
      const notificationPayloadNoDoctor = {
        type: 'new_emergency_patient_no_doctor',
        message: `New emergency patient registered: ${patient.firstName} ${patient.lastName}. No doctor currently available.`,
        patientId: patient._id,
        patientName: `${patient.firstName} ${patient.lastName}`,
        symptoms: currentSymptoms,
        emergencyLevel: emergencyLevel,
        timestamp: new Date(),
      };
      io.to('nurse-room').emit('notification', notificationPayloadNoDoctor);
      io.to('doctor-room').emit('notification', notificationPayloadNoDoctor);
    }

    // Fetch final patient details for response
    const responsePatient = await EmergencyPatient.findById(patient._id)
      .populate('assignedDoctor', 'username specialization email profileImage phoneNumber')
      .populate('medicalRecord', 'accessCode');

    res.status(201).json({
      patient: responsePatient,
      isNewPatient: isNew,
      patientCode: responsePatient.patientCode,
    });
  } catch (error) {
    console.error("‚ùå Erreur cr√©ation/mise √† jour patient d'urgence:", error);
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map(val => val.message);
      res.status(400).json({ message: "Erreur de validation", details: messages });
    } else {
      res.status(500).json({ message: 'Erreur Serveur Interne', error: error.message });
    }
  }
});

// GET /:id/medical-access-code
router.get('/:id/medical-access-code', async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID patient invalide" });
  }
  try {
    const patient = await EmergencyPatient.findById(id);
    if (!patient) return res.status(404).json({ message: "Patient non trouv√©" });
    const medicalRecord = await MedicalRecord.findOne({ patientId: id })
      .select('accessCode')
      .lean();
    if (!medicalRecord) {
      return res.status(404).json({
        message: "Dossier m√©dical non trouv√©",
        shouldDisplay: false,
      });
    }
    res.status(200).json({
      accessCode: medicalRecord.accessCode,
      shouldDisplay: true,
    });
  } catch (error) {
    console.error("Erreur r√©cup√©ration code acc√®s:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// GET /
router.get('/', async (req, res) => {
  try {
    const emergencyPatients = await EmergencyPatient.find()
      .populate('assignedDoctor', 'username specialization')
      .sort({ createdAt: -1 });
    res.status(200).json(emergencyPatients);
  } catch (error) {
    console.error("Erreur r√©cup√©ration patients:", error);
    res.status(500).json({ message: "Erreur serveur" });
  }
});

// GET /:id/details
router.get('/:id/details', async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID invalide" });
  }
  try {
    const patient = await EmergencyPatient.findById(id)
      .populate('assignedDoctor', 'username specialization email profileImage');
    if (!patient) return res.status(404).json({ message: "Patient non trouv√©" });
    res.status(200).json(patient);
  } catch (error) {
    console.error("Erreur d√©tails patient:", error);
    res.status(500).json({ message: "Erreur serveur" });
  }
});

// PUT /:id/status
router.put('/:id/status', authenticateToken, async (req, res) => {
  const io = req.io;
  const userSockets = req.userSockets;
  try {
    const { id } = req.params;
    const { status } = req.body;
    const userId = req.user.id;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const allowedStatuses = ['Demande Enregistr√©e', 'En Cours d\'Examen', 'M√©decin Assign√©', 'M√©decin En Route', 'Trait√©', 'Annul√©'];
    if (!allowedStatuses.includes(status)) {
      return res.status(400).json({ message: "Statut invalide" });
    }

    const updatedPatient = await EmergencyPatient.findByIdAndUpdate(
      id,
      { status },
      { new: true }
    ).populate('assignedDoctor', 'username specialization email profileImage');

    if (!updatedPatient) {
      return res.status(404).json({ message: "Patient non trouv√©" });
    }

    // WebSocket Notification Logic
    const statusUpdatePayload = {
      type: 'patient_status_update',
      message: `Statut du patient ${updatedPatient.firstName} ${updatedPatient.lastName} mis √† jour √†: ${status}.`,
      patientId: updatedPatient._id,
      patientName: `${updatedPatient.firstName} ${updatedPatient.lastName}`,
      newStatus: status,
      timestamp: new Date(),
    };
    if (updatedPatient.assignedDoctor) {
      const doctorSocketId = userSockets.get(updatedPatient.assignedDoctor._id.toString());
      if (doctorSocketId) {
        io.to(doctorSocketId).emit('notification', statusUpdatePayload);
        console.log(`üì¨ Notification de statut envoy√©e au m√©decin ${updatedPatient.assignedDoctor.username}`);
      }
    }
    io.to('nurse-room').emit('notification', statusUpdatePayload);
    console.log(`üì¨ Notification de statut envoy√©e √† toutes les infirmi√®res connect√©es.`);

    // Medical Record Creation Logic
    if (['M√©decin En Route', 'Trait√©'].includes(status)) {
      let medicalRecord = await MedicalRecord.findOne({ patientId: id });
      if (!medicalRecord) {
        console.log(`Cr√©ation du dossier m√©dical pour le patient ${id}...`);
        const medicalRecordData = {
          patientId: id,
          creator: updatedPatient.assignedDoctor?._id || userId,
          emergencyContact: { phone: updatedPatient.emergencyContact },
          knownAllergies: updatedPatient.allergies ? updatedPatient.allergies.split(',').map(s => s.trim()) : [],
        };
        if (updatedPatient.bloodType) {
          medicalRecordData.bloodType = updatedPatient.bloodType;
        }
        medicalRecord = new MedicalRecord(medicalRecordData);
        await medicalRecord.save();
        console.log(`Dossier m√©dical ${medicalRecord._id} cr√©√©.`);

        await EmergencyPatient.findByIdAndUpdate(id, { medicalRecord: medicalRecord._id });

        console.log(`Cr√©ation du fichier PatientInformation pour le dossier ${medicalRecord._id}...`);
        
        const patientFile = new PatientFile({
          medicalRecord: medicalRecord._id,
          creator: updatedPatient.assignedDoctor?._id || userId,
          type: "PatientInformation",
          details: {
            patientInfo: {
              firstName: updatedPatient.firstName,
              lastName: updatedPatient.lastName,
              dateOfBirth: updatedPatient.dateOfBirth,
              gender: updatedPatient.gender,
              phoneNumber: updatedPatient.phoneNumber,
              email: updatedPatient.email,
              address: updatedPatient.address,
              emergencyContact: updatedPatient.emergencyContact,
              insuranceInfo: updatedPatient.insuranceInfo,
              allergies: updatedPatient.allergies,
              currentMedications: updatedPatient.currentMedications,
              medicalHistory: updatedPatient.medicalHistory,
              currentSymptoms: updatedPatient.currentSymptoms,
              painLevel: updatedPatient.painLevel,
              emergencyLevel: updatedPatient.emergencyLevel,
            },
          },
        });
        await patientFile.save();
        console.log(`Fichier PatientInformation ${patientFile._id} cr√©√©.`);
      }
    }

    // SMS Status Update to Patient
    const patientPhoneNumber = updatedPatient.phoneNumber;
    if (patientPhoneNumber) {
      const smsMessage = `Emergency Update: Your request status has been updated to: ${status}.`;
      try {
        console.log(`üì≤ Attempting status update SMS to PATIENT ${updatedPatient.firstName} ${updatedPatient.lastName} at ${patientPhoneNumber}...`);
        const smsResult = await sendSMS(smsMessage, patientPhoneNumber);
        if (smsResult.success) {
          console.log(`‚úÖ Status SMS sent successfully to PATIENT ${updatedPatient._id}.`);
        } else {
          console.error(`‚ö†Ô∏è Failed status SMS to PATIENT ${updatedPatient._id}: ${smsResult.message || 'Unknown error'}`);
        }
      } catch (smsError) {
        console.error(`‚ùå Critical error sending status SMS to PATIENT ${updatedPatient._id}:`, smsError);
      }
    } else {
      console.warn(`‚ö†Ô∏è Cannot send status SMS to patient ${updatedPatient._id}: Phone number missing.`);
    }

    res.status(200).json(updatedPatient);
  } catch (error) {
    console.error("‚ùå Erreur mise √† jour statut:", error);
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map(val => `${val.path}: ${val.message}`);
      console.error("Validation Error during MedicalRecord save:", error.errors);
      return res.status(400).json({ message: "Erreur de validation lors de la cr√©ation du dossier m√©dical", details: messages });
    }
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// GET /:id/medical-record
router.get('/:id/medical-record', authenticateToken, async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID patient invalide" });
  }
  try {
    const patient = await EmergencyPatient.findById(id);
    if (!patient) return res.status(404).json({ message: "Patient non trouv√©" });

    const medicalRecord = await MedicalRecord.findOne({ patientId: id })
      .populate('patientId', 'firstName lastName dateOfBirth gender phoneNumber email address')
      .lean();

    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√© pour ce patient" });
    }

    if (medicalRecord.creator) {
      try {
        medicalRecord.creator = await User.findById(medicalRecord.creator)
          .select('username role specialization')
          .lean();
      } catch (userError) {
        console.warn(`Could not populate creator ${medicalRecord.creator}: ${userError.message}`);
        medicalRecord.creator = { _id: medicalRecord.creator, username: 'Utilisateur inconnu' };
      }
    }

    const patientFiles = await PatientFile.find({ medicalRecord: medicalRecord._id })
      .populate('creator', 'username role')
      .sort({ createdAt: -1 })
      .lean();

    const result = { ...medicalRecord, patientFiles };

    res.status(200).json(result);
  } catch (error) {
    console.error("Erreur r√©cup√©ration dossier m√©dical:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// DELETE /:id
router.delete('/:id', async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID invalide" });
  }
  try {
    const deletedPatient = await EmergencyPatient.findByIdAndDelete(id);
    if (!deletedPatient) return res.status(404).json({ message: "Patient non trouv√©" });

    if (deletedPatient.assignedDoctor) {
      try {
        await User.findByIdAndUpdate(deletedPatient.assignedDoctor, { isAvailable: true });
        console.log(`‚úÖ M√©decin ${deletedPatient.assignedDoctor} rendu disponible apr√®s suppression du cas ${id}.`);
      } catch (docError) {
        console.error(`‚ö†Ô∏è Erreur lors de la remise √† dispo du m√©decin ${deletedPatient.assignedDoctor}: ${docError.message}`);
      }
    }
    res.status(200).json({ message: "Patient d'urgence supprim√© avec succ√®s", deletedId: id });
  } catch (error) {
    console.error("Erreur suppression patient:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// GET /by-doctor/:doctorId
router.get('/by-doctor/:doctorId', authenticateToken, async (req, res) => {
  const { doctorId } = req.params;
  if (!mongoose.Types.ObjectId.isValid(doctorId)) {
    return res.status(400).json({ message: "ID m√©decin invalide" });
  }
  try {
    const patients = await EmergencyPatient.find({ assignedDoctor: doctorId })
      .populate('assignedDoctor', 'username specialization email profileImage')
      .populate('medicalRecord', '_id')
      .sort({ createdAt: -1 });
    res.status(200).json(patients);
  } catch (error) {
    console.error("Erreur r√©cup√©ration patients par m√©decin:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// GET /stats/total
router.get('/stats/total', async (req, res) => {
  try {
    const totalPatients = await EmergencyPatient.countDocuments();
    res.status(200).json({ total: totalPatients });
  } catch (error) {
    console.error("Erreur r√©cup√©ration nombre total de patients:", error);
    res.status(500).json({ message: "Erreur serveur" });
  }
});

// GET /stats/today
router.get('/stats/today', async (req, res) => {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const patientsToday = await EmergencyPatient.countDocuments({
      createdAt: { $gte: today, $lt: tomorrow },
    });
    res.status(200).json({ today: patientsToday });
  } catch (error) {
    console.error("Erreur r√©cup√©ration nombre de patients aujourd'hui:", error);
    res.status(500).json({ message: "Erreur serveur" });
  }
});

// GET /:id/estimated-wait-time
router.get('/:id/estimated-wait-time', async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({ message: "ID patient invalide" });
  }
  try {
    const estimatedTime = await getEstimatedWaitTime(id);
    res.json({ estimatedWaitTime: estimatedTime });
  } catch (error) {
    console.error(`Erreur API get wait time pour ${id}:`, error);
    if (error.message === "Patient non trouv√©.") {
      return res.status(404).json({ message: error.message });
    }
    res.status(500).json({ message: "Erreur lors du calcul du temps d'attente estim√©." });
  }
});

// GET /stats/levels
router.get('/stats/levels', async (req, res) => {
  try {
    const stats = await EmergencyPatient.getEmergencyLevelStats();
    res.json(stats);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// GET /stats/trends
router.get('/stats/trends', async (req, res) => {
  try {
    const { period = 'day' } = req.query;
    const trends = await EmergencyPatient.getEmergencyTrends(period);
    res.json(trends);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

export default router;
</file>

<file path="routes/medicalRecords.js">
import express from "express";
import mongoose from "mongoose";
import { authenticateToken } from "../middleware/authMiddleware.js";
import MedicalRecord from "../models/MedicalRecord.js";
import EmergencyPatient from "../models/EmergencyPatient.js";
import PatientFile from "../models/PatientFile.js";
import { User } from "../models/User.js"; // <-- Ajoutez cette ligne

const router = express.Router();

// Cr√©er un MedicalRecord
router.post("/", authenticateToken, async (req, res) => {
  try {
    const { patientId } = req.body;

    if (!mongoose.Types.ObjectId.isValid(patientId)) {
      return res.status(400).json({ message: "ID patient invalide" });
    }

    const patient = await EmergencyPatient.findById(patientId);
    if (!patient) {
      return res.status(404).json({ message: "Patient non trouv√©" });
    }

    // V√©rifier si un MedicalRecord existe d√©j√†
    const existingRecord = await MedicalRecord.findOne({ patientId });
    if (existingRecord) {
      return res.status(400).json({ message: "Un dossier m√©dical existe d√©j√† pour ce patient" });
    }

    const medicalRecord = new MedicalRecord({
      patientId,
      creator: req.user._id,
      emergencyContact: patient.emergencyContact ? { phone: patient.emergencyContact } : undefined,
      knownAllergies: patient.allergies ? patient.allergies.split(',') : [],
      bloodType: patient.bloodType,
    });

    await medicalRecord.save();

    // Mettre √† jour le patient avec la r√©f√©rence au MedicalRecord
    patient.medicalRecord = medicalRecord._id;
    await patient.save();

    res.status(201).json(medicalRecord);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// R√©cup√©rer tous les MedicalRecords
router.get("/", authenticateToken, async (req, res) => {
  try {
    const records = await MedicalRecord.find()
      .populate('patientId', 'firstName lastName dateOfBirth')
      .populate('creator', 'username specialization');
    res.status(200).json(records);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

router.get("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    // 1. R√©cup√©rer le dossier m√©dical de base
    const record = await MedicalRecord.findById(id)
      .populate('patientId', 'firstName lastName dateOfBirth gender phoneNumber')
      .populate('creator', 'username role specialization')
      .lean();

    if (!record) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    // 2. R√©cup√©rer les fichiers patients s√©par√©ment avec les cr√©ateurs
    const patientFiles = await PatientFile.aggregate([
      { $match: { medicalRecord: new mongoose.Types.ObjectId(id) } },
      { $sort: { createdAt: -1 } },
      {
        $lookup: {
          from: "users",
          localField: "creator",
          foreignField: "_id",
          as: "creatorInfo"
        }
      },
      { $unwind: { path: "$creatorInfo", preserveNullAndEmptyArrays: true } },
      {
        $project: {
          type: 1,
          notes: 1,
          details: 1,
          createdAt: 1,
          updatedAt: 1,
          creator: {
            username: "$creatorInfo.username",
            role: "$creatorInfo.role"
          }
        }
      }
    ]);

    // 3. Combiner les r√©sultats
    const result = {
      ...record,
      patientFiles
    };

    res.status(200).json(result);

  } catch (error) {
    console.error("Error fetching medical record:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});
// Mettre √† jour un MedicalRecord
router.put("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const updatedRecord = await MedicalRecord.findByIdAndUpdate(id, updateData, {
      new: true,
      runValidators: true
    });

    if (!updatedRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    res.status(200).json(updatedRecord);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Supprimer un MedicalRecord (avec ses PatientFiles associ√©s)
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    // Supprimer d'abord les PatientFiles associ√©s
    await PatientFile.deleteMany({ medicalRecord: id });

    // Puis supprimer le MedicalRecord
    const deletedRecord = await MedicalRecord.findByIdAndDelete(id);

    if (!deletedRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    // Mettre √† jour le patient en retirant la r√©f√©rence
    await EmergencyPatient.updateOne(
      { medicalRecord: id },
      { $unset: { medicalRecord: "" } }
    );

    res.status(200).json({ message: "Dossier m√©dical et fichiers associ√©s supprim√©s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
/**
 * @route POST /api/medical-records/:recordId/files
 * @description Ajoute un fichier patient √† un dossier m√©dical
 * @body {type, notes, details}
 * @access Prot√©g√© (authentification requise)
 */
router.post('/:recordId/files', authenticateToken, async (req, res) => {
  const { recordId } = req.params;
  const { type, notes, details } = req.body;

  try {
    // V√©rifier que le dossier m√©dical existe
    const medicalRecord = await MedicalRecord.findById(recordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    // Cr√©er le nouveau fichier patient
    const newFile = new PatientFile({
      medicalRecord: recordId,
      creator: req.user._id, // L'utilisateur authentifi√©
      type,
      notes,
      details,
      dateRecorded: new Date()
    });

    // Sauvegarder le fichier
    await newFile.save();

    // Mettre √† jour la date de derni√®re modification du dossier m√©dical
    medicalRecord.lastUpdated = new Date();
    await medicalRecord.save();

    res.status(201).json(newFile);

  } catch (error) {
    console.error("Erreur cr√©ation fichier patient:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
});
// Nouvelle route pour acc√©der au dossier m√©dical par code
router.get('/by-access-code/:accessCode', async (req, res) => {
  try {
      const { accessCode } = req.params;
      
      // 1. Trouver le dossier m√©dical de base
      const medicalRecord = await MedicalRecord.findOne({ accessCode })
          .populate('patientId', 'firstName lastName dateOfBirth gender phoneNumber email')
          .populate('creator', 'username role specialization')
          .lean();

      if (!medicalRecord) {
          return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
      }

      // 2. R√©cup√©rer les fichiers patients s√©par√©ment
      const patientFiles = await PatientFile.find({ 
          medicalRecord: medicalRecord._id 
      })
      .sort({ createdAt: -1 })
      .lean();

      // 3. R√©cup√©rer les informations des cr√©ateurs des fichiers
      const creatorIds = patientFiles.map(file => file.creator).filter(Boolean);
      const creators = creatorIds.length > 0 ? await User.find({ 
          _id: { $in: creatorIds } 
      }).select('username role').lean() : [];

      // 4. Cr√©er un mapping des cr√©ateurs
      const creatorMap = creators.reduce((map, creator) => {
          map[creator._id.toString()] = creator;
          return map;
      }, {});

      // 5. Combiner les r√©sultats
      const result = {
          ...medicalRecord,
          patientFiles: patientFiles.map(file => ({
              ...file,
              creator: file.creator ? creatorMap[file.creator.toString()] : null
          }))
      };

      res.status(200).json(result);
  } catch (error) {
      console.error("Erreur r√©cup√©ration dossier m√©dical:", error);
      res.status(500).json({ 
          message: "Erreur serveur", 
          error: error.message 
      });
  }
});
router.get('/:recordId/files', authenticateToken, async (req, res) => {
  const { recordId } = req.params;

  try {
    // V√©rifier que le dossier m√©dical existe
    const medicalRecord = await MedicalRecord.findById(recordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    // R√©cup√©rer les fichiers sans populate
    const patientFiles = await PatientFile.find({ medicalRecord: recordId })
      .sort({ dateRecorded: -1 })
      .lean(); // Convertit en objets JavaScript simples

    // R√©cup√©rer tous les cr√©ateurs en une seule requ√™te
    const creatorIds = patientFiles.map(file => file.creator).filter(id => id);
    const creators = await User.find({ _id: { $in: creatorIds } })
      .select('username role')
      .lean();

    // Cr√©er un map pour un acc√®s rapide
    const creatorMap = creators.reduce((map, creator) => {
      map[creator._id] = creator;
      return map;
    }, {});

    // Combiner les fichiers avec leurs cr√©ateurs
    const filesWithCreators = patientFiles.map(file => ({
      ...file,
      creator: file.creator ? creatorMap[file.creator.toString()] : null
    }));

    res.status(200).json(filesWithCreators);

  } catch (error) {
    console.error("Erreur r√©cup√©ration fichiers patients:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message 
    });
  }
});
// Dans medicalRecordRoutes.js
import { generateMedicalRecordPDF } from '../utils/pdfGenerator.js'; // Ajoutez cette ligne en haut

router.get('/by-access-code/:accessCode/download-pdf', async (req, res) => {
  try {
    const { accessCode } = req.params;
    
    const medicalRecord = await MedicalRecord.findOne({ accessCode })
      .populate('patientId')
      .lean();

    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    const patientFiles = await PatientFile.find({ 
      medicalRecord: medicalRecord._id 
    }).lean();

    const pdfBuffer = await generateMedicalRecordPDF(medicalRecord, patientFiles);

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename=dossier_medical_${accessCode}.pdf`);
    res.send(pdfBuffer);

  } catch (error) {
    console.error("Erreur g√©n√©ration PDF:", error);
    res.status(500).json({ 
      message: "Erreur serveur", 
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});


export default router;
</file>

<file path="routes/notifications.js">
// routes/notifications.js
import express from 'express';
import { authenticateToken } from '../middleware/authMiddleware.js';
import Notification from '../models/Notification.js';
import mongoose from 'mongoose';

const router = express.Router();

// GET /api/notifications - R√©cup√©rer les notifications pour l'utilisateur connect√©
router.get('/', authenticateToken, async (req, res) => {
    try {
        const notifications = await Notification.find({ recipientId: req.user.id })
            .sort({ createdAt: -1 }) // Les plus r√©centes en premier
            .limit(50); // Limiter √† 50 pour la performance
        const unreadCount = await Notification.countDocuments({ recipientId: req.user.id, isRead: false });

        res.json({ notifications, unreadCount });
    } catch (error) {
        console.error("Error fetching notifications:", error);
        res.status(500).json({ message: "Erreur serveur lors de la r√©cup√©ration des notifications." });
    }
});

// PATCH /api/notifications/:id/read - Marquer une notification comme lue
router.patch('/:id/read', authenticateToken, async (req, res) => {
    try {
        const notification = await Notification.findOneAndUpdate(
            { _id: req.params.id, recipientId: req.user.id }, // S'assurer que la notif appartient √† l'utilisateur
            { isRead: true },
            { new: true }
        );
        if (!notification) {
            return res.status(404).json({ message: "Notification non trouv√©e ou acc√®s non autoris√©." });
        }
        res.json(notification);
    } catch (error) {
        console.error("Error marking notification as read:", error);
        res.status(500).json({ message: "Erreur serveur." });
    }
});

// PATCH /api/notifications/read-all - Marquer toutes les notifications comme lues
router.patch('/read-all', authenticateToken, async (req, res) => {
    try {
        await Notification.updateMany(
            { recipientId: req.user.id, isRead: false },
            { isRead: true }
        );
        res.json({ message: "Toutes les notifications ont √©t√© marqu√©es comme lues." });
    } catch (error) {
        console.error("Error marking all notifications as read:", error);
        res.status(500).json({ message: "Erreur serveur." });
    }
});

// DELETE /api/notifications/:id - Supprimer une notification (optionnel)
router.delete('/:id', authenticateToken, async (req, res) => {
    try {
        const result = await Notification.findOneAndDelete({ _id: req.params.id, recipientId: req.user.id });
        if (!result) {
            return res.status(404).json({ message: "Notification non trouv√©e ou acc√®s non autoris√©." });
        }
        res.json({ message: "Notification supprim√©e." });
    } catch (error) {
        console.error("Error deleting notification:", error);
        res.status(500).json({ message: "Erreur serveur." });
    }
});

export default router;
</file>

<file path="routes/ocr.js">
import express from "express";
import { uploadImage } from "../middleware/fileUpload.js";
import { processImage } from "../services/ocrService.js";
import OcrResult from "../models/OcrResult.js";
import PatientFile from "../models/PatientFile.js";
import { authenticateToken } from "../middleware/authMiddleware.js";
import mongoose from "mongoose";

const router = express.Router();

router.post(
  "/process-image",
  authenticateToken,
  uploadImage.single("medicalImage"),
  async (req, res) => {
    try {
      const { medicalRecordId } = req.body;

      // Validation
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          error: "Aucune image t√©l√©charg√©e" 
        });
      }

      if (!medicalRecordId) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de dossier m√©dical requis" 
        });
      }

      if (!mongoose.Types.ObjectId.isValid(medicalRecordId)) {
        return res.status(400).json({ 
          success: false, 
          error: "ID de dossier m√©dical invalide" 
        });
      }

      // Traitement OCR
      const result = await processImage(req.file.path, medicalRecordId);

      // Transaction MongoDB
      const session = await mongoose.startSession();
      let savedOcr, savedFile;

      try {
        await session.withTransaction(async () => {
          // Sauvegarde r√©sultat OCR
          const ocrRecord = new OcrResult({
            medicalRecord: medicalRecordId,
            originalFilename: req.file.originalname,
            textResult: result.data.text,
            extractedData: result.data.extractedData
          });

          savedOcr = await ocrRecord.save({ session });

          // Sauvegarde fichier patient
          const patientFile = new PatientFile({
            medicalRecord: medicalRecordId,
            type: "Diagnostic",
            isOCRProcessed: true,
            ocrResults: savedOcr._id,
            details: {
              diagnosis: result.data.extractedData.diagnosis,
              diagnosticTests: result.data.extractedData.tests,
              patientInfo: {
                firstName: result.data.extractedData.patientName?.split(' ')[0] || 'Inconnu',
                lastName: result.data.extractedData.patientName?.split(' ').slice(1).join(' ') || 'Inconnu'
              }
            }
          });

          savedFile = await patientFile.save({ session });
        });
      } finally {
        await session.endSession();
      }

      // R√©ponse r√©ussie
      res.json({
        success: true,
        data: {
          text: result.data.text,
          extractedData: result.data.extractedData,
          databaseIds: {
            ocrId: savedOcr._id,
            fileId: savedFile._id
          }
        }
      });

    } catch (error) {
      console.error("Erreur OCR:", error);
      const errorMessage = error.message.includes("ENOENT") 
        ? "Fichier introuvable" 
        : error.message;
      
      res.status(500).json({
        success: false,
        error: `√âchec du traitement OCR: ${errorMessage}`
      });
    }
  }
);

export default router;
</file>

<file path="routes/patient.js">
import express from 'express';
import PatientFile from '../models/PatientFile.js';
import MedicalRecord from '../models/MedicalRecord.js';
import { classifyPatientNeeds } from '../services/classifierService.js'; // still using this name

const router = express.Router();

// POST /api/patients/:patientId/recommend
router.post('/:patientId/recommend', async (req, res) => {
  try {
    const { patientId } = req.params;
    const { noteOverride } = req.body;

    // 1. Find the MedicalRecord
    const medRecord = await MedicalRecord.findOne({ patientId });
    if (!medRecord) {
      return res.status(404).send({ error: 'Medical record not found for this patient' });
    }

    // 2. Fetch latest unarchived PatientFile
    const patientFile = await PatientFile.findOne({
      medicalRecord: medRecord._id,
      isArchived: false,
    }).sort({ dateRecorded: -1 });

    if (!patientFile) {
      return res.status(404).send({ error: 'Patient file not found for this record' });
    }

    // 3. Build prompt
    const prompt = noteOverride || 
      `Chief complaint: ${patientFile.details?.chiefComplaint || 'N/A'}. ` +
      `Vitals: ${JSON.stringify(patientFile.details?.vitalSigns || {})}. ` +
      `Notes: ${patientFile.notes || 'None'}.`;

    // 4. Generate recommendations
    const recommendations = await classifyPatientNeeds(prompt); // returns top 3 suggestions
    console.log('Recommendations:', recommendations);
    return res.send({ recommendations });

  } catch (err) {
    console.error('Error in recommend route:', err);
    return res.status(500).send({ error: 'Server error' });
  }
});

export default router;
</file>

<file path="routes/patientFile.js">
import express from "express";
import mongoose from "mongoose";
import { authenticateToken } from "../middleware/authMiddleware.js";
import PatientFile from "../models/PatientFile.js";
import MedicalRecord from "../models/MedicalRecord.js";

const router = express.Router();

// Cr√©er un PatientFile (associ√© √† un MedicalRecord)
router.post("/", authenticateToken, async (req, res) => {
  try {
    const { medicalRecordId, type, details, notes } = req.body;

    if (!mongoose.Types.ObjectId.isValid(medicalRecordId)) {
      return res.status(400).json({ message: "ID dossier m√©dical invalide" });
    }

    // V√©rifier que le MedicalRecord existe
    const medicalRecord = await MedicalRecord.findById(medicalRecordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical non trouv√©" });
    }

    const patientFile = new PatientFile({
      medicalRecord: medicalRecordId,
      creator: req.user._id,
      type,
      details,
      notes
    });

    await patientFile.save();

    res.status(201).json(patientFile);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// R√©cup√©rer tous les PatientFiles d'un MedicalRecord
router.get("/medical-record/:medicalRecordId", authenticateToken, async (req, res) => {
  try {
    const { medicalRecordId } = req.params;

    if (!mongoose.Types.ObjectId.isValid(medicalRecordId)) {
      return res.status(400).json({ message: "ID dossier m√©dical invalide" });
    }

    const files = await PatientFile.find({ medicalRecord: medicalRecordId })
      .sort({ dateRecorded: -1 })
      .populate('creator', 'username');

    res.status(200).json(files);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// R√©cup√©rer un PatientFile sp√©cifique
router.get("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const file = await PatientFile.findById(id).populate('creator', 'username');

    if (!file) {
      return res.status(404).json({ message: "Fichier patient non trouv√©" });
    }

    res.status(200).json(file);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Mettre √† jour un PatientFile
router.put("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const updatedFile = await PatientFile.findByIdAndUpdate(id, updateData, {
      new: true,
      runValidators: true
    });

    if (!updatedFile) {
      return res.status(404).json({ message: "Fichier patient non trouv√©" });
    }

    res.status(200).json(updatedFile);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Supprimer un PatientFile
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "ID invalide" });
    }

    const deletedFile = await PatientFile.findByIdAndDelete(id);

    if (!deletedFile) {
      return res.status(404).json({ message: "Fichier patient non trouv√©" });
    }

    res.status(200).json({ message: "Fichier patient supprim√©" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

export default router;
</file>

<file path="routes/profile.js">
// In your routes/profile.js
import express from 'express';
import { User, Patient, Doctor, Nurse, Administrator } from '../models/User.js';
import { authenticateToken } from '../middleware/authMiddleware.js';
import cors from "cors";
import dotenv from "dotenv";

const router = express.Router();
router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();

router.get('/profile', authenticateToken, async (req, res) => {
  console.log("üì© Requ√™te re√ßue :", req.body);
  try {
    // Get complete user document including role-specific fields
    const user = await User.findById(req.user.id).select('-password -resetPasswordToken -resetPasswordExpires -otp -otpExpires');
    
    if (!user) {
      return res.status(404).json({ message: "Profil non trouv√©" });
    }
    const profileImageUrl = user.profileImage ? `http://localhost:8089/${user.profileImage}` : null;

    // Format data based on user role
    let profileData = {
      personal: {
        username: user.username,
        email: user.email,
        phoneNumber: user.phoneNumber,
        role: user.role,
        profileImage: user.profileImage
      }
    };

    // Add role-specific data
    switch (user.role) {
      case 'Patient':
        profileData.medical = {
          name: user.name,
          dateOfBirth: user.dateOfBirth,
          gender: user.gender,
          address: user.address,
          emergencyContact: user.emergencyContact,
          bloodType: user.bloodType,
          allergies: user.allergies || []
        };
        break;

      case 'Doctor':
        profileData.professional = {
          badgeNumber: user.badgeNumber,
          specialization: user.specialization,
          licenseNumber: user.licenseNumber
        };
        break;

      case 'Nurse':
        profileData.professional = {
          badgeNumber: user.badgeNumber,
          shift: user.shift,
          licenseNumber: user.licenseNumber
        };
        break;

      case 'Administrator':
        profileData.professional = {
          badgeNumber: user.badgeNumber
        };
        break;
    }

    res.status(200).json(profileData);
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update profile endpoint
router.put('/profile', authenticateToken, async (req, res) => {
  try {
    const { personal, medical, professional } = req.body;
    const user = await User.findById(req.user.id);

    if (!user) {
      return res.status(404).json({ message: "Profil non trouv√©" });
    }

    // Update common fields
    if (personal) {
      user.username = personal.username || user.username;
      user.email = personal.email || user.email;
      user.phoneNumber = personal.phoneNumber || user.phoneNumber;
    }

    // Update role-specific fields
    switch (user.role) {
      case 'Patient':
        if (medical) {
          user.name = medical.name || user.name;
          user.dateOfBirth = medical.dateOfBirth || user.dateOfBirth;
          user.gender = medical.gender || user.gender;
          user.address = medical.address || user.address;
          user.emergencyContact = medical.emergencyContact || user.emergencyContact;
          user.bloodType = medical.bloodType || user.bloodType;
          user.allergies = medical.allergies || user.allergies;
        }
        break;

      case 'Doctor':
      case 'Nurse':
        if (professional) {
          user.badgeNumber = professional.badgeNumber || user.badgeNumber;
          user.licenseNumber = professional.licenseNumber || user.licenseNumber;
          if (user.role === 'Doctor') {
            user.specialization = professional.specialization || user.specialization;
          } else {
            user.shift = professional.shift || user.shift;
          }
        }
        break;

      case 'Administrator':
        if (professional) {
          user.badgeNumber = professional.badgeNumber || user.badgeNumber;
        }
        break;
    }

    await user.save();
    
    // Return updated profile in same format as GET
    res.redirect(303, '/api/profile');
  } catch (error) {
    console.error("Erreur serveur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

export default router;
</file>

<file path="routes/resource.js">
import express from "express";
import mongoose from "mongoose";
import cors from "cors";
import dotenv from "dotenv";
import { authenticateToken } from "../middleware/authMiddleware.js";
import Resource from "../models/Resource.js";

const router = express.Router();

// Enable CORS for frontend
router.use(cors({ origin: process.env.FRONTEND_URL || "http://localhost:3000", credentials: true }));
dotenv.config();

/**
 * Create a new resource (admin only)
 */
router.post("/", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Access denied" });
    }
    const newRes = new Resource(req.body);
    const saved = await newRes.save();
    res.status(201).json(saved);
  } catch (error) {
    console.error("Error creating resource:", error);
    res.status(400).json({ message: "Invalid data", error: error.message });
  }
});

/**
 * Get all resources (admin, doctor, nurse)
 */
router.get("/", authenticateToken, async (req, res) => {
  try {
    const allowed = ["Administrator", "Doctor", "Nurse"];
    if (!allowed.includes(req.user.role)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const list = await Resource.find();
    res.status(200).json(list);
  } catch (error) {
    console.error("Error fetching resources:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
});

/**
 * Get a resource by ID
 */
router.get("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "Invalid resource ID" });
    }
    const resrc = await Resource.findById(id);
    if (!resrc) {
      return res.status(404).json({ message: "Resource not found" });
    }
    res.status(200).json(resrc);
  } catch (error) {
    console.error("Error fetching resource:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
});

/**
 * Update a resource by ID (admin, nurse)
 */
router.put("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const allowed = ["Administrator", "Nurse"];
    if (!allowed.includes(req.user.role)) {
      return res.status(403).json({ message: "Access denied" });
    }
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "Invalid resource ID" });
    }
    const updated = await Resource.findByIdAndUpdate(id, req.body, { new: true, runValidators: true });
    if (!updated) {
      return res.status(404).json({ message: "Resource not found" });
    }
    res.status(200).json(updated);
  } catch (error) {
    console.error("Error updating resource:", error);
    res.status(400).json({ message: "Invalid data", error: error.message });
  }
});

/**
 * Delete a resource by ID (admin only)
 */
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Access denied" });
    }
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: "Invalid resource ID" });
    }
    const deleted = await Resource.findByIdAndDelete(id);
    if (!deleted) {
      return res.status(404).json({ message: "Resource not found" });
    }
    res.status(200).json({ message: "Resource deleted successfully" });
  } catch (error) {
    console.error("Error deleting resource:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
});
router.post("/:id/allocate", authenticateToken, async (req, res) => {
    try {
      const allowed = ['Administrator','Nurse'];
      if (!allowed.includes(req.user.role)) return res.status(403).json({ message: 'Access denied' });
      const { id } = req.params;
      const { patientId } = req.body;
      if (!mongoose.Types.ObjectId.isValid(id) || !mongoose.Types.ObjectId.isValid(patientId)) {
        return res.status(400).json({ message: 'Invalid ID(s)' });
      }
      const resource = await Resource.findById(id);
      if (!resource) return res.status(404).json({ message: 'Resource not found' });
      resource.allocatedTo = patientId;
      resource.status = 'in-maintenance';
      await resource.save();
      res.status(200).json(resource);
    } catch (error) {
      console.error('Allocation error:', error);
      res.status(500).json({ message: 'Server error', error: error.message });
    }
  });
  
// Export the router
export default router;
</file>

<file path="routes/users.js">
import express from "express";
import { User } from "../models/User.js";
import { authenticateToken } from "../middleware/authMiddleware.js";
import cors from "cors";
import dotenv from "dotenv";
import mongoose from "mongoose";
import SharedMedicalRecord from "../models/SharedMedicalRecord.js";
import AuditLog from "../models/AuditLog.js";
import MedicalRecord from "../models/MedicalRecord.js"; // <-- Import crucial ici


const router = express.Router();
router.use(cors({ origin: "http://localhost:3000", credentials: true }));
dotenv.config();

// Get all doctors (accessible to doctors and admins)
router.get("/doctor/doctors", authenticateToken, async (req, res) => {
  try {
    if (!["Doctor", "Administrator"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const doctors = await User.find({ role: "Doctor" }).select("_id username");
    res.status(200).json(doctors);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Partager un dossier m√©dical avec un autre m√©decin
router.post('/medical-records/:recordId/share', authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== 'Doctor') {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins" });
    }

    const { recordId } = req.params;
    const { recipientId, note } = req.body;

    // Validation de l'ID du destinataire
    if (!mongoose.Types.ObjectId.isValid(recipientId)) {
      return res.status(400).json({ message: "ID m√©decin destinataire invalide" });
    }

    // R√©cup√©ration du m√©decin destinataire
    const recipientDoctor = await User.findOne({
      _id: recipientId,
      role: 'Doctor'
    });

    if (!recipientDoctor) {
      return res.status(404).json({ message: "M√©decin destinataire introuvable" });
    }

    // V√©rification de l'auto-partage (corrig√©)
    if (recipientId === req.user.id) { // <-- Correction ici
      return res.status(400).json({ message: "Impossible de partager avec vous-m√™me" });
    }

    // V√©rification du dossier m√©dical
    const medicalRecord = await MedicalRecord.findById(recordId);
    if (!medicalRecord) {
      return res.status(404).json({ message: "Dossier m√©dical introuvable" });
    }

    // Cr√©ation du partage
    const newShare = new SharedMedicalRecord({
      medicalRecordId: recordId,
      sharerId: req.user.id, // Utilisation de .id
      recipientId: recipientId,
      note: note || "Partage de dossier m√©dical"
    });

    await newShare.save();

    // Journalisation
    await AuditLog.create({
      action: 'SHARE_MEDICAL_RECORD',
      userId: req.user.id, // Utilisation de .id
      details: `Partage du dossier ${recordId} avec le Dr. ${recipientDoctor.username}`
    });

    res.status(201).json({
      message: "Dossier partag√© avec succ√®s",
      shareDetails: newShare
    });

  } catch (error) {
    console.error("Erreur lors du partage du dossier:", error);
    res.status(500).json({
      message: "Erreur serveur",
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});
// R√©cup√©rer les dossiers partag√©s avec le m√©decin connect√©
router.get('/medical-records/shared', authenticateToken, async (req, res) => {
  try {
    // V√©rifier que l'utilisateur est un m√©decin
    if (req.user.role !== 'Doctor') {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins" });
    }

    const sharedRecords = await SharedMedicalRecord.find({ recipientId: req.user._id })
      .populate({
        path: 'medicalRecordId',
        populate: [
          {
            path: 'patientId',
            model: 'EmergencyPatient',
            select: 'firstName lastName dateOfBirth gender'
          },
          {
            path: 'creator',
            model: 'User',
            select: 'username specialization'
          }
        ]
      })
      .populate('sharerId', 'username role')
      .sort({ sharedAt: -1 });

    // Formater la r√©ponse
    const formattedRecords = sharedRecords.map(record => ({
      _id: record._id,
      sharedAt: record.sharedAt,
      note: record.note,
      sharer: record.sharerId,
      medicalRecord: {
        _id: record.medicalRecordId._id,
        patient: record.medicalRecordId.patientId,
        creator: record.medicalRecordId.creator,
        bloodType: record.medicalRecordId.bloodType,
        lastUpdated: record.medicalRecordId.lastUpdated
      }
    }));

    res.status(200).json(formattedRecords);

  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des dossiers partag√©s:", error);
    res.status(500).json({
      message: "Erreur serveur",
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});
function formatFileDetails(file) {
  const baseDetails = {
    id: file._id,
    type: file.type,
    createdAt: file.createdAt,
    updatedAt: file.updatedAt
  };

  switch(file.type) {
    case 'Triage':
      return {
        ...baseDetails,
        priorityLevel: file.details.priorityLevel,
        chiefComplaint: file.details.chiefComplaint
      };
    case 'Diagnostic':
      return {
        ...baseDetails,
        diagnosis: file.details.diagnosis,
        tests: file.details.diagnosticTests
      };
    case 'Treatment':
      return {
        ...baseDetails,
        procedures: file.details.procedures
      };
    case 'VitalSigns':
      return {
        ...baseDetails,
        vitalSigns: file.details.vitalSigns
      };
    case 'Prescription':
      return {
        ...baseDetails,
        medications: file.details.medications
      };
    default:
      return baseDetails;
  }
}
// R√©cup√©rer les dossiers partag√©s avec le m√©decin connect√©
router.get('/medical-records/shared-with-me', authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== 'Doctor') {
      return res.status(403).json({ message: "Acc√®s r√©serv√© aux m√©decins" });
    }

    const sharedRecords = await SharedMedicalRecord.find({ recipientId: req.user.id })
      .populate({
        path: 'medicalRecordId',
        populate: [
          {
            path: 'patientId',
            model: 'EmergencyPatient',
            select: 'firstName lastName dateOfBirth gender'
          },
          {
            path: 'creator',
            model: 'User',
            select: 'username specialization'
          },
          {
            path: 'patientFiles',
            model: 'PatientFile',
            options: { 
              sort: { dateRecorded: -1 },
              match: { medicalRecord: { $exists: true } } // Filtre suppl√©mentaire
            }
          }
        ]
      })
      .populate('sharerId', 'username role')
      .sort({ sharedAt: -1 });

    // Ajouter une validation suppl√©mentaire
    const formattedRecords = sharedRecords.map(record => {
      if (!record.medicalRecordId?.patientFiles) {
        console.warn(`Dossier ${record._id} a une structure invalide`);
        return null;
      }

      return {
        // ... autres champs ...,
        medicalRecord: {
          // ... autres champs ...,
          files: record.medicalRecordId.patientFiles
            .filter(file => file) // Filtrer les fichiers null
            .map(file => ({
              id: file._id,
              type: file.type,
              dateRecorded: file.dateRecorded,
              notes: file.notes,
              details: formatFileDetails(file)
            }))
        }
      };
    }).filter(record => record !== null); // Filtrer les entr√©es invalides

    res.status(200).json(formattedRecords);

  } catch (error) {
    console.error("Erreur de r√©cup√©ration :", error);
    res.status(500).json({
      message: "Erreur serveur",
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Ajouter cette m√©thode de formatage

router.get("/doctors", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const doctors = await User.find({ role: "Doctor" }); // Find users with role "Doctor"
    res.status(200).json(doctors);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
// Obtenir tous les utilisateurs (admin uniquement)
router.get("/", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const users = await User.find();
    res.status(200).json(users);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Obtenir un utilisateur par ID
router.get("/users/:id", authenticateToken, async (req, res) => {
  try {
    const userId = mongoose.Types.ObjectId(req.params.id); // Ensure the id is cast to ObjectId
    const user = await User.findById(userId).exec();

    if (!user) {
      return res.status(404).json({ message: "Utilisateur non trouv√©" });
    }

    res.status(200).json(user);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration de l'utilisateur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Mettre √† jour un utilisateur
router.put("/:id", authenticateToken, async (req, res) => {
  try {
  

    const updatedUser = await User.findByIdAndUpdate(req.params.id, req.body, { new: true });
    res.status(200).json(updatedUser);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Supprimer un utilisateur (admin uniquement)
router.delete("/:id", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    await User.findByIdAndDelete(req.params.id);
    res.status(200).json({ message: "Utilisateur supprim√©" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});

// Route de validation d'utilisateur (admin uniquement)
router.post("/validate-user", authenticateToken, async (req, res) => {
  try {
    // V√©rifier si l'utilisateur est un administrateur
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const { userId } = req.body;
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    // Valider l'utilisateur
    user.isValidated = true;
    await user.save();

    res.status(200).json({ message: "Utilisateur valid√© avec succ√®s" });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
router.get("/patients/count", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const patientCount = await User.countDocuments({ role: "Patient" });
    res.status(200).json({ count: patientCount });
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error });
  }
});
router.get("/patients", authenticateToken, async (req, res) => {
  try {
    // Ensure the user is an Administrator, Doctor, or Nurse
    if (!["Administrator", "Doctor", "Nurse"].includes(req.user.role)) {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    // Fetch patients from the database
    const patients = await User.find({ role: "Patient" }).exec();

    // Check if patients were found
    if (!patients || patients.length === 0) {
      return res.status(404).json({ message: "Aucun patient trouv√©" });
    }

    // Return the list of patients
    res.status(200).json(patients);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des patients:", error); // Log the error
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Delete a patient (admin only)
router.delete("/patients/:id", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const patient = await User.findById(req.params.id);
    if (!patient || patient.role !== "Patient") {
      return res.status(404).json({ message: "Patient non trouv√©" });
    }

    await User.findByIdAndDelete(req.params.id);
    res.status(200).json({ message: "Patient supprim√© avec succ√®s" });
  } catch (error) {
    console.error("Erreur lors de la suppression du patient:", error); // Log the error
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Update a patient (admin only)
router.put("/patients/:id", authenticateToken, async (req, res) => {
  try {
    if (req.user.role !== "Administrator") {
      return res.status(403).json({ message: "Acc√®s refus√©" });
    }

    const patient = await User.findById(req.params.id);
    if (!patient || patient.role !== "Patient") {
      return res.status(404).json({ message: "Patient non trouv√©" });
    }

    const updatedPatient = await User.findByIdAndUpdate(req.params.id, req.body, { new: true });
    res.status(200).json(updatedPatient);
  } catch (error) {
    console.error("Erreur lors de la mise √† jour du patient:", error); // Log the error
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
router.put("/:id/availability", authenticateToken, async (req, res) => {
    const targetUserId = req.params.id;
    const requesterUserId = req.user.id; // ID de celui qui fait la requ√™te
    const requesterRole = req.user.role; // R√¥le de celui qui fait la requ√™te
    const { isAvailable } = req.body; // Valeur attendue : true ou false

    // 1. Validation de l'ID cible
    if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
        return res.status(400).json({ message: "ID utilisateur cible invalide." });
    }

    // 2. V√©rification d'autorisation : Admin OU le m√©decin lui-m√™me
    if (requesterRole !== "Administrator" && requesterUserId !== targetUserId) {
        console.log(`Acc√®s refus√© pour ${requesterUserId} (r√¥le ${requesterRole}) tentant de modifier ${targetUserId}`);
        return res.status(403).json({ message: "Acc√®s refus√©. Vous ne pouvez modifier que votre propre disponibilit√© ou √™tre administrateur." });
    }

    // 3. Validation de la valeur 'isAvailable' re√ßue
    if (typeof isAvailable !== 'boolean') {
        return res.status(400).json({ message: "La valeur fournie pour 'isAvailable' est invalide (doit √™tre true ou false)." });
    }

    try {
        // 4. Trouver l'utilisateur cible
        const userToUpdate = await User.findById(targetUserId);

        if (!userToUpdate) {
             return res.status(404).json({ message: "L'utilisateur cible n'a pas √©t√© trouv√©." });
        }

        // 5. V√©rifier si l'utilisateur cible est bien un m√©decin
        if (userToUpdate.role !== 'Doctor') {
           return res.status(400).json({ message: "La disponibilit√© ne peut √™tre modifi√©e que pour un utilisateur ayant le r√¥le 'Doctor'." });
        }

        // 6. Mettre √† jour la disponibilit√© et sauvegarder
        userToUpdate.isAvailable = isAvailable;
        await userToUpdate.save();
        console.log(`Disponibilit√© de ${userToUpdate.username} (ID: ${targetUserId}) mise √† jour √† ${isAvailable} par ${requesterUserId}`);

        // 7. Renvoyer une r√©ponse de succ√®s
        res.status(200).json({
            message: `Disponibilit√© de ${userToUpdate.username} mise √† jour √† ${isAvailable ? 'Disponible' : 'Occup√©'}.`,
            user: { // Renvoyer seulement les infos n√©cessaires
                _id: userToUpdate._id,
                username: userToUpdate.username,
                isAvailable: userToUpdate.isAvailable
            }
        });

    } catch (error) {
        console.error(`Erreur PUT /${targetUserId}/availability:`, error);
        res.status(500).json({ message: "Erreur serveur lors de la mise √† jour de la disponibilit√©.", error: error.message });
    }
});
router.get("/nurses", authenticateToken, async (req, res) => {
  try {
    // Find users with the role "Nurse"
    const nurses = await User.find({ role: "Nurse" });
    res.status(200).json(nurses);
  } catch (error) {
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});

// Nouvelle route pour les statistiques des utilisateurs
router.get("/stats", authenticateToken, async (req, res) => {
  try {
      if (req.user.role !== "Administrator") {
          return res.status(403).json({ message: "Acc√®s refus√©" });
      }

      const [patients, doctors, nurses, admins, emergencyPatients] = await Promise.all([
          User.countDocuments({ role: "Patient" }),
          User.countDocuments({ role: "Doctor" }),
          User.countDocuments({ role: "Nurse" }),
          User.countDocuments({ role: "Administrator" }),
          mongoose.model('EmergencyPatient').countDocuments()
      ]);

      const totalUsers = patients + doctors + nurses + admins;
      
      const stats = [
          { name: "Patients", count: patients, percentage: (patients / totalUsers * 100).toFixed(2) },
          { name: "Doctors", count: doctors, percentage: (doctors / totalUsers * 100).toFixed(2) },
          { name: "Nurses", count: nurses, percentage: (nurses / totalUsers * 100).toFixed(2) },
          { name: "Admins", count: admins, percentage: (admins / totalUsers * 100).toFixed(2) },
          { name: "Emergency", count: emergencyPatients, percentage: (emergencyPatients / (totalUsers + emergencyPatients) * 100).toFixed(2) }
      ];

      res.status(200).json(stats);
  } catch (error) {
      console.error("Erreur r√©cup√©ration stats utilisateurs:", error);
      res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
// Ajoutez cette route dans votre fichier de routes (users.js)
// Dans users.js (backend)
router.get("/me", authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.id)
      .select("-password -resetPasswordToken -resetPasswordExpires -otp -otpExpires");

    if (!user) return res.status(404).json({ message: "Utilisateur non trouv√©" });

    res.status(200).json({
      id: user._id,
      username: user.username,
      email: user.email,
      role: user.role,
      // Ajoutez d'autres champs si n√©cessaire
    });
    
  } catch (error) {
    console.error("Erreur r√©cup√©ration utilisateur:", error);
    res.status(500).json({ message: "Erreur serveur", error: error.message });
  }
});
export default router;
</file>

<file path="sendSMS.js">
import { parsePhoneNumberFromString, isValidPhoneNumber } from 'libphonenumber-js';
import dotenv from 'dotenv';
import twilio from 'twilio';

dotenv.config();

const accountSid = process.env.TWILIO_ACCOUNT_SID;
const authToken = process.env.TWILIO_AUTH_TOKEN;
const client = twilio(accountSid, authToken);

const sendSMS = async (body, userPhoneNumber) => {
    try {
        // Parse le num√©ro
        const phoneNumber = parsePhoneNumberFromString(userPhoneNumber, 'TN'); // 'TN' pour Tunisie.  Change si n√©cessaire.

        // V√©rifie si le num√©ro est valide
        if (!phoneNumber || !isValidPhoneNumber(phoneNumber.number, phoneNumber.country)) {
            console.error("Num√©ro de t√©l√©phone invalide :", userPhoneNumber);
            return { success: false, message: 'Num√©ro de t√©l√©phone invalide.' };
        }

        // Formate le num√©ro en E.164 (le format requis par Twilio)
        const formattedPhoneNumber = phoneNumber.format('E.164');

        const msgOptions = {
            from: process.env.TWILIO_FROM_NUMBER,
            to: formattedPhoneNumber,
            body: body
        };

        const message = await client.messages.create(msgOptions);
        console.log("‚úÖ SMS envoy√© avec succ√®s :", message.sid);
        return { success: true, message: 'Message sent successfully' };

    } catch (error) {
        console.error("‚ùå Erreur d'envoi SMS ou de validation du num√©ro:", error);

        // G√©rer les erreurs sp√©cifiques √† libphonenumber et Twilio s√©par√©ment
        if (error.message === "INVALID_COUNTRY") { // Exemple d'erreur libphonenumber-js
            return { success: false, message: 'Code pays invalide pour le num√©ro de t√©l√©phone.' };
        }

        if (error.code === 21211) {
            return { success: false, message: 'Num√©ro de t√©l√©phone invalide pour Twilio.' };
        }
        //Ajoute d'autre  gestion d'erreur si n√©cessaire
        return { success: false, message: '√âchec de l\'envoi du SMS', error: error.message };
    }
};

export default sendSMS;
</file>

<file path="server.js">
import express from "express";
import mongoose from "mongoose";
import cors from "cors";
import dotenv from "dotenv";
import http from 'http'; // Keep only one http import
import cookieParser from "cookie-parser";
import path from "path";
import { fileURLToPath } from "url";
import { Server as SocketIOServer } from "socket.io"; // Use the alias you defined
import jwt from 'jsonwebtoken'; // Keep JWT import

import connectDB from "./db.js";

// --- Route Imports ---
import authRoutes from "./routes/auth.js";
import userRoutes from "./routes/users.js";
import profileRoutes from "./routes/profile.js";
import emergencyPatientRoutes from "./routes/emergencyPatients.js";
import aiRoutes from './routes/ai.js';
import ambulanceRoutes from "./routes/ambulance.js";
import medicalRecordRoutes from "./routes/medicalRecords.js";
import patientFileRoutes from "./routes/patientFile.js";
import alertsRoutes from "./routes/alerts.js";
import notificationRoutes from './routes/notifications.js';

// --- Model Imports ---
import { User } from "./models/User.js";
import Ambulance from "./models/Ambulance.js";
import Alert from "./models/Alert.js";

// --- Helpers ---
dotenv.config();
connectDB();

const app = express();
const server = http.createServer(app); // Use the http server instance

// Get __dirname in ES module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// --- Initialize Socket.IO server ---
const io = new SocketIOServer(server, {
  cors: {
    origin: "http://localhost:3000", // Your frontend URL
    methods: ["GET", "POST"],
    credentials: true, // Important for passing cookies
  },
});

// --- User-socket mapping ---
const userSockets = new Map(); // Use Map for better performance
// Make io and userSockets globally accessible if needed by other modules not using req object
// global.io = io;
// global.userSockets = userSockets;

// --- Middleware ---
app.use(cors({ // Ensure CORS is first
  origin: "http://localhost:3000",
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization"],
}));
app.use(express.json());
app.use(cookieParser());

// Serve static files from 'uploads' directory
app.use("/uploads", express.static(path.join(__dirname, "uploads")));

// --- ‚ú® Middleware to attach io and userSockets to request object ---
// This makes them easily accessible in your route handlers
app.use((req, res, next) => {
  req.io = io;
  req.userSockets = userSockets;
  next();
});
// --- End Middleware ---

// --- REST API routes ---
app.use("/api/auth", authRoutes);
app.use("/api/users", userRoutes);
app.use("/api", profileRoutes);
app.use("/api/emergency-patients", emergencyPatientRoutes); // Ensure this uses req.io
app.use("/api/ambulance", ambulanceRoutes);
app.use("/api/medical-records", medicalRecordRoutes);
app.use("/api/patient-files", patientFileRoutes);
app.use("/api/alerts", alertsRoutes);
app.use('/api/ai', aiRoutes);
app.use('/api/notifications', notificationRoutes); 

// --- ‚ú® Socket.IO Authentication Middleware ---
io.use((socket, next) => {
  // Extract token from handshake auth or cookies
  const token = socket.handshake.auth.token || socket.handshake.headers.cookie?.split('; ').find(row => row.startsWith('token='))?.split('=')[1];

  if (!token) {
    console.error("‚ùå Socket Auth Error: No token provided");
    return next(new Error('Authentication error: No token'));
  }
  try {
    const verified = jwt.verify(token, process.env.JWT_SECRET);
    socket.userId = verified.id; // Attach userId to socket
    socket.userRole = verified.role; // Attach userRole to socket
    console.log(`üîí Socket authenticated: User ${socket.userId} (${socket.userRole})`);
    next(); // Proceed to connection
  } catch (error) {
    console.error("‚ùå Socket Auth Error: Invalid token -", error.message);
    return next(new Error('Authentication error: Invalid token'));
  }
});
// --- End Socket.IO Auth Middleware ---

// --- Socket.IO Connection Logic ---
io.on("connection", (socket) => {
  // This now runs *after* the io.use middleware authentication
  console.log(`‚ö° Socket connected: ${socket.id} for User ID: ${socket.userId} (${socket.userRole})`);

  // --- Associate userId with socket ---
  // Ensure userId is valid before adding to map
  if (socket.userId) {
    userSockets.set(socket.userId.toString(), socket.id);
    console.log(`üó∫Ô∏è User ${socket.userId} mapped to socket ${socket.id}`);
  } else {
    console.warn(`‚ö†Ô∏è Socket ${socket.id} connected without a valid userId after authentication.`);
    // Optionally disconnect if userId is absolutely required
    // socket.disconnect(true);
    // return;
  }

  // --- ‚ú® Join Role-Based Rooms ---
  if (socket.userRole) {
    const roomName = `${socket.userRole.toLowerCase()}-room`; // e.g., 'nurse-room', 'doctor-room'
    socket.join(roomName);
    console.log(`üö™ Socket ${socket.id} (User ${socket.userId}) joined room: ${roomName}`);

    // Optionally join a user-specific room too
    socket.join(`user_${socket.userId}`);
    console.log(`üö™ Socket ${socket.id} (User ${socket.userId}) joined personal room: user_${socket.userId}`);
  }
  // --- End Room Joining ---

  // --- Keep Existing Event Listeners ---
  // Ambulance location update
  socket.on("locationUpdate", async (data) => {
    console.log("Received locationUpdate:", data); // Debug log
    if (!data || !data.id || data.latitude == null || data.longitude == null) {
      console.error("Invalid locationUpdate data received:", data);
      return; // Prevent processing invalid data
    }
    try {
      await Ambulance.findByIdAndUpdate(data.id, {
        latitude: data.latitude,
        longitude: data.longitude,
        lastUpdated: data.timestamp || new Date(), // Ensure timestamp exists
      });
      // Emit back to all clients (consider specific room/client if needed)
      io.emit("locationUpdate", data);
    } catch (err) {
      console.error("‚ùå Error saving location:", err);
    }
  });

  // Ambulance destination update
  socket.on("destinationUpdate", async (data) => {
    console.log("Received destinationUpdate:", data); // Debug log
    if (!data || !data.id || data.destinationLatitude == null || data.destinationLongitude == null) {
      console.error("Invalid destinationUpdate data received:", data);
      return; // Prevent processing invalid data
    }
    try {
      const destination = `${data.destinationLatitude},${data.destinationLongitude}`;
      await Ambulance.findByIdAndUpdate(data.id, {
        destination,
        lastUpdated: Date.now(),
      });
      // Emit back to all clients (consider specific room/client if needed)
      io.emit("destinationUpdate", data);
    } catch (err) {
      console.error("‚ùå Error saving destination:", err);
    }
  });

  // Ambulance alert
  socket.on("alert", async ({ message, source }) => {
    console.log("Received alert:", { message, source }); // Debug log
    if (!message || !source) {
      console.error("Invalid alert data received:", { message, source });
      return; // Prevent processing invalid data
    }
    try {
      const alert = await Alert.create({ message, source });
      // Emit back to all clients (consider specific room/client if needed)
      io.emit("alert", {
        _id: alert._id,
        message: alert.message,
        source: alert.source,
        timestamp: alert.timestamp,
      });
    } catch (err) {
      console.error("‚ùå Error saving alert:", err);
    }
  });

  // Ping-pong test
  socket.on("ping_server", (data) => {
    console.log("Received ping_server from:", socket.id, data); // Debug log
    socket.emit("pong_client", {
      message: "Pong from server!",
      timestamp: Date.now(),
    });
  });
  // --- End Existing Event Listeners ---

  socket.on("disconnect", (reason) => {
    console.log(`üî• Socket disconnected: ${socket.id}. Reason: ${reason}`);
    // Remove the user from the map upon disconnection
    if (socket.userId) {
      // Check if the disconnected socket ID matches the stored ID for that user
      if (userSockets.get(socket.userId.toString()) === socket.id) {
        userSockets.delete(socket.userId.toString());
        console.log(`üó∫Ô∏è User ${socket.userId} removed from socket map.`);
      }
    }
    // Fallback: Clean up any socket ID entry just in case mapping got skewed
    for (let [key, value] of userSockets.entries()) {
      if (value === socket.id) {
        userSockets.delete(key);
        console.log(`üó∫Ô∏è Cleaned up map entry for disconnected socket ${socket.id}`);
        break; // Exit loop once found
      }
    }
  });
});
// --- End Socket.IO Logic ---

// --- Server Listen ---
const PORT = process.env.PORT || 8089;
server.listen(PORT, () => { // Use the http server instance
  console.log(`‚úÖ Server (with Socket.IO) running on port ${PORT}`);
});
</file>

<file path="services/aiService.js">
// backend/services/aiService.js
import OpenAI from 'openai';
import dotenv from 'dotenv';

dotenv.config(); // Charger les variables d'environnement

// Initialiser le client OpenAI
const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Analyse le texte des sympt√¥mes fourni par un patient √† l'aide d'un LLM.
 * @param {string} symptomText - La description des sympt√¥mes fournie par le patient.
 * @returns {Promise<object>} Un objet contenant les mots-cl√©s et les questions sugg√©r√©es.
 *                          Ex: { keywords: ["douleur poitrine", "essoufflement"], suggestedQuestions: ["La douleur s'√©tend-elle au bras ?", ...] }
 * @throws {Error} Si l'analyse √©choue.
 */
export const analyzeSymptoms = async (symptomText) => {
    if (!symptomText || typeof symptomText !== 'string' || symptomText.trim().length < 10) {
        // Ne pas appeler l'API si le texte est trop court ou invalide
        console.log("Texte de sympt√¥me trop court ou invalide, analyse annul√©e.");
        return { keywords: [], suggestedQuestions: [] };
    }

    const systemPrompt = `
    You are a helpful medical assistant bot integrated into an emergency registration system.
    Your role is to analyze a patient's symptom description to extract key information and suggest clarifying questions.
    You MUST follow these instructions strictly:
    1.  Identify the main keywords or symptoms mentioned by the patient. List them concisely.
    2.  Suggest 2-3 relevant follow-up questions that a medical professional MIGHT ask to get more details about the symptoms described. These questions should be open-ended and aimed at clarification (e.g., "Where exactly is the pain located?", "When did the symptoms start?").
    3.  **CRITICAL: DO NOT provide any diagnosis, medical advice, assessment of severity, or treatment recommendations.** Do not use phrases like "you might have", "it sounds like", "you should".
    4.  **CRITICAL: Your output MUST be a valid JSON object ONLY, with the following structure:**
        {
          "keywords": ["symptom1", "symptom2", ...],
          "suggestedQuestions": ["question1?", "question2?", ...]
        }
    5.  If the input text is vague or doesn't seem like symptoms, return empty arrays for keywords and questions in the JSON structure.
    6.  Keep keywords and questions concise and clear.
  `;

    try {
        console.log(`[AI Service] Analyse des sympt√¥mes demand√©e pour: "${symptomText.substring(0, 50)}..."`);
        const completion = await openai.chat.completions.create({
            model: "gpt-3.5-turbo-0125", // Mod√®le √©conomique et rapide, suffisant pour cette t√¢che. Vous pouvez tester gpt-4o si besoin.
            messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: symptomText }
            ],
            temperature: 0.3, // Faible temp√©rature pour des r√©ponses plus factuelles/pr√©visibles
            max_tokens: 150, // Limiter la longueur de la r√©ponse
            response_format: { type: "json_object" } // Essayer de forcer le JSON (marche avec certains mod√®les)
        });

        const responseContent = completion.choices[0]?.message?.content;
        console.log("[AI Service] R√©ponse brute de l'API:", responseContent);

        if (!responseContent) {
            throw new Error("R√©ponse vide de l'API OpenAI.");
        }

        // Essayer de parser la r√©ponse JSON
        let parsedResponse;
        try {
            parsedResponse = JSON.parse(responseContent);
            // Valider la structure attendue
            if (!parsedResponse || !Array.isArray(parsedResponse.keywords) || !Array.isArray(parsedResponse.suggestedQuestions)) {
                console.error("[AI Service] Structure JSON invalide re√ßue:", parsedResponse);
                throw new Error("Format de r√©ponse JSON invalide de l'API.");
            }
            console.log("[AI Service] R√©ponse analys√©e:", parsedResponse);
            return parsedResponse;
        } catch (parseError) {
            console.error("[AI Service] Erreur de parsing JSON:", parseError);
            console.error("[AI Service] Contenu re√ßu non-JSON:", responseContent);
            // Fallback: essayer d'extraire manuellement si c'est possible (peu fiable)
            // Ou simplement retourner un objet vide/erreur structur√©e
            return { keywords: [], suggestedQuestions: [], error: "Format de r√©ponse invalide de l'IA." };
        }

    } catch (error) {
        console.error("[AI Service] Erreur lors de l'appel √† l'API OpenAI:", error);
        // Remonter une erreur plus g√©n√©rique pour ne pas exposer de d√©tails sensibles
        throw new Error("L'analyse des sympt√¥mes par l'IA a √©chou√©.");
    }
};
</file>

<file path="services/chatbotService.js">
// backend/services/chatbotService.js
import EmergencyPatient from '../models/EmergencyPatient.js';
import { getEstimatedWaitTime } from './waitTimeService.js'; // Assurez-vous que le chemin est correct

/**
 * G√©n√®re une r√©ponse simple bas√©e sur des mots-cl√©s dans la requ√™te de l'utilisateur.
 * @param {string} patientId - L'ID du patient.
 * @param {string} queryText - La question de l'utilisateur.
 * @returns {Promise<string>} La r√©ponse du chatbot.
 */
export const getSimpleChatbotResponse = async (patientId, queryText) => {
    if (!patientId || !queryText) {
        console.warn("[ChatbotService] Patient ID ou QueryText manquant.");
        return "D√©sol√©, je n'ai pas toutes les informations n√©cessaires pour r√©pondre.";
    }

    const lowerQuery = queryText.toLowerCase().trim();
    // R√©ponse par d√©faut si aucune intention n'est comprise
    let responseMessage = "Je suis un assistant virtuel. Je peux vous donner des informations sur votre statut actuel, le temps d'attente estim√©, ou le m√©decin qui vous a √©t√© assign√©. Pour toute autre pr√©occupation, veuillez patienter qu'un membre de notre √©quipe vous contacte.";

    console.log(`[ChatbotService] Traitement de la requ√™te: "${lowerQuery}" pour patient ID: ${patientId}`);

    try {
        // R√©cup√©rer les infos patient n√©cessaires. Populate pour avoir nom et sp√© du m√©decin si assign√©.
        const patient = await EmergencyPatient.findById(patientId)
            .populate('assignedDoctor', 'username specialization'); // 'username' et 'specialization' sont des exemples

        if (!patient) {
            console.warn(`[ChatbotService] Patient non trouv√© pour ID: ${patientId}`);
            return "D√©sol√©, je n'arrive pas √† trouver votre dossier d'urgence dans notre syst√®me.";
        }

        // --- Analyse simple par mots-cl√©s ---

        // 1. Intention : Demande de Statut
        if (lowerQuery.includes('statut') || lowerQuery.includes('status') || lowerQuery.includes('√©tat') || lowerQuery.includes("o√π en est")) {
            responseMessage = `Votre statut actuel est : "${patient.status}". `;
            // Ajouter une br√®ve explication du statut si possible
            switch (patient.status) {
                case 'Demande Enregistr√©e':
                    responseMessage += "Notre √©quipe examine votre demande.";
                    break;
                case 'En Cours d\'Examen':
                    responseMessage += "Un professionnel de sant√© √©value actuellement votre situation.";
                    break;
                case 'M√©decin Assign√©':
                    responseMessage += "Un m√©decin a √©t√© assign√© et sera inform√©.";
                    break;
                case 'M√©decin En Route':
                    responseMessage += "Le m√©decin est en chemin. Veuillez rester disponible.";
                    break;
                case 'Trait√©':
                    responseMessage += "Votre prise en charge est termin√©e.";
                    break;
                case 'Annul√©':
                    responseMessage += "Votre demande a √©t√© annul√©e.";
                    break;
                default:
                    responseMessage += "Nous traitons votre demande.";
            }
            console.log(`[ChatbotService] Intention d√©tect√©e: Statut. R√©ponse: ${responseMessage}`);

        // 2. Intention : Demande de Temps d'Attente
        } else if (lowerQuery.includes('temps') || lowerQuery.includes('attente') || lowerQuery.includes('combien de temps') || lowerQuery.includes('quand serai-je')) {
            const waitTime = await getEstimatedWaitTime(patientId); // Appel au service de temps d'attente
            responseMessage = `Le temps d'attente actuel est estim√© √† ${waitTime}. Veuillez noter qu'il s'agit d'une estimation et qu'elle peut varier.`;
            console.log(`[ChatbotService] Intention d√©tect√©e: Temps d'attente. R√©ponse: ${responseMessage}`);

        // 3. Intention : Demande d'Informations sur le M√©decin
        } else if (lowerQuery.includes('m√©decin') || lowerQuery.includes('docteur') || (lowerQuery.includes('qui') && lowerQuery.includes('assign√©'))) {
            if (patient.assignedDoctor && patient.assignedDoctor.username) {
                let doctorDetails = `Le Dr. ${patient.assignedDoctor.username}`;
                if (patient.assignedDoctor.specialization) {
                    doctorDetails += `, sp√©cialiste en ${patient.assignedDoctor.specialization},`;
                }
                doctorDetails += " vous a √©t√© assign√©.";
                responseMessage = doctorDetails;
            } else {
                responseMessage = "Un m√©decin n'a pas encore √©t√© formellement assign√© √† votre cas, mais notre √©quipe examine votre demande.";
            }
            console.log(`[ChatbotService] Intention d√©tect√©e: Info M√©decin. R√©ponse: ${responseMessage}`);

        // 4. Intention : Salutations
        } else if (lowerQuery.includes('bonjour') || lowerQuery.includes('salut') || lowerQuery.includes('hello') || lowerQuery.includes('yo')) {
             responseMessage = `Bonjour ! Comment puis-je vous aider concernant votre statut actuel, le temps d'attente estim√©, ou le m√©decin qui vous a √©t√© assign√© ?`;
             console.log(`[ChatbotService] Intention d√©tect√©e: Salutation. R√©ponse: ${responseMessage}`);
        }
        // Ajoutez d'autres 'else if' pour plus de mots-cl√©s/intentions ici...
        // Exemple:
        // else if (lowerQuery.includes('conseil') || lowerQuery.includes('faire')) {
        //    responseMessage = "Je ne peux pas donner de conseils m√©dicaux. Si votre √©tat s'aggrave, veuillez le signaler. En attendant, essayez de rester calme.";
        // }

    } catch (error) {
        console.error(`[ChatbotService] Erreur lors du traitement de la requ√™te pour patient ${patientId} / query "${queryText}":`, error);
        responseMessage = "D√©sol√©, une erreur technique s'est produite lors de la r√©cup√©ration des informations. Veuillez r√©essayer plus tard.";
    }

    return responseMessage;
};
</file>

<file path="services/classifierService.js">
import dotenv from 'dotenv';
dotenv.config();

import { pipeline } from '@xenova/transformers';

let classifierPromise = null;

async function getClassifier() {
  if (!classifierPromise) {
    const options = {};
    if (process.env.HF_HUB_TOKEN) {
      options.auth_token = process.env.HF_HUB_TOKEN;
    }

    classifierPromise = pipeline(
      'zero-shot-classification',
      'Xenova/nli-deberta-v3-xsmall',
      options
    );
  }
  return classifierPromise;
}

export async function classifyPatientNeeds(prompt) {
  const candidateLabels = ['bed', 'icu', 'ct-scan', 'xray', 'ventilator'];
  const classifier = await getClassifier();
  
  // Call the classifier with all candidate labels
  const result = await classifier(prompt, candidateLabels);
  
  console.log('Raw classifier result:', JSON.stringify(result, null, 2));

  // Check if the result has both labels and scores arrays
  if (!result.labels || !result.scores) {
    console.error("Error: Expected structure not found in classifier result");
    return null;
  }

  // Find the index of the highest score
  let maxScoreIndex = 0;
  for (let i = 1; i < result.scores.length; i++) {
    if (result.scores[i] > result.scores[maxScoreIndex]) {
      maxScoreIndex = i;
    }
  }
  
  // Return only the top label
  return result.labels[maxScoreIndex];
}

// Example usage
async function test() {
  const prompt = "Chief complaint: Headache and fever. Vitals: {\"bloodPressure\":{\"systolic\":118,\"diastolic\":76},\"temperature\":38.2,\"heartRate\":92,\"respiratoryRate\":20,\"oxygenSaturation\":97}. Notes: Initial diagnostic notes..";
  const topRecommendation = await classifyPatientNeeds(prompt);
  console.log("Top recommendation:", topRecommendation);
}

// Uncomment to run test
// test().catch(console.error);
</file>

<file path="services/emailService.js">
// services/emailService.js
import nodemailer from "nodemailer";
import dotenv from "dotenv";

dotenv.config();

// Configurer le transporteur d'email
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD,
  },
});

// Envoyer l'OTP par email
export const sendOTP = async (email, otp) => {
  const mailOptions = {
    from: process.env.EMAIL_USER,
    to: email,
    subject: "Your OTP Code",
    html: `<!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>OTP Verification</title>
          <style>
              body {
                  font-family: Arial, sans-serif;
                  background-color: #f4f4f4;
                  padding: 40px;
                  margin: 0;
                  text-align: center;
              }
              .container {
                  max-width: 600px;
                  margin: 0 auto;
                  background-color: #ffffff;
                  border-radius: 8px;
                  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                  padding: 30px;
                  text-align: center;
              }
              h1 {
                  color: #333;
                  font-size: 24px;
                  margin-bottom: 20px;
              }
              .otp-code {
                  font-size: 32px;
                  font-weight: bold;
                  color: #007BFF;
                  padding: 10px;
                  border: 2px solid #007BFF;
                  display: inline-block;
                  margin-bottom: 20px;
              }
              .expiration {
                  color: #555;
                  font-size: 14px;
                  margin-top: 10px;
              }
              .footer {
                  margin-top: 30px;
                  color: #888;
                  font-size: 12px;
              }
              .footer a {
                  color: #007BFF;
                  text-decoration: none;
              }
          </style>
      </head>
      <body>
          <div class="container">
              <h1>OTP Verification</h1>
              <p>Your OTP code is:</p>
              <div class="otp-code">${otp}</div>
              <p class="expiration">It will expire in 5 minutes.</p>
              <div class="footer">
                  <p>If you didn't request this, please ignore this email.</p>
              </div>
          </div>
      </body>
      </html>`,
  };

  await transporter.sendMail(mailOptions);
};
</file>

<file path="services/ocrService.js">
import { createWorker } from 'tesseract.js';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { extractMedicalData } from '../utils/textParser.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const imagesUploadDir = path.resolve(__dirname, '../../../uploads/images');
const tessdataDir = path.resolve(__dirname, '../../../tessdata');
const tesscacheDir = path.resolve(__dirname, '../../../tesscache');

const verifyEnvironment = async () => {
    try {
        const requiredDirs = [
            imagesUploadDir,
            tessdataDir
        ];

        for (const dir of requiredDirs) {
            await fs.ensureDir(dir);
        }

        return true;
    } catch (error) {
        throw new Error(`Erreur de configuration: ${error.message}`);
    }
};

export const processImage = async (imagePath, medicalRecordId) => {
    let worker = null;

    try {
        // V√©rification de l'existence du fichier image
        await fs.access(imagePath, fs.constants.R_OK);

        await verifyEnvironment();

        worker = await createWorker({
            cachePath: tesscacheDir,
            logger: m => console.log('[TESSERACT]', m),
            errorHandler: err => console.error('[TESSERACT ERROR]', err),
            tessdataDir: tessdataDir
        });

        await worker.loadLanguage('fra+eng');
        await worker.initialize('fra+eng');

        await worker.setParameters({
            tessedit_pageseg_mode: '6', // Mode traitement de bloc unique (adapter si n√©cessaire)
            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√â√à√ä√ã√Ä√Ç√Ñ√é√è√î√ñ√ô√õ√ú√á√©√®√™√´√†√¢√§√Æ√Ø√¥√∂√π√ª√º√ß0123456789-/,.:;()\'" ',
            preserve_interword_spaces: '1'
        });

        const extractionStartTime = Date.now();

        const { data } = await worker.recognize(imagePath, {
            rotateAuto: true,
            pdfTitle: "Image" // Le titre PDF n'est plus pertinent ici
        });

        const fullText = data.text;

        console.log(`OCR compl√©t√© en ${((Date.now() - extractionStartTime) / 1000).toFixed(1)}s`);

        const extractedData = extractMedicalData(fullText); // Tu peux adapter cette fonction si n√©cessaire pour des images

        return {
            success: true,
            data: {
                text: fullText,
                extractedData: extractedData // Les donn√©es extraites d√©pendront du contenu de l'image
            }
        };

    } catch (error) {
        console.error('Erreur de traitement OCR sur image:', {
            error: error.message,
            imagePath,
            stack: error.stack
        });
        throw new Error(`√âchec du traitement OCR sur image: ${error.message}`);
    } finally {
        if (worker) {
            await worker.terminate();
        }
    }
};
</file>

<file path="services/otpService.js">
// services/otpService.js
import bcrypt from "bcrypt";
import { User } from "../models/User.js";

// G√©n√©rer un OTP
export const generateOTP = async () => {
  const otp = Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit OTP
  const salt = await bcrypt.genSalt(10);
  const hashedOTP = await bcrypt.hash(otp, salt);
  return { otp, hashedOTP };
};

// Sauvegarder l'OTP dans la base de donn√©es
export const saveOTPToUser = async (email, hashedOTP) => {
  const user = await User.findOne({ email });
  if (!user) throw new Error("User not found");

  // Stocker l'OTP et d√©finir une date d'expiration (10 minutes)
  user.otp = hashedOTP;
  user.otpExpires = Date.now() + 10 * 60 * 1000; // 10 minutes
  await user.save();
};

// V√©rifier l'OTP
export const verifyOTP = async (inputOTP, storedHashedOTP) => {
  return await bcrypt.compare(inputOTP, storedHashedOTP);
};
</file>

<file path="services/simpleSymptomHelper.js">
// backend/services/simpleSymptomHelper.js

// --- D√©finition des Mappings ---
// On d√©finit d'abord les questions communes pour √©viter la r√©p√©tition
const commonQuestions = {
    respiratory: [
        'Est-ce apparu soudainement ou progressivement ?',
        'Avez-vous de la toux ou une douleur en respirant ?',
        'Est-ce pire en position allong√©e ?'
    ],
    chestPain: [
        'La douleur s\'√©tend-elle √† d\'autres parties (bras, dos, m√¢choire) ?',
        'Quand la douleur a-t-elle commenc√© exactement ?',
        'Avez-vous des difficult√©s √† respirer, des sueurs ou des naus√©es ?'
    ],
    headache: [
        'O√π se situe la douleur dans la t√™te ?',
        'Avez-vous des naus√©es, vomissements ou sensibilit√© √† la lumi√®re ?',
        'Avez-vous eu un choc √† la t√™te r√©cemment ?'
    ],
    abdominalPain: [
        'O√π se situe pr√©cis√©ment la douleur dans l\'abdomen ?',
        'Avez-vous de la fi√®vre, des naus√©es ou des diarrh√©es ?',
        'Depuis quand avez-vous mal ?'
    ],
    fever: [
        'Avez-vous pris votre temp√©rature ? Si oui, combien ?',
        'Avez-vous d\'autres sympt√¥mes (toux, courbatures) ?',
        'Depuis combien de temps avez-vous de la fi√®vre ?'
    ],
    fall: [
        'Avez-vous perdu connaissance, m√™me bri√®vement ?',
        'Vous √™tes-vous cogn√© la t√™te ou une autre partie du corps ?',
        'Avez-vous des douleurs ou difficult√©s √† bouger ?'
    ],
    allergy: [
        '√Ä quoi pensez-vous √™tre allergique ?',
        'Avez-vous des difficult√©s √† respirer ou un gonflement (visage, gorge) ?',
        'Avez-vous une √©ruption cutan√©e ? O√π ?'
    ],
    nausea: [
            'Avez-vous vomi ? Si oui, combien de fois et √† quoi ressemblaient les vomissements ?',
            'Avez-vous d\'autres sympt√¥mes (douleur ventre, diarrh√©e, fi√®vre) ?',
            'Depuis quand avez-vous des naus√©es ?'
    ]
    // Ajouter d'autres groupes de questions communes si n√©cessaire
};

const symptomMappings = {
    // Douleurs
    'poitrine': {
        keywords: ['douleur poitrine', 'pression thoracique', 'serrement poitrine'],
        questions: commonQuestions.chestPain
    },
    'c≈ìur': { // Nouveau: li√© √† poitrine
        keywords: ['douleur cardiaque', 'palpitations', 'probl√®me c≈ìur', 'douleur poitrine'],
        questions: commonQuestions.chestPain // R√©utiliser ou adapter les questions
    },
    't√™te': {
        keywords: ['mal de t√™te', 'c√©phal√©e', 'migraine'],
        questions: commonQuestions.headache
    },
    'ventre': {
        keywords: ['douleur abdominale', 'mal de ventre', 'crampes estomac'],
        questions: commonQuestions.abdominalPain
    },
    'estomac': { // Variante de ventre
        keywords: ['douleur estomac', 'br√ªlure estomac'],
        questions: commonQuestions.abdominalPain
    },
    'dos': {
        keywords: ['mal de dos', 'douleur lombaire', 'douleur dorsale'],
        questions: [
            'O√π exactement dans le dos avez-vous mal ? (Bas, milieu, haut)',
            'La douleur descend-elle dans une jambe ?',
            'Est-ce apparu apr√®s un effort ou une chute ?',
        ]
    },

    // Respiration
    'respire': {
        keywords: ['difficult√© respiratoire', 'essoufflement', 'manque d\'air', 'souffle court'],
        questions: commonQuestions.respiratory
    },
    'souffle': { // Variante
        keywords: ['difficult√© respiratoire', 'essoufflement', 'manque d\'air'],
        questions: commonQuestions.respiratory
    },
    'toux': {
        keywords: ['toux', 'tousse'],
        questions: [
            'La toux est-elle s√®che ou grasse (avec crachats) ?',
            'Depuis combien de temps toussez-vous ?',
            'Avez-vous de la fi√®vre ou des difficult√©s √† respirer associ√©es ?'
        ]
    },

    // Fi√®vre
    'fi√®vre': {
        keywords: ['fi√®vre', 'chaud', 'temp√©rature √©lev√©e'],
        questions: commonQuestions.fever
    },
    'temp√©rature': { // Nouveau: li√© √† fi√®vre
        keywords: ['temp√©rature', 'fi√®vre'],
        questions: commonQuestions.fever
    },
    'frisson': { // Variante fi√®vre
        keywords: ['frissons', 'fi√®vre'],
        questions: commonQuestions.fever
    },

    // Traumatisme / Blessures
    'tomber': {
        keywords: ['chute', 'tomb√©(e)', 'perte d\'√©quilibre'],
        questions: commonQuestions.fall
    },
     'chute': { // Variante
        keywords: ['chute', 'tomb√©(e)'],
        questions: commonQuestions.fall
    },
    'cogn√©': {
        keywords: ['choc', 'coup', 'contusion'],
        questions: [
            'Quelle partie du corps a re√ßu le choc ?',
            'Y a-t-il un gonflement, un bleu ou une plaie ouverte ?',
            'Avez-vous des douleurs intenses ou des difficult√©s √† bouger ?'
        ]
    },
     'coupure': { /* ... */ }, // Garder vos d√©finitions pr√©c√©dentes ou les adapter
     'plaie': { /* ... */ },
     'br√ªlure': { /* ... */ },
     'saigne': { /* ... */ },

    // Neuro / Conscience
    'vertige': { /* ... */ },
    '√©vanoui': { /* ... */ },
    'connaissance': { /* ... */ },

    // Allergies
    'allergie': {
        keywords: ['r√©action allergique', 'allergie', '√©ruption'],
        questions: commonQuestions.allergy
    },
    'gonflement': {
         keywords: ['gonflement', '≈ìd√®me'],
         questions: [ /* ... gardez les questions pr√©c√©dentes pour gonflement ... */
             'Quelle partie du corps est gonfl√©e ?',
             'Est-ce apparu soudainement ?',
             'Est-ce douloureux, rouge ou chaud ?',
             'Avez-vous des difficult√©s √† respirer ?'
         ]
    },

    // Digestif
    'naus√©e': { // Mot-cl√© pour les naus√©es
        keywords: ['naus√©e', 'envie de vomir', 'mal au c≈ìur'], // Ajout "mal au c≈ìur" ici
        questions: commonQuestions.nausea
    },
     'vomi': { // Variante
        keywords: ['vomissements', 'naus√©e'],
        questions: commonQuestions.nausea
    },
    'diarrh√©e': { /* ... */ },

    // Ajoutez d'autres...
};

/**
 * Analyse SIMPLEMENT le texte des sympt√¥mes bas√© sur des mots-cl√©s pr√©d√©finis.
 * @param {string} symptomText - La description des sympt√¥mes.
 * @returns {object} Un objet { keywords: string[], suggestedQuestions: string[] }.
 */
export const analyzeSymptomsSimple = (symptomText) => {
    if (!symptomText || typeof symptomText !== 'string' || symptomText.trim().length < 5) {
         console.log("[Simple Analysis] Texte trop court ou invalide, retour vide.");
        return { keywords: [], suggestedQuestions: [] };
    }

    console.log(`[Simple Analysis] Analyse du texte: "${symptomText.substring(0, 70)}..."`);
    const textLower = symptomText.toLowerCase();
    const foundKeywords = new Set();
    const suggestedQuestions = new Set();
    let questionCount = 0;
    const maxQuestions = 3; // Limite du nombre total de questions √† sugg√©rer

    // Parcourir les mots d√©clencheurs d√©finis
    for (const triggerWord in symptomMappings) {
        // Utiliser includes() pour une recherche de sous-cha√Æne simple et robuste
        if (textLower.includes(triggerWord)) {
            console.log(`[Simple Analysis] Mot d√©clencheur trouv√©: "${triggerWord}"`);

            // Ajouter les mots-cl√©s associ√©s (√©vite les doublons gr√¢ce au Set)
            symptomMappings[triggerWord].keywords.forEach(kw => foundKeywords.add(kw));

            // Ajouter les questions associ√©es sans d√©passer la limite et sans doublons
            symptomMappings[triggerWord].questions.forEach(q => {
                if (questionCount < maxQuestions && !suggestedQuestions.has(q)) {
                    suggestedQuestions.add(q);
                    questionCount++;
                }
            });
        }
         // Optionnel: sortir de la boucle si on a d√©j√† assez de questions
         // if (questionCount >= maxQuestions) break;
    }

    // Optionnel: ajouter une question g√©n√©rique si absolument rien n'a √©t√© trouv√©
    if (foundKeywords.size === 0 && suggestedQuestions.size === 0 && textLower.length > 15) {
        console.log("[Simple Analysis] Aucun mot-cl√© trouv√©, ajout de questions g√©n√©riques.");
        suggestedQuestions.add("Pouvez-vous d√©crire plus pr√©cis√©ment le sympt√¥me principal ?");
        if (suggestedQuestions.size < maxQuestions) {
             suggestedQuestions.add("Quand ces sympt√¥mes ont-ils commenc√© ?");
        }
    }

    // Convertir les Sets en Array pour le retour JSON
    const result = {
        keywords: [...foundKeywords],
        suggestedQuestions: [...suggestedQuestions]
    };

    console.log("[Simple Analysis] R√©sultat final:", result);
    return result;
};
</file>

<file path="services/waitTimeService.js">
// backend/services/waitTimeService.js
import EmergencyPatient from '../models/EmergencyPatient.js';
// Correction: Utiliser l'import nomm√© avec les accolades
import { User } from '../models/User.js'; // Assurez-vous que le chemin est correct

// --- Logique Heuristique Simple ---
// Ces valeurs sont des exemples, √† ajuster selon la r√©alit√© de l'h√¥pital
const BASE_WAIT_TIME_MINUTES = {
    critical: 5, // Temps incompressible pour pr√©parer
    high: 15,
    medium: 30,
    low: 60,
    default: 45 // Si niveau non d√©fini ou invalide
};

const PEAK_HOURS_START = 8; // 8h du matin
const PEAK_HOURS_END = 18; // 18h (6 PM)
const PEAK_HOUR_FACTOR = 1.5; // Augmente le temps de 50% pendant les heures de pointe
const WEEKEND_FACTOR = 1.2; // Augmente le temps de 20% le week-end (Samedi/Dimanche)
const PATIENT_LOAD_FACTOR_PER_PATIENT = 5; // Ajoute 5 minutes par autre patient en attente r√©cente
const DOCTOR_AVAILABILITY_FACTOR = 0.8; // R√©duit le temps de 20% si plus de 2 m√©decins sont disponibles
const MIN_WAIT_TIME = 5; // Temps d'attente minimum absolu (en minutes)
const MAX_WAIT_TIME = 180; // Temps d'attente maximum pour √©viter les estimations excessives (en minutes)

/**
 * Estime le temps d'attente pour un patient donn√© bas√© sur des heuristiques simples.
 * @param {string} patientId - L'ID du patient d'urgence.
 * @returns {Promise<string>} Une estimation textuelle du temps d'attente (ex: "environ 20-30 minutes").
 * @throws {Error} Si le patient n'est pas trouv√© ou en cas d'erreur.
 */
export const getEstimatedWaitTime = async (patientId) => {
    console.log(`[WaitTime] D√©but estimation pour patient ID: ${patientId}`);
    try {
        const patient = await EmergencyPatient.findById(patientId);
        if (!patient) {
            console.error(`[WaitTime] Patient non trouv√©: ${patientId}`);
            throw new Error("Patient non trouv√©.");
        }

        // 1. Temps de base selon le niveau d'urgence
        // Utiliser 'toLowerCase()' pour la robustesse et g√©rer le cas o√π le niveau est null/undefined
        const emergencyLevel = patient.emergencyLevel?.toLowerCase() || 'default';
        let estimatedTime = BASE_WAIT_TIME_MINUTES[emergencyLevel] || BASE_WAIT_TIME_MINUTES.default;
        console.log(`[WaitTime] Base time for level "${emergencyLevel}": ${estimatedTime.toFixed(0)} min`);

        // 2. Ajustement selon l'heure et le jour
        const submissionTime = new Date(patient.createdAt || Date.now()); // Utiliser createdAt, fallback sur maintenant
        const hour = submissionTime.getHours();
        const day = submissionTime.getDay(); // 0 = Dimanche, 6 = Samedi

        if (hour >= PEAK_HOURS_START && hour < PEAK_HOURS_END) {
            estimatedTime *= PEAK_HOUR_FACTOR;
            console.log(`[WaitTime] Peak hour adjustment applied: ${estimatedTime.toFixed(0)} min`);
        }
        if (day === 0 || day === 6) {
            estimatedTime *= WEEKEND_FACTOR;
            console.log(`[WaitTime] Weekend adjustment applied: ${estimatedTime.toFixed(0)} min`);
        }

        // 3. Ajustement selon la charge (patients en attente)
        // Compter les patients enregistr√©s r√©cemment et non trait√©s/annul√©s
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
        let waitingPatientsCount = 0;
        try {
             waitingPatientsCount = await EmergencyPatient.countDocuments({
                createdAt: { $gte: oneHourAgo },
                 // Statuts consid√©r√©s comme "en attente" ou "en cours"
                status: { $in: ['Demande Enregistr√©e', 'En Cours d\'Examen', 'M√©decin Assign√©', 'M√©decin En Route'] },
                _id: { $ne: patientId } // Exclure le patient actuel du compte
            });
            estimatedTime += waitingPatientsCount * PATIENT_LOAD_FACTOR_PER_PATIENT;
            console.log(`[WaitTime] Load adjustment (+${waitingPatientsCount} waiting patients): ${estimatedTime.toFixed(0)} min`);
        } catch (countError) {
             console.error("[WaitTime] Erreur lors du comptage des patients en attente:", countError);
             // Continuer sans cet ajustement si le comptage √©choue
        }


        // 4. Ajustement (simplifi√©) selon les m√©decins disponibles
        try {
             const availableDoctorsCount = await User.countDocuments({
                 role: 'Doctor',
                 isAvailable: true, // Le champ cl√©
                 isValidated: true // S'assurer qu'ils sont actifs/valid√©s
             });
             console.log(`[WaitTime] M√©decins disponibles: ${availableDoctorsCount}`);
             // Ajustement simple: si peu de m√©decins dispo, le temps peut augmenter l√©g√®rement
             // Si beaucoup de m√©decins dispo, le temps peut diminuer l√©g√®rement
             if (availableDoctorsCount <= 1 && waitingPatientsCount > 0) { // Si peu de m√©decins et charge
                 estimatedTime *= 1.15; // Augmentation modeste
                 console.log(`[WaitTime] Low doctor availability adjustment applied: ${estimatedTime.toFixed(0)} min`);
             } else if (availableDoctorsCount > 3) { // Si > 3 m√©decins dispo
                estimatedTime *= DOCTOR_AVAILABILITY_FACTOR; // R√©duction
                console.log(`[WaitTime] High doctor availability adjustment applied: ${estimatedTime.toFixed(0)} min`);
             }
        } catch (userError) {
            console.error("[WaitTime] Erreur lors de la r√©cup√©ration des m√©decins dispos:", userError);
            // Ne pas planter si la r√©cup√©ration des users √©choue, continuer sans cet ajustement
        }


        // 5. Assurer un temps minimum, appliquer un plafond maximum et arrondir
        estimatedTime = Math.max(MIN_WAIT_TIME, estimatedTime); // Appliquer minimum
        estimatedTime = Math.min(MAX_WAIT_TIME, estimatedTime); // Appliquer maximum
        estimatedTime = Math.round(estimatedTime / 5) * 5; // Arrondir aux 5 minutes les plus proches

        console.log(`[WaitTime] Final estimated (rounded, capped) for ${patientId}: ${estimatedTime} min`);

        // 6. Retourner une fourchette textuelle pour g√©rer l'incertitude
        // Cr√©er une fourchette simple autour du temps estim√©
        const lowerBound = Math.max(MIN_WAIT_TIME, estimatedTime - 5);
        const upperBound = Math.min(MAX_WAIT_TIME, estimatedTime + 10); // Plafonner aussi la borne sup

        // G√©rer le cas o√π la borne inf > sup apr√®s plafonnement
        if (lowerBound >= upperBound) {
            return `environ ${upperBound} minutes`;
        }

        return `environ ${lowerBound}-${upperBound} minutes`;

    } catch (error) {
        // Log l'erreur compl√®te c√¥t√© serveur pour le d√©bogage
        console.error(`[WaitTime] Erreur finale dans getEstimatedWaitTime pour ${patientId}:`, error);
        // Retourner un message g√©n√©rique au client
        return "Estimation indisponible";
    }
};
</file>

<file path="templates/medicalRecordTemplate.html">
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dossier M√©dical - {{patientName}}</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      line-height: 1.6; 
      padding: 20px;
      color: #333;
    }
    .header { 
      text-align: center; 
      margin-bottom: 30px; 
      border-bottom: 2px solid #42A5FF; 
      padding-bottom: 20px; 
    }
    .patient-info { 
      margin-bottom: 30px; 
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
    }
    .file-section { 
      margin-bottom: 30px; 
      border: 1px solid #eee;
      padding: 15px;
      border-radius: 5px;
    }
    .file-header {
      background-color: #f0f7ff;
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
    }
    .logo { 
      max-width: 150px;
      height: auto;
    }
    h1 { color: #42A5FF; }
    h2 { color: #42A5FF; border-bottom: 1px solid #eee; padding-bottom: 5px; }
    h3 { color: #6DDDCF; margin-bottom: 5px; }
    h4 { color: #555; margin-bottom: 5px; margin-top: 15px; }
    hr { border: 0.5px solid #eee; margin: 20px 0; }
    .footer { 
      text-align: center; 
      margin-top: 30px; 
      font-size: 0.8em; 
      color: #777;
      border-top: 1px solid #eee;
      padding-top: 20px;
    }
    .info-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    .info-item {
      margin-bottom: 10px;
    }
    .info-label {
      font-weight: bold;
      color: #555;
      font-size: 0.9em;
    }
    .info-value {
      margin-top: 3px;
    }
    .card {
      border: 1px solid #eee;
      border-radius: 5px;
      padding: 10px;
      margin-bottom: 10px;
      background-color: #fff;
    }
    .card-title {
      font-weight: bold;
      margin-bottom: 5px;
      color: #42A5FF;
    }
    .card-subtitle {
      font-size: 0.8em;
      color: #777;
      margin-bottom: 8px;
    }
    .badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 0.8em;
      font-weight: bold;
    }
    .badge-primary {
      background-color: #E6F3FF;
      color: #42A5FF;
    }
    .badge-secondary {
      background-color: #E6F9F7;
      color: #6DDDCF;
    }
    .badge-warning {
      background-color: #FFF5E6;
      color: #FF9F42;
    }
    .badge-danger {
      background-color: #FFEBEB;
      color: #FF4242;
    }
    .vital-signs-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .vital-sign-card {
      border: 1px solid #eee;
      border-radius: 5px;
      padding: 10px;
      background-color: #f8f9fa;
    }
    .vital-sign-title {
      font-size: 0.8em;
      color: #777;
    }
    .vital-sign-value {
      font-weight: bold;
      font-size: 1.1em;
      color: #333;
    }
    .notes-section {
      background-color: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
      font-style: italic;
    }
    .section-title {
      font-weight: bold;
      margin-bottom: 10px;
      color: #555;
    }
    .allergy-item, .condition-item, .medication-item {
      padding: 8px;
      margin-bottom: 5px;
      border-radius: 5px;
    }
    .allergy-item {
      background-color: #FFEBEB;
      border-left: 3px solid #FF4242;
    }
    .condition-item {
      background-color: #E6F9F7;
      border-left: 3px solid #6DDDCF;
    }
    .medication-item {
      background-color: #E6F3FF;
      border-left: 3px solid #42A5FF;
    }
    .page-break {
      page-break-after: always;
    }
    .confidential {
      text-align: center;
      font-size: 0.7em;
      color: #FF4242;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="header">
    <img src="{{logo}}" class="logo" alt="Logo du site">
    <div class="header-text">
      <h1>Dossier M√©dical √âlectronique</h1>
      <p>Code d'acc√®s: <strong>{{accessCode}}</strong></p>
      <p class="confidential">DOCUMENT CONFIDENTIEL</p>
    </div>
  </div>

  <div class="patient-info">
    <h2>Informations Patient</h2>
    <div class="info-grid">
      <div>
        <div class="info-item">
          <div class="info-label">Nom complet</div>
          <div class="info-value"><strong>{{patientName}}</strong></div>
        </div>
        <div class="info-item">
          <div class="info-label">Date de naissance</div>
          <div class="info-value">{{birthDate}}</div>
        </div>
        <div class="info-item">
          <div class="info-label">Sexe</div>
          <div class="info-value">{{gender}}</div>
        </div>
      </div>
      <div>
        <div class="info-item">
          <div class="info-label">T√©l√©phone</div>
          <div class="info-value">{{phoneNumber}}</div>
        </div>
        <div class="info-item">
          <div class="info-label">Email</div>
          <div class="info-value">{{email}}</div>
        </div>
        <div class="info-item">
          <div class="info-label">Groupe sanguin</div>
          <div class="info-value"><strong>{{bloodType}}</strong></div>
        </div>
      </div>
    </div>
  </div>

  <div class="medical-info">
    <h2>Informations M√©dicales</h2>
    
    {{#if allergies}}
    <h4>Allergies connues :</h4>
    <ul>
      {{#each allergies}}
        <li>{{@index}}. {{this.name}}</li>
      {{/each}}
    </ul>
    {{/if}}
    
    {{#if chronicConditions}}
    <h4>Conditions Chroniques</h4>
    <div>
      {{#each chronicConditions}}
      <div class="condition-item">{{this}}</div>
      {{/each}}
    </div>
    {{/if}}
    
    {{#if medications}}
    <h4>M√©dicaments Actuels</h4>
    <div>
      {{#each medications}}
      <div class="medication-item">
        <div><strong>{{this.name}}</strong></div>
        <div style="font-size: 0.9em;">{{this.dosage}}, {{this.frequency}}</div>
      </div>
      {{/each}}
    </div>
    {{/if}}
  </div>

  {{#if emergencyContact}}
  <div class="emergency-info">
    <h2>Contact d'Urgence</h2>
    <div class="card" style="border-left: 4px solid #FF4242;">
      <div class="info-grid">
        {{#if emergencyContact.name}}
        <div class="info-item">
          <div class="info-label">Nom</div>
          <div class="info-value"><strong>{{emergencyContact.name}}</strong></div>
        </div>
        {{/if}}
        {{#if emergencyContact.relationship}}
        <div class="info-item">
          <div class="info-label">Relation</div>
          <div class="info-value">{{emergencyContact.relationship}}</div>
        </div>
        {{/if}}
        {{#if emergencyContact.phone}}
        <div class="info-item">
          <div class="info-label">T√©l√©phone</div>
          <div class="info-value">{{emergencyContact.phone}}</div>
        </div>
        {{/if}}
      </div>
    </div>
  </div>
  {{/if}}

  <div class="page-break"></div>

  <h2>Documents M√©dicaux</h2>
  {{#each files}}
  <div class="file-section">
    <div class="file-header">
      <h3>{{this.type}}</h3>
      <span>{{this.dateFormatted}}</span>
    </div>

    {{#if this.details.patientInfo}}
    <!-- PatientInformation -->
    <div>
      <h4>Informations Personnelles</h4>
      <div class="info-grid">
        <div>
          {{#if this.details.patientInfo.firstName}}
          <div class="info-item">
            <div class="info-label">Pr√©nom</div>
            <div class="info-value">{{this.details.patientInfo.firstName}}</div>
          </div>
          {{/if}}
          {{#if this.details.patientInfo.lastName}}
          <div class="info-item">
            <div class="info-label">Nom</div>
            <div class="info-value">{{this.details.patientInfo.lastName}}</div>
          </div>
          {{/if}}
          {{#if this.details.patientInfo.dateOfBirth}}
          <div class="info-item">
            <div class="info-label">Date de naissance</div>
            <div class="info-value">{{this.details.patientInfo.dateOfBirth}}</div>
          </div>
          {{/if}}
        </div>
        <div>
          {{#if this.details.patientInfo.gender}}
          <div class="info-item">
            <div class="info-label">Genre</div>
            <div class="info-value">{{this.details.patientInfo.gender}}</div>
          </div>
          {{/if}}
          {{#if this.details.patientInfo.phoneNumber}}
          <div class="info-item">
            <div class="info-label">T√©l√©phone</div>
            <div class="info-value">{{this.details.patientInfo.phoneNumber}}</div>
          </div>
          {{/if}}
          {{#if this.details.patientInfo.email}}
          <div class="info-item">
            <div class="info-label">Email</div>
            <div class="info-value">{{this.details.patientInfo.email}}</div>
          </div>
          {{/if}}
        </div>
      </div>

      {{#if this.details.patientInfo.medicalHistory}}
      <h4>Ant√©c√©dents M√©dicaux</h4>
      <div class="card">
        {{this.details.patientInfo.medicalHistory}}
      </div>
      {{/if}}

      {{#if this.details.patientInfo.currentSymptoms}}
      <h4>Sympt√¥mes Actuels</h4>
      <div class="card">
        {{this.details.patientInfo.currentSymptoms}}
      </div>
      {{/if}}

      <div class="info-grid">
        {{#if this.details.patientInfo.painLevel}}
        <div class="info-item">
          <div class="info-label">Niveau de douleur</div>
          <div class="info-value"><strong>{{this.details.patientInfo.painLevel}}/10</strong></div>
        </div>
        {{/if}}
        {{#if this.details.patientInfo.emergencyLevel}}
        <div class="info-item">
          <div class="info-label">Niveau d'urgence</div>
          <div class="info-value"><strong>{{this.details.patientInfo.emergencyLevel}}</strong></div>
        </div>
        {{/if}}
      </div>
    </div>
    {{/if}}

    {{#if this.details.diagnosis}}
    <!-- Diagnostic -->
    <div>
      <h4>Diagnostic Principal</h4>
      <div class="card">
        {{this.details.diagnosis}}
      </div>

      {{#if this.details.diagnosticTests}}
      <h4>Tests Diagnostiques</h4>
      {{#each this.details.diagnosticTests}}
      <div class="card">
        <div class="card-title">{{this.testName}}</div>
        <div class="card-subtitle">{{this.dateFormatted}}</div>
        <div><strong>R√©sultat:</strong> {{this.result}}</div>
      </div>
      {{/each}}
      {{/if}}
    </div>
    {{/if}}

    {{#if this.details.procedures}}
    <!-- Treatment -->
    <div>
      <h4>Proc√©dures</h4>
      {{#each this.details.procedures}}
      <div class="card">
        <div class="card-title">{{this.name}}</div>
        <div class="card-subtitle">{{this.dateFormatted}}</div>
        {{#if this.notes}}
        <div><strong>Notes:</strong> {{this.notes}}</div>
        {{/if}}
      </div>
      {{/each}}
    </div>
    {{/if}}

    {{#if this.details.vitalSigns}}
    <!-- VitalSigns -->
    <div>
      <h4>Signes Vitaux</h4>
      <div class="vital-signs-grid">
        {{#if this.details.vitalSigns.temperature}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Temp√©rature</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.temperature}} ¬∞C</div>
        </div>
        {{/if}}
        
        {{#if this.details.vitalSigns.bloodPressure}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Pression art√©rielle</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.bloodPressure.systolic}}/{{this.details.vitalSigns.bloodPressure.diastolic}} mmHg</div>
        </div>
        {{/if}}
        
        {{#if this.details.vitalSigns.heartRate}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Fr√©quence cardiaque</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.heartRate}} bpm</div>
        </div>
        {{/if}}
        
        {{#if this.details.vitalSigns.respiratoryRate}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Fr√©quence respiratoire</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.respiratoryRate}} resp/min</div>
        </div>
        {{/if}}
        
        {{#if this.details.vitalSigns.oxygenSaturation}}
        <div class="vital-sign-card">
          <div class="vital-sign-title">Saturation en oxyg√®ne</div>
          <div class="vital-sign-value">{{this.details.vitalSigns.oxygenSaturation}}%</div>
        </div>
        {{/if}}
      </div>
    </div>
    {{/if}}

    {{#if this.details.priorityLevel}}
    <!-- Triage -->
    <div>
      <h4>Niveau de Priorit√©</h4>
      <div class="card">
        <div><strong>{{this.details.priorityLevel}}</strong></div>
      </div>
      
      {{#if this.details.chiefComplaint}}
      <h4>Plainte Principale</h4>
      <div class="card">
        {{this.details.chiefComplaint}}
      </div>
      {{/if}}
    </div>
    {{/if}}

    {{#if this.details.dischargeInstructions}}
    <!-- Discharge -->
    <div>
      <h4>Instructions de Sortie</h4>
      <div class="card">
        {{this.details.dischargeInstructions}}
      </div>
      
      {{#if this.details.followUpDate}}
      <h4>Rendez-vous de Suivi</h4>
      <div class="card">
        {{this.details.followUpDateFormatted}}
      </div>
      {{/if}}
    </div>
    {{/if}}

    {{#if this.details.medications}}
    <!-- Prescription or medications from other types -->
    <div>
      <h4>M√©dicaments</h4>
      {{#each this.details.medications}}
      <div class="card">
        <div class="card-title">{{this.name}}</div>
        <div><strong>Dosage:</strong> {{this.dosage}}</div>
        <div><strong>Fr√©quence:</strong> {{this.frequency}}</div>
        {{#if this.duration}}
        <div><strong>Dur√©e:</strong> {{this.duration}}</div>
        {{/if}}
      </div>
      {{/each}}
    </div>
    {{/if}}

    {{#if this.notes}}
    <div class="notes-section">
      <div class="section-title">Notes</div>
      {{this.notes}}
    </div>
    {{/if}}
  </div>

  {{#unless @last}}
  <hr>
  {{/unless}}
  {{/each}}

  <div class="footer">
    <p>Document g√©n√©r√© le {{currentDate}}</p>
    <p>Ce document est strictement confidentiel et prot√©g√© par le secret m√©dical.</p>
  </div>
</body>
</html>
</file>

<file path="utils/pdfGenerator.js">
import pdf from "html-pdf-node"
import fs from "fs"
import path from "path"
import { fileURLToPath } from "url"
import Handlebars from "handlebars"

const __dirname = path.dirname(fileURLToPath(import.meta.url))

// Fonction pour formater une date
const formatDate = (dateString) => {
  if (!dateString) return "Non sp√©cifi√©"
  return new Date(dateString).toLocaleDateString("fr-FR", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  })
}

// Enregistrer les helpers Handlebars
Handlebars.registerHelper("if", function (conditional, options) {
  if (conditional) {
    return options.fn(this)
  } else {
    return options.inverse(this)
  }
})

Handlebars.registerHelper("unless", function (conditional, options) {
  if (!conditional) {
    return options.fn(this)
  } else {
    return options.inverse(this)
  }
})

Handlebars.registerHelper("each", (context, options) => {
  let ret = ""

  for (let i = 0, j = context.length; i < j; i++) {
    // Ajouter une propri√©t√© @index et @last
    context[i]["@index"] = i
    context[i]["@last"] = i === context.length - 1
    ret = ret + options.fn(context[i])
  }

  return ret
})

export const generateMedicalRecordPDF = async (medicalRecord, patientFiles) => {
  const templatePath = path.join(__dirname, "../../backend/templates/medicalRecordTemplate.html")
  const logoPath = path.join(__dirname, "../../backend/utils/logo1.png")

  // Formatage des donn√©es
  const currentDate = formatDate(new Date())

  // Lire le logo et le convertir en base64
  const logoBuffer = fs.readFileSync(logoPath)
  const base64Logo = logoBuffer.toString("base64")
  const logoDataURI = `data:image/png;base64,${base64Logo}`

  // Pr√©parer les fichiers avec des dates format√©es
  const formattedFiles = patientFiles.map((file) => {
    // Cr√©er une copie profonde du fichier pour √©viter de modifier l'original
    const formattedFile = JSON.parse(JSON.stringify(file))

    // Formater la date d'enregistrement
    formattedFile.dateFormatted = formatDate(file.dateRecorded)

    // Formater les dates dans les tests diagnostiques
    if (file.details?.diagnosticTests?.length > 0) {
      formattedFile.details.diagnosticTests.forEach((test) => {
        test.dateFormatted = formatDate(test.date)
      })
    }

    // Formater les dates dans les proc√©dures
    if (file.details?.procedures?.length > 0) {
      formattedFile.details.procedures.forEach((procedure) => {
        procedure.dateFormatted = formatDate(procedure.date)
      })
    }

    // Formater la date de suivi
    if (file.details?.followUpDate) {
      formattedFile.details.followUpDateFormatted = formatDate(file.details.followUpDate)
    }

    return formattedFile
  })

  // Pr√©parer les donn√©es pour le template
  const templateData = {
    logo: logoDataURI,
    patientName: `${medicalRecord.patientId?.firstName || ""} ${medicalRecord.patientId?.lastName || ""}`,
    birthDate: formatDate(medicalRecord.patientId?.dateOfBirth),
    gender: medicalRecord.patientId?.gender || "Non sp√©cifi√©",
    phoneNumber: medicalRecord.patientId?.phoneNumber || "Non sp√©cifi√©",
    email: medicalRecord.patientId?.email || "Non sp√©cifi√©",
    bloodType: medicalRecord.bloodType || "Non sp√©cifi√©",
    accessCode: medicalRecord.accessCode,
    currentDate: currentDate,
    allergies: medicalRecord.knownAllergies?.map(allergy => ({ name: allergy })) || null,
    chronicConditions: medicalRecord.chronicConditions?.map(condition => ({ name: condition })) || null,
    medications: medicalRecord.currentMedications?.map(med => ({
      name: med.name,
      dosage: med.dosage,
      frequency: med.frequency
    })) || null,
        emergencyContact: medicalRecord.emergencyContact || null,
    files: formattedFiles,
  }

  // Lire le template
  const templateSource = fs.readFileSync(templatePath, "utf8")

  // Compiler le template avec Handlebars
  const template = Handlebars.compile(templateSource)

  // G√©n√©rer le HTML final
  const html = template(templateData)

  const options = {
    format: "A4",
    printBackground: true,
    margin: {
      top: "10mm",
      right: "10mm",
      bottom: "10mm",
      left: "10mm",
    },
    displayHeaderFooter: false,
  }

  return new Promise((resolve, reject) => {
    pdf.generatePdf({ content: html }, options, (err, buffer) => {
      if (err) reject(err)
      else resolve(buffer)
    })
  })
}
</file>

<file path="utils/pdfProcessor.js">
// utils/pdfProcessor.js
import fs from 'fs-extra';
import path from 'path';
import { PDFDocument } from 'pdf-lib';
import { exec } from 'child_process';
import util from 'util';
import sharp from 'sharp';

const execPromise = util.promisify(exec);

export const convertPDFToImages = async (pdfPath) => {
  try {
    const outputDir = path.join(path.dirname(pdfPath), 'temp_images');
    await fs.ensureDir(outputDir); // Cr√©er le dossier temporaire
    
    // Utiliser le chemin absolu pour Ghostscript
    const absolutePdfPath = path.resolve(pdfPath);
    
    const { stdout, stderr } = await execPromise(
      `gs -dNOPAUSE -sDEVICE=png16m -r300 -sOutputFile="${path.join(outputDir, 'page-%d.png')}" "${absolutePdfPath}" -dBATCH`
    );


    const files = await fs.readdir(tempDir);
    const imagePaths = files
      .filter(file => file.endsWith('.png'))
      .map(file => path.join(tempDir, file))
      .sort();

    // Optimiser les images pour l'OCR
    const optimizedImages = [];
    for (const imgPath of imagePaths) {
      const optimizedPath = imgPath.replace('.png', '-optimized.png');
      await sharp(imgPath)
        .normalize()  // Am√©liore le contraste
        .linear(1.1, -(128 * 0.1))  // Ajuste la luminosit√©
        .threshold(128, { grayscale: true })  // Binarisation pour certains documents
        .toFile(optimizedPath);
      optimizedImages.push(optimizedPath);
    }

    return optimizedImages;
  } catch (error) {
    console.error('Erreur lors de la conversion PDF en images:', error);
    throw error;
  }
};
</file>

<file path="utils/textParser.js">
// utils/textParser.js
export const extractMedicalData = (text) => {
  const result = {
    patientName: '',
    diagnosis: '',
    tests: [],
    treatments: []
  };

  // Extraire le nom du patient
  const nameMatch = text.match(/Nom et pr√©nom:\s*(.+)/i);
  if (nameMatch) {
    result.patientName = nameMatch[1].trim();
  }

  // Extraire le diagnostic
  const diagnosisMatch = text.match(/DIAGNOSTIQUE\s*([^\n]+)/i);
  if (diagnosisMatch) {
    result.diagnosis = diagnosisMatch[1].trim();
  }

  // Extraire les r√©sultats de test
  const resultMatch = text.match(/RESULTAT\s*([^\n]+)/i);
  if (resultMatch) {
    result.tests.push({
      testName: 'R√©sultats diagnostiques',
      result: resultMatch[1].trim(),
      date: new Date()
    });
  }

  return result;
};
</file>

</files>
